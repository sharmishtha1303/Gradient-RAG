CS229 Lecture Notes Andrew Ng and Tengyu Ma June , Contents I Supervised learning 5 1 Linear regression 8 1.1 LMS algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . 9 1.2 The normal equations . . . . . . . . . . . . . . . . . . . . . . . 1.2.1 Matrix derivatives . . . . . . . . . . . . . . . . . . . . . 1.2.2 Least squares revisited . . . . . . . . . . . . . . . . . . 1.3 Probabilistic interpretation . . . . . . . . . . . . . . . . . . . . 1.4 Locally weighted linear regression (optional reading) . . . . . . 2 Classification and logistic regression 2.1 Logistic regression . . . . . . . . . . . . . . . . . . . . . . . . 2.2 Digression: the perceptron learning algorithm . . . . . . . . . 2.3 Multiclass classification . . . . . . . . . . . . . . . . . . . . . 2.4 Another algorithm for maximizing (cid:)() . . . . . . . . . . . . . 3 Generalized linear models 3.1 The exponential family . . . . . . . . . . . . . . . . . . . . . . 3.2 Constructing GLMs . . . . . . . . . . . . . . . . . . . . . . . . 3.2.1 Ordinary least squares . . . . . . . . . . . . . . . . . . 3.2.2 Logistic regression . . . . . . . . . . . . . . . . . . . . 4 Generative learning algorithms 4.1 Gaussian discriminant analysis . . . . . . . . . . . . . . . . . . 4.1.1 The multivariate normal distribution . . . . . . . . . . 4.1.2 The Gaussian discriminant analysis model . . . . . . . 4.1.3 Discussion: GDA and logistic regression . . . . . . . . 4.2 Naive bayes (Option Reading) . . . . . . . . . . . . . . . . . . 4.2.1 Laplace smoothing . . . . . . . . . . . . . . . . . . . . 4.2.2 Event models for text classification . . . . . . . . . . . 1 CS229 Spring 2 5 Kernel methods 5.1 Feature maps . . . . . . . . . . . . . . . . . . . . . . . . . . . 5.2 LMS (least mean squares) with features . . . . . . . . . . . . . 5.3 LMS with the kernel trick . . . . . . . . . . . . . . . . . . . . 5.4 Properties of kernels . . . . . . . . . . . . . . . . . . . . . . . 6 Support vector machines 6.1 Margins: intuition . . . . . . . . . . . . . . . . . . . . . . . . . 6.2 Notation (option reading) . . . . . . . . . . . . . . . . . . . . 6.3 Functional and geometric margins (option reading) . . . . . . 6.4 The optimal margin classifier (option reading) . . . . . . . . . 6.5 Lagrange duality (optional reading) . . . . . . . . . . . . . . . 6.6 Optimal margin classifiers: the dual form (option reading) . . 6.7 Regularization and the nonseparable case (optional reading) . 6.8 The SMO algorithm (optional reading) . . . . . . . . . . . . . 6.8.1 Coordinate ascent . . . . . . . . . . . . . . . . . . . . . 6.8.2 SMO . . . . . . . . . . . . . . . . . . . . . . . . . . . . II Deep learning 7 Deep learning 7.1 Supervised learning with nonlinear models . . . . . . . . . . . 7.2 Neural networks . . . . . . . . . . . . . . . . . . . . . . . . . . 7.3 Modules in Modern Neural Networks . . . . . . . . . . . . . . 7.4 Backpropagation . . . . . . . . . . . . . . . . . . . . . . . . . 7.4.1 Preliminaries on partial derivatives . . . . . . . . . . . 7.4.2 General strategy of backpropagation . . . . . . . . . . 7.4.3 Backward functions for basic modules . . . . . . . . . . 7.4.4 Backpropagation for MLPs . . . . . . . . . . . . . . . 7.5 Vectorization over training examples . . . . . . . . . . . . . . III Generalization and regularization 8 Generalization 8.1 Biasvariance tradeoff . . . . . . . . . . . . . . . . . . . . . . . 8.1.1 A mathematical decomposition (for regression) . . . . . 8.2 The double descent phenomenon . . . . . . . . . . . . . . . . . 8.3 Sample complexity bounds (optional readings) . . . . . . . . . CS229 Spring 3 8.3.1 Preliminaries . . . . . . . . . . . . . . . . . . . . . . . 8.3.2 The case of finite H . . . . . . . . . . . . . . . . . . . . 8.3.3 The case of infinite H . . . . . . . . . . . . . . . . . . 9 Regularization and model selection 9.1 Regularization . . . . . . . . . . . . . . . . . . . . . . . . . . . 9.2 Implicit regularization effect (optional reading) . . . . . . . . . 9.3 Model selection via cross validation . . . . . . . . . . . . . . . 9.4 Bayesian statistics and regularization . . . . . . . . . . . . . . IV Unsupervised learning Clustering and the kmeans algorithm EM algorithms .1 EM for mixture of Gaussians . . . . . . . . . . . . . . . . . . . .2 Jensens inequality . . . . . . . . . . . . . . . . . . . . . . . . .3 General EM algorithms . . . . . . . . . . . . . . . . . . . . . . .3.1 Other interpretation of ELBO . . . . . . . . . . . . . . .4 Mixture of Gaussians revisited . . . . . . . . . . . . . . . . . . .5 Variational inference and variational autoencoder (optional reading) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Principal components analysis Independent components analysis .1 ICA ambiguities . . . . . . . . . . . . . . . . . . . . . . . . . . .2 Densities and linear transformations . . . . . . . . . . . . . . . .3 ICA algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . Selfsupervised learning and foundation models .1 Pretraining and adaptation . . . . . . . . . . . . . . . . . . . . .2 Pretraining methods in computer vision . . . . . . . . . . . . . .3 Pretrained large language models . . . . . . . . . . . . . . . . .3.1 Open up the blackbox of Transformers . . . . . . . . . .3.2 Zeroshot learning and incontext learning . . . . . . . CS229 Spring 4 V Reinforcement Learning and Control Reinforcement learning .1 Markov decision processes . . . . . . . . . . . . . . . . . . . . .2 Value iteration and policy iteration . . . . . . . . . . . . . . . .3 Learning a model for an MDP . . . . . . . . . . . . . . . . . . .4 Continuous state MDPs . . . . . . . . . . . . . . . . . . . . . .4.1 Discretization . . . . . . . . . . . . . . . . . . . . . . . .4.2 Value function approximation . . . . . . . . . . . . . . .5 Connections between Policy and Value Iteration (Optional) . . LQR, DDP and LQG .1 Finitehorizon MDPs . . . . . . . . . . . . . . . . . . . . . . . .2 Linear Quadratic Regulation (LQR) . . . . . . . . . . . . . . . .3 From nonlinear dynamics to LQR . . . . . . . . . . . . . . . .3.1 Linearization of dynamics . . . . . . . . . . . . . . . . .3.2 Differential Dynamic Programming (DDP) . . . . . . . .4 Linear Quadratic Gaussian (LQG) . . . . . . . . . . . . . . . . Policy Gradient (REINFORCE) Part I Supervised learning 5 6 Lets start by talking about a few examples of supervised learning prob lems. Suppose we have a dataset giving the living areas and prices of houses from Portland, Oregon: Living area (feet2) Price (s) . . . . . . We can plot this data: housing prices 0 square feet ) ni( ecirp Givendatalikethis, howcanwelearntopredictthepricesofotherhouses in Portland, as a function of the size of their living areas? To establish notation for future use, well use x(i) to denote the input variables (living area in this example), also called input features, and y(i) to denote the output or target variable that we are trying to predict (price). A pair (x(i),y(i)) is called a training example, and the dataset that well be using to learna list of n training examples (x(i),y(i));i  1,...,nis called a training set. Note that the superscript (i) in the notation is simply an index into the training set, and has nothing to do with exponentiation. We will also use X denote the space of input values, and Y the space of output values. In this example, X  Y  R. To describe the supervised learning problem slightly more formally, our goal is, given a training set, to learn a function h : X (cid:) Y so that h(x) is a good predictor for the corresponding value of y. For historical reasons, this 7 function h is called a hypothesis. Seen pictorially, the process is therefore like this: Training set Learning algorithm x h predicted y (living area of (predicted price) house.) of house) When the target variable that were trying to predict is continuous, such as in our housing example, we call the learning problem a regression prob lem. When y can take on only a small number of discrete values (such as if, given the living area, we wanted to predict if a dwelling is a house or an apartment, say), we call it a classification problem. Chapter 1 Linear regression To make our housing example more interesting, lets consider a slightly richer dataset in which we also know the number of bedrooms in each house: Living area (feet2) bedrooms Price (s) 3 3 3 2 4 . . . . . . . . . Here, the xs are twodimensional vectors in R2. For instance, x(i) is the 1 living area of the ith house in the training set, and x(i) is its number of 2 bedrooms. (In general, when designing a learning problem, it will be up to you to decide what features to choose, so if you are out in Portland gathering housing data, you might also decide to include other features such as whether each house has a fireplace, the number of bathrooms, and so on. Well say more about feature selection later, but for now lets take the features as given.) To perform supervised learning, we must decide how were going to rep resent functionshypotheses h in a computer. As an initial choice, lets say we decide to approximate y as a linear function of x: h (x)    x  x  0 1 1 2 2 Here, the  s are the parameters (also called weights) parameterizing the i space of linear functions mapping from X to Y. When there is no risk of 8 9 confusion, we will drop the  subscript in h (x), and write it more simply as  h(x). To simplify our notation, we also introduce the convention of letting x  1 (this is the intercept term), so that 0 d (cid:) h(x)   x  Tx, i i i0 where on the righthand side above we are viewing  and x both as vectors, and here d is the number of input variables (not counting x ). 0 Now, given a training set, how do we pick, or learn, the parameters ? One reasonable method seems to be to make h(x) close to y, at least for the training examples we have. To formalize this, we will define a function that measures, for each value of the s, how close the h(x(i))s are to the corresponding y(i)s. We define the cost function: n 1 (cid:) J()  (h (x(i))y(i))2.  2 i1 If youve seen linear regression before, you may recognize this as the familiar leastsquares cost function that gives rise to the ordinary least squares regression model. Whether or not you have seen it previously, lets keep going, and well eventually show this to be a special case of a much broader family of algorithms. 1.1 LMS algorithm We want to choose  so as to minimize J(). To do so, lets use a search algorithm that starts with some initial guess for , and that repeatedly changes  to make J() smaller, until hopefully we converge to a value of  that minimizes J(). Specifically, lets consider the gradient descent algorithm, which starts with some initial , and repeatedly performs the update:   :   J(). j j  j (This update is simultaneously performed for all values of j  0,...,d.) Here,  is called the learning rate. This is a very natural algorithm that repeatedly takes a step in the direction of steepest decrease of J. In order to implement this algorithm, we have to work out what is the partial derivative term on the right hand side. Lets first work it out for the case of if we have only one training example (x,y), so that we can neglect the sum in the definition of J. We have:   1 J()  (h (x)y)2    2 j j 1   2 (h (x)y) (h (x)y)   2  j (cid:) (cid:) d  (cid:)  (h (x)y)  x y  i i  j i0  (h (x)y)x  j For a single training example, this gives the update rule:1  :   (cid:0) y(i) h (x(i)) (cid:1) x(i). j j  j TheruleiscalledtheLMSupdaterule(LMSstandsforleastmeansquares), and is also known as the WidrowHoff learning rule. This rule has several properties that seem natural and intuitive. For instance, the magnitude of the update is proportional to the error term (y(i)  h (x(i))); thus, for in  stance, if we are encountering a training example on which our prediction nearly matches the actual value of y(i), then we find that there is little need to change the parameters; in contrast, a larger change to the parameters will be made if our prediction h (x(i)) has a large error (i.e., if it is very far from  y(i)). Wed derived the LMS rule for when there was only a single training example. There are two ways to modify this method for a training set of more than one example. The first is replace it with the following algorithm: Repeat until convergence  n  :   (cid:)(cid:0) y(i) h (x(i)) (cid:1) x(i),(for every j) (1.1) j j  j i1  1We use the notation a : b to denote an operation (in a computer program) in which we set the value of a variable a to be equal to the value of b. In other words, this operation overwrites a with the value of b. In contrast, we will write ab when we are asserting a statement of fact, that the value of a is equal to the value of b. By grouping the updates of the coordinates into an update of the vector , we can rewrite update (1.1) in a slightly more succinct way: n (cid:)(cid:0) (cid:1)  :  y(i) h (x(i)) x(i)  i1 The reader can easily verify that the quantity in the summation in the update rule above is just J() (for the original definition of J). So, this j is simply gradient descent on the original cost function J. This method looks at every example in the entire training set on every step, and is called batch gradient descent. Note that, while gradient descent can be susceptible to local minima in general, the optimization problem we have posed here for linear regression has only one global, and no other local, optima; thus gradient descent always converges (assuming the learning rate  is not too large) to the global minimum. Indeed, J is a convex quadratic function. Here is an example of gradient descent as it is run to minimize a quadratic function. 5 5 The ellipses shown above are the contours of a quadratic function. Also shown is the trajectory taken by gradient descent, which was initialized at (,). The xs in the figure (joined by straight lines) mark the successive values of  that gradient descent went through. When we run batch gradient descent to fit  on our previous dataset, to learn to predict housing price as a function of living area, we obtain   .,   0.. If we plot h (x) as a function of x (area), along 0 1  with the training data, we obtain the following figure: housing prices 0 square feet ) ni( ecirp If the number of bedrooms were included as one of the input features as well, we get   .,  0.,   8.. 0 1 2 The above results were obtained with batch gradient descent. There is an alternative to batch gradient descent that also works very well. Consider the following algorithm: Loop  for i  1 to n,   :   (cid:0) y(i) h (x(i)) (cid:1) x(i), (for every j) (1.2) j j  j   By grouping the updates of the coordinates into an update of the vector , we can rewrite update (1.2) in a slightly more succinct way: (cid:0) (cid:1)  :  y(i) h (x(i)) x(i)  In this algorithm, we repeatedly run through the training set, and each time we encounter a training example, we update the parameters according to the gradient of the error with respect to that single training example only. This algorithm is called stochastic gradient descent (also incremental gradient descent). Whereas batch gradient descent has to scan through the entire training set before taking a single stepa costly operation if n is largestochastic gradient descent can start making progress right away, and continues to make progress with each example it looks at. Often, stochastic gradient descent gets  close to the minimum much faster than batch gra dient descent. (Note however that it may never converge to the minimum, and the parameters  will keep oscillating around the minimum of J(); but in practice most of the values near the minimum will be reasonably good approximations to the true minimum.2) For these reasons, particularly when the training set is large, stochastic gradient descent is often preferred over batch gradient descent. 1.2 The normal equations Gradient descent gives one way of minimizing J. Lets discuss a second way of doing so, this time performing the minimization explicitly and without resorting to an iterative algorithm. In this method, we will minimize J by explicitly taking its derivatives with respect to the  s, and setting them to j zero. To enable us to do this without having to write reams of algebra and pages full of matrices of derivatives, lets introduce some notation for doing calculus with matrices. 1.2.1 Matrix derivatives For a function f : Rnd (cid:) R mapping from nbyd matrices to the real numbers, we define the derivative of f with respect to A to be:  f  f   A f(A)    A . . . ... A . . . 1d   f  f An1 A nd Thus, the gradient  f(A) is itself an nbyd matrix, whose (i,j)element is A (cid:) (cid:) A A fA . For example, suppose A  is a 2by2 matrix, and ij A A the function f : R22 (cid:) R is given by 3 f(A)  A 5A2 A A . 2 2By slowly letting the learning rate  decrease to zero as the algorithm runs, it is also possible to ensure that the parameters will converge to the global minimum rather than merely oscillate around the minimum. Here, A denotes the (i,j) entry of the matrix A. We then have ij (cid:) (cid:) 3 10A  f(A)  2 . A A A 1.2.2 Least squares revisited Armed with the tools of matrix derivatives, let us now proceed to find in closedform the value of  that minimizes J(). We begin by rewriting J in matrixvectorial notation. Givenatrainingset, definethedesign matrixX tobethenbydmatrix (actually nbyd  1, if we include the intercept term) that contains the training examples input values in its rows:    (x(1))T    (x(2))T   X   . .  .  .    (x(n))T  Also, let (cid:)y be the ndimensional vector containing all the target values from the training set:   y(1)  y(2)  (cid:)y   . .  .  .   y(n) Now, since h (x(i))  (x(i))T, we can easily verify that      (x(1))T y(1) . . X(cid:)y   . .  . .      (x(n))T y(n)   h (x(1))y(1)  .   . . .   h (x(n))y(n)  Thus, using the fact that for a vector z, we have that zTz  (cid:) z2: i i n 1 1 (cid:) (X(cid:)y)T(X(cid:)y)  (h (x(i))y(i))2  2 2 i1  J() Finally, to minimize J, lets find its derivatives with respect to . Hence, 1  J()   (X(cid:)y)T(X(cid:)y)   2 1 (cid:0) (cid:1)   (X)TX(X)T(cid:)y (cid:)yT(X)(cid:)yT(cid:)y  2 1 (cid:0) (cid:1)   T(XTX)(cid:)yT(X)(cid:)yT(X)  2 1 (cid:0) (cid:1)   T(XTX)2(XT(cid:)y)T  2 1 (cid:0) (cid:1)  2XTX2XT(cid:)y 2  XTXXT(cid:)y In the third step, we used the fact that aTb  bTa, and in the fifth step used the facts  bTx  b and  xTAx  2Ax for symmetric matrix A (for x x more details, see Section 4.3 of Linear Algebra Review and Reference). To minimizeJ, wesetitsderivativestozero, andobtainthenormal equations: XTX  XT(cid:)y Thus, the value of  that minimizes J() is given in closed form by the equation   (XTX)1XT(cid:)y.3 1.3 Probabilistic interpretation When faced with a regression problem, why might linear regression, and specifically why might the leastsquares cost function J, be a reasonable choice? In this section, we will give a set of probabilistic assumptions, under which leastsquares regression is derived as a very natural algorithm. Let us assume that the target variables and the inputs are related via the equation y(i)  Tx(i) (cid:)(i), 3Note that in the above step, we are implicitly assuming that XTX is an invertible matrix. This can be checked before calculating the inverse. If either the number of linearly independent examples is fewer than the number of features, or if the features are not linearly independent, then XTX will not be invertible. Even in such cases, it is possible to fix the situation with additional techniques, which we skip here for the sake of simplicty. where (cid:)(i) is an error term that captures either unmodeled effects (such as if there are some features very pertinent to predicting housing price, but that wed left out of the regression), or random noise. Let us further assume that the (cid:)(i) are distributed IID (independently and identically distributed) according to a Gaussian distribution (also called a Normal distribution) with mean zero and some variance 2. We can write this assumption as (cid:)(i)  N(0,2). I.e., the density of (cid:)(i) is given by 1 (cid:) ((cid:)(i))2(cid:) p((cid:)(i))   exp  . 2 22 This implies that 1 (cid:) (y(i) Tx(i))2(cid:) p(y(i)x(i);)   exp  . 2 22 The notation p(y(i)x(i);) indicates that this is the distribution of y(i) given x(i) and parameterized by . Note that we should not condition on  (p(y(i)x(i),)), since  is not a random variable. We can also write the distribution of y(i) as y(i)  x(i);  N(Tx(i),2). Given X (the design matrix, which contains all the x(i)s) and , what is the distribution of the y(i)s? The probability of the data is given by p((cid:)yX;). This quantity is typically viewed a function of (cid:)y (and perhaps X), for a fixed value of . When we wish to explicitly view this as a function of , we will instead call it the likelihood function: L()  L(;X,(cid:)y)  p((cid:)yX;). Note that by the independence assumption on the (cid:)(i)s (and hence also the y(i)s given the x(i)s), this can also be written n (cid:) L()  p(y(i)  x(i);) i1 (cid:) n 1 (cid:) (y(i) Tx(i))2(cid:)   exp  . 2 22 i1 Now, given this probabilistic model relating the y(i)s and the x(i)s, what is a reasonable way of choosing our best guess of the parameters ? The principal of maximum likelihood says that we should choose  so as to make the data as high probability as possible. I.e., we should choose  to maximize L(). Instead of maximizing L(), we can also maximize any strictly increasing function of L(). In particular, the derivations will be a bit simpler if we instead maximize the log likelihood (cid:)(): (cid:)()  logL() (cid:) n 1 (cid:) (y(i) Tx(i))2(cid:)  log  exp  2 22 i1 (cid:) n 1 (cid:) (y(i) Tx(i))2(cid:)  log  exp  2 22 i1 n 1 1 1 (cid:)  nlog    (y(i) Tx(i))2. 2 2 2 i1 Hence, maximizing (cid:)() gives the same answer as minimizing n 1 (cid:) (y(i) Tx(i))2, 2 i1 which we recognize to be J(), our original leastsquares cost function. To summarize: Under the previous probabilistic assumptions on the data, leastsquares regression corresponds to finding the maximum likelihood esti mate of . This is thus one set of assumptions under which leastsquares re gression can be justified as a very natural method thats just doing maximum likelihood estimation. (Note however that the probabilistic assumptions are by no means necessary for leastsquares to be a perfectly good and rational procedure, and there mayand indeed there areother natural assumptions that can also be used to justify it.) Note also that, in our previous discussion, our final choice of  did not depend on what was 2, and indeed wed have arrived at the same result even if 2 were unknown. We will use this fact again later, when we talk about the exponential family and generalized linear models. 1.4 Locally weighted linear regression (optional reading) Consider the problem of predicting y from x  R. The leftmost figure below shows the result of fitting a y    x to a dataset. We see that the data 0 1 doesnt really lie on straight line, and so the fit is not very good. 4.5 4 3.5 3 2.5 2 1.5 1 0.5 1 2 3 x 4 5 6 7 y 4.5 4 3.5 3 2.5 2 1.5 1 0.5 1 2 3 x 4 5 6 7 y 4.5 4 3.5 3 2.5 2 1.5 1 0.5 1 2 3 x 4 5 6 7 y Instead, if we had added an extra feature x2, and fit y    x x2, 0 1 2 then we obtain a slightly better fit to the data. (See middle figure) Naively, it might seem that the more features we add, the better. However, there is also a danger in adding too many features: The rightmost figure is the result of fitting a 5th order polynomial y  (cid:)5  xj. We see that even though the j0 j fitted curve passes through the data perfectly, we would not expect this to be a very good predictor of, say, housing prices (y) for different living areas (x). Without formally defining what these terms mean, well say the figure on the left shows an instance of underfittingin which the data clearly shows structure not captured by the modeland the figure on the right is an example of overfitting. (Later in this class, when we talk about learning theory well formalize some of these notions, and also define more carefully just what it means for a hypothesis to be good or bad.) As discussed previously, and as shown in the example above, the choice of features is important to ensuring good performance of a learning algorithm. (When we talk about model selection, well also see algorithms for automat ically choosing a good set of features.) In this section, let us briefly talk about the locally weighted linear regression (LWR) algorithm which, assum ing there is sufficient training data, makes the choice of features less critical. This treatment will be brief, since youll get a chance to explore some of the properties of the LWR algorithm yourself in the homework. Intheoriginallinearregressionalgorithm, tomakeapredictionataquery point x (i.e., to evaluate h(x)), we would: 1. Fit  to minimize (cid:) (y(i) Tx(i))2. i 2. Output Tx. In contrast, the locally weighted linear regression algorithm does the fol lowing: 1. Fit  to minimize (cid:) w(i)(y(i) Tx(i))2. i 2. Output Tx. Here, the w(i)s are nonnegative valued weights. Intuitively, if w(i) is large for a particular value of i, then in picking , well try hard to make (y(i)  Tx(i))2 small. If w(i) is small, then the (y(i)  Tx(i))2 error term will be pretty much ignored in the fit. A fairly standard choice for the weights is4 (cid:) (x(i) x)2(cid:) w(i)  exp  22 Note that the weights depend on the particular point x at which were trying to evaluate x. Moreover, if x(i)  x is small, then w(i) is close to 1; and if x(i)  x is large, then w(i) is small. Hence,  is chosen giving a much higher weight to the (errors on) training examples close to the query point x. (Note also that while the formula for the weights takes a form that is cosmetically similar to the density of a Gaussian distribution, the w(i)s do not directly have anything to do with Gaussians, and in particular the w(i) are not random variables, normally distributed or otherwise.) The parameter  controls how quickly the weight of a training example falls off with distance of its x(i) from the query point x;  is called the bandwidth parameter, and is also something that youll get to experiment with in your homework. Locally weighted linear regression is the first example were seeing of a nonparametric algorithm. The (unweighted) linear regression algorithm that we saw earlier is known as a parametric learning algorithm, because it has a fixed, finite number of parameters (the  s), which are fit to the i data. Once weve fit the  s and stored them away, we no longer need to i keep the training data around to make future predictions. In contrast, to make predictions using locally weighted linear regression, we need to keep the entire training set around. The term nonparametric (roughly) refers to the fact that the amount of stuff we need to keep in order to represent the hypothesis h grows linearly with the size of the training set. 4Ifxisvectorvalued,thisisgeneralizedtobew(i) exp((x(i)x)T(x(i)x)(22)), or w(i) exp((x(i)x)T1(x(i)x)(22)), for an appropriate choice of  or . Chapter 2 Classification and logistic regression Letsnowtalkabouttheclassificationproblem. Thisisjustliketheregression problem, except that the values y we now want to predict take on only a small number of discrete values. For now, we will focus on the binary classification problem in which y can take on only two values, 0 and 1. (Most of what we say here will also generalize to the multipleclass case.) For instance, if we are trying to build a spam classifier for email, then x(i) may be some features of a piece of email, and y may be 1 if it is a piece of spam mail, and 0 otherwise. 0 is also called the negative class, and 1 the positive class, and they are sometimes also denoted by the symbols  and . Given x(i), the corresponding y(i) is also called the label for the training example. 2.1 Logistic regression We could approach the classification problem ignoring the fact that y is discretevalued, and use our old linear regression algorithm to try to predict y given x. However, it is easy to construct examples where this method performs very poorly. Intuitively, it also doesnt make sense for h (x) to take  values larger than 1 or smaller than 0 when we know that y  0,1. To fix this, lets change the form for our hypotheses h (x). We will choose  1 h (x)  g(Tx)  ,  1eTx where 1 g(z)  1ez is called the logistic function or the sigmoid function. Here is a plot showing g(z): 1 0.9 0.8 0.7 0.6 0.5 0.4 0.3 0.2 0.1 0 5 4 3 2 1 0 1 2 3 4 5 z )z(g Notice that g(z) tends towards 1 as z  , and g(z) tends towards 0 as z  . Moreover, g(z), and hence also h(x), is always bounded between 0 and 1. As before, we are keeping the convention of letting x  1, so that 0 Tx    (cid:)d  x . 0 j1 j j Fornow, letstakethechoiceofg asgiven. Otherfunctionsthatsmoothly increasefrom0to1canalsobeused, butforacoupleofreasonsthatwellsee later(whenwetalkaboutGLMs, andwhenwetalkaboutgenerativelearning algorithms), the choice of the logistic function is a fairly natural one. Before moving on, heres a useful property of the derivative of the sigmoid function, which we write as g(cid:): d 1 g(cid:)(z)  dz 1ez 1 (cid:0) (cid:1)  ez (1ez)2 (cid:) (cid:) 1 1   1 (1ez) (1ez)  g(z)(1g(z)). So, given the logistic regression model, how do we fit  for it? Following how we saw least squares regression could be derived as the maximum like lihood estimator under a set of assumptions, lets endow our classification model with a set of probabilistic assumptions, and then fit the parameters via maximum likelihood. Let us assume that P(y  1  x;)  h (x)  P(y  0  x;)  1h (x)  Note that this can be written more compactly as p(y  x;)  (h (x))y(1h (x))1y   Assuming that the n training examples were generated independently, we can then write down the likelihood of the parameters as L()  p((cid:)y  X;) n (cid:)  p(y(i)  x(i);) i1 n  (cid:)(cid:0) h (x(i)) (cid:1)y(i)(cid:0) 1h (x(i)) (cid:1)1y(i)   i1 As before, it will be easier to maximize the log likelihood: n (cid:) (cid:)()  logL()  y(i)logh(x(i))(1y(i))log(1h(x(i))) (2.1) i1 How do we maximize the likelihood? Similar to our derivation in the case oflinearregression, wecanusegradientascent. Writteninvectorialnotation, our updates will therefore be given by  :   (cid:)(). (Note the positive  rather than negative sign in the update formula, since were maximizing, rather than minimizing, a function now.) Lets start by working with just one training example (x,y), and take derivatives to derive the stochastic gradient ascent rule: (cid:) (cid:)  1 1  (cid:)()  y (1y) g(Tx)  g(Tx) 1g(Tx)  j j (cid:) (cid:) 1 1   y (1y) g(Tx)(1g(Tx)) Tx g(Tx) 1g(Tx)  j (cid:0) (cid:1)  y(1g(Tx))(1y)g(Tx) x j (y h (x))x (2.2)  j Above, we used the fact that g(cid:)(z)  g(z)(1g(z)). This therefore gives us the stochastic gradient ascent rule  :   (cid:0) y(i) h (x(i)) (cid:1) x(i) j j  j If we compare this to the LMS update rule, we see that it looks identical; but this is not the same algorithm, because h (x(i)) is now defined as a nonlinear  function of Tx(i). Nonetheless, its a little surprising that we end up with the same update rule for a rather different algorithm and learning problem. Is this coincidence, or is there a deeper reason behind this? Well answer this when we get to GLM models. Remark 2.1.1: An alternative notational viewpoint of the same loss func tionisalsouseful, especiallyforSection7.1wherewestudynonlinearmodels. Let (cid:) : R0,1  R be the logistic loss defined as logistic 0 (cid:) (t,y) (cid:) ylog(1exp(t))(1y)log(1exp(t)). (2.3) logistic One can verify by plugging in h (x)  1(1e(cid:)x) that the negative log  likelihood (the negation of (cid:)() in equation (2.1)) can be rewritten as (cid:)()  (cid:) ((cid:)x,y). (2.4) logistic Oftentimes (cid:)x or t is called the logit. Basic calculus gives us that (cid:) (t,y) exp(t) 1 logistic  y (1y) (2.5) t 1exp(t) 1exp(t)  1(1exp(t))y. (2.6) Then, using the chain rule, we have that  (cid:) (t,y) t logistic (cid:)()    (2.7)  t  j j  (y 1(1exp(t)))x  (y h (x))x , (2.8) j  j which is consistent with the derivation in equation (2.2). We will see this viewpoint can be extended nonlinear models in Section 7.1. 2.2 Digression: the perceptron learning algo rithm We now digress to talk briefly about an algorithm thats of some historical interest, and that we will also return to later when we talk about learning theory. Consider modifying the logistic regression method to force it to output values that are either 0 or 1 or exactly. To do so, it seems natural to change the definition of g to be the threshold function: (cid:) 1 if z  0 g(z)  0 if z  0 If we then let h (x)  g(Tx) as before but using this modified definition of  g, and if we use the update rule  :   (cid:0) y(i) h (x(i)) (cid:1) x(i). j j  j then we have the perceptron learning algorithn. In the 1960s, this perceptron was argued to be a rough model for how individual neurons in the brain work. Given how simple the algorithm is, it will also provide a starting point for our analysis when we talk about learning theory later in this class. Note however that even though the perceptron may be cosmetically similar to the other algorithms we talked about, it is actually a very different type of algorithm than logistic regression and least squares linearregression; inparticular, itisdifficulttoendowtheperceptronspredic tions with meaningful probabilistic interpretations, or derive the perceptron as a maximum likelihood estimation algorithm. 2.3 Multiclass classification Consideraclassificationprobleminwhichtheresponsevariabley cantakeon any one of k values, so y  1,2,...,k. For example, rather than classifying emails into the two classes spam or notspamwhich would have been a binary classification problemwe might want to classify them into three classes, such as spam, personal mails, and workrelated mails. The label  response variable is still discrete, but can now take on more than two values. We will thus model it as distributed according to a multinomial distribution. In this case, p(y  x;) is a distribution over k possible discrete outcomes and is thus a multinomial distribution. Recall that a multinomial distribu tion involves k numbers  ,..., specifying the probability of each of the 1 k outcomes. Note that these numbers must satisfy (cid:)k   1. We will de i1 i sign a parameterized model that outputs  ,..., satisfying this constraint 1 k given the input x. We introduce k groups of parameters  ,..., , each of them being a 1 k vector in Rd. Intuitively, we would like to use (cid:)x,...,(cid:)x to represent 1 k  ,..., , the probabilities P(y  1  x;),...,P(y  k  x;). However, 1 k there are two issues with such a direct approach. First, (cid:)x is not neces j sarily within [0,1]. Second, the summation of (cid:)xs is not necessarily 1. j Thus, instead, we will use the softmax function to turn ((cid:)x, ,(cid:)x) into 1 k a probability vector with nonnegative entries that sum up to 1. Define the softmax function softmax : Rk  Rk as  exp(t1)  (cid:)k j1 exp(tj)  .  softmax(t 1 ,...,t k )   . . . (2.9)   exp(t ) k (cid:)k j1 exp(tj) The inputs to the softmax function, the vector t here, are often called log its. Note that by definition, the output of the softmax function is always a probability vector whose entries are nonnegative and sum up to 1. Let (t ,...,t )  ((cid:)x, ,(cid:)x). We apply the softmax function to 1 k 1 k (t ,...,t ), andusetheoutputastheprobabilitiesP(y  1  x;),...,P(y  1 k k  x;). We obtain the following probabilistic model:     exp( 1 (cid:)x) P(y  1  x;) (cid:)k exp((cid:)x)  j1 j  . .   . .    softmax(t 1 , ,t k )    . .   . (2.) P(y  k  x;)  exp((cid:)x)  k (cid:)k exp((cid:)x) j1 j For notational convenience, we will let   exp(ti) . More succinctly, the i (cid:)k j1 exp(tj) equation above can be written as: exp(t ) exp((cid:)x) P(y  i  x;)    i  i . (2.) i (cid:)k exp(t ) (cid:)k exp((cid:)x) j1 j j1 j Next, we compute the negative loglikelihood of a single example (x,y). (cid:) (cid:) (cid:) (cid:) exp(t ) exp((cid:)x) y y logp(y  x,)  log  log (cid:)k exp(t ) (cid:)k exp((cid:)x) j1 j j1 j (2.) Thus, the loss function, the negative loglikelihood of the training data, is given as (cid:) (cid:) n exp((cid:) x(i)) (cid:) y(i) (cid:)()  log . (2.) (cid:)k exp((cid:)x(i)) i1 j1 j Its convenient to define the crossentropy loss (cid:) : Rk 1,...,k  R , ce 0 which modularizes in the complex equation above:1 (cid:) (cid:) exp(t ) y (cid:) ((t ,...,t ),y)  log . (2.) ce 1 k (cid:)k exp(t ) j1 j With this notation, we can simply rewrite equation (2.) as n (cid:) (cid:)()  (cid:) (((cid:)x(i),...,(cid:)x(i)),y(i)). (2.) ce 1 k i1 Moreover, conveniently, the crossentropy loss also has a simple gradient. Let t  (t ,...,t ), and recall   exp(ti) . By basic calculus, we can derive 1 k i (cid:)k j1 exp(tj) (cid:) (t,y) ce   1y  i, (2.) i t i where 1 is the indicator function, that is, 1y  i  1 if y  i, and 1y  i  0 if y (cid:) i. Alternatively, in vectorized notations, we have the following form which will be useful for Chapter 7: (cid:) (t,y) ce  e , (2.) y t where e  Rk is the sth natural basis vector (where the sth entry is 1 and s all other entries are zeros.) Using Chain rule, we have that (cid:) (((cid:)x,...,(cid:)x),y) (cid:)(t,y) t ce 1 k   i  ( 1y  i)x. (2.) i  t  i i i Therefore, the gradient of the loss with respect to the part of parameter  is i n (cid:)() (cid:)  ((j) 1y(j)  i)x(j), (2.)  i i j1 where (j)  exp( i (cid:)x(j)) is the probability that the model predicts item i i (cid:)k exp((cid:)x(j)) s1 s for example x(j). With the gradients above, one can implement (stochastic) gradient descent to minimize the loss function (cid:)(). 1Therearesomeambiguityinthenaminghere. Somepeoplecallthecrossentropyloss the function that maps the probability vector (the  in our language) and label y to the final real number, and call our version of crossentropy loss softmaxcrossentropy loss. Wechooseourcurrentnamingconventionbecauseitsconsistentwiththenamingofmost modern deep learning library such as PyTorch and Jax. 0  1.5 2 2.5 3x 3.5 4 4.5 5 )x(f 0  1.5 2 2.5 3x 3.5 4 4.5 5 )x(f 0  1.5 2 2.5 3x 3.5 4 4.5 5 )x(f 2.4 Another algorithm for maximizing (cid:)() Returning to logistic regression with g(z) being the sigmoid function, lets now talk about a different algorithm for maximizing (cid:)(). To get us started, lets consider Newtons method for finding a zero of a function. Specifically, suppose we have some function f : R (cid:) R, and we wish to find a value of  so that f()  0. Here,   R is a real number. Newtons method performs the following update: f()  :  . f(cid:)() This method has a natural interpretation in which we can think of it as approximating the function f via a linear function that is tangent to f at the current guess , solving for where that linear function equals to zero, and letting the next guess for  be where that linear function is zero. Heres a picture of the Newtons method in action: In the leftmost figure, we see the function f plotted along with the line y  0. Weretryingtofind sothatf()  0; thevalueof thatachievesthis is about 1.3. Suppose we initialized the algorithm with   4.5. Newtons method then fits a straight line tangent to f at   4.5, and solves for the where that line evaluates to 0. (Middle figure.) This give us the next guess for , which is about 2.8. The rightmost figure shows the result of running one more iteration, which the updates  to about 1.8. After a few more iterations, we rapidly approach   1.3. Newtons method gives a way of getting to f()  0. What if we want to use it to maximize some function (cid:)? The maxima of (cid:) correspond to points where its first derivative (cid:)(cid:)() is zero. So, by letting f()  (cid:)(cid:)(), we can use the same algorithm to maximize (cid:), and we obtain update rule: (cid:)(cid:)()  :  . (cid:)(cid:)(cid:)() (Something to think about: How would this change if we wanted to use Newtons method to minimize rather than maximize a function?) Lastly, in our logistic regression setting,  is vectorvalued, so we need to generalize Newtons method to this setting. The generalization of Newtons method to this multidimensional setting (also called the NewtonRaphson method) is given by  : H1 (cid:)().  Here,  (cid:)() is, as usual, the vector of partial derivatives of (cid:)() with respect  tothe s; andH isandbydmatrix(actually, d1byd1, assumingthat i we include the intercept term) called the Hessian, whose entries are given by 2(cid:)() H  . ij   i j Newtons method typically enjoys faster convergence than (batch) gra dient descent, and requires many fewer iterations to get very close to the minimum. One iteration of Newtons can, however, be more expensive than one iteration of gradient descent, since it requires finding and inverting an dbyd Hessian; but so long as d is not too large, it is usually much faster overall. When Newtons method is applied to maximize the logistic regres sion log likelihood function (cid:)(), the resulting method is also called Fisher scoring. Chapter 3 Generalized linear models So far, weve seen a regression example, and a classification example. In the regression example, we had yx;  N(,2), and in the classification one, yx;  Bernoulli(), forsomeappropriatedefinitionsofandasfunctions of x and . In this section, we will show that both of these methods are special cases of a broader family of models, called Generalized Linear Models (GLMs).1 We will also show how other models in the GLM family can be derived and applied to other classification and regression problems. 3.1 The exponential family To work our way up to GLMs, we will begin by defining exponential family distributions. We say that a class of distributions is in the exponential family if it can be written in the form p(y;)  b(y)exp(TT(y)a()) (3.1) Here,  iscalledthenatural parameter(alsocalledthecanonical param eter) of the distribution; T(y) is the sufficient statistic (for the distribu tions we consider, it will often be the case that T(y)  y); and a() is the log partition function. The quantity ea() essentially plays the role of a nor malization constant, that makes sure the distribution p(y;) sumsintegrates over y to 1. A fixed choice of T, a and b defines a family (or set) of distributions that is parameterized by ; as we vary , we then get different distributions within this family. 1The presentation of the material in this section takes inspiration from Michael I. Jordan, Learning in graphical models (unpublished book draft), and also McCullagh and Nelder, Generalized Linear Models (2nd ed.). We now show that the Bernoulli and the Gaussian distributions are ex amples of exponential family distributions. The Bernoulli distribution with mean , written Bernoulli(), specifies a distribution over y  0,1, so that p(y  1;)  ; p(y  0;)  1  . As we vary , we obtain Bernoulli distributions with different means. We now show that this class of Bernoulli distributions, ones obtained by varying , is in the exponential family; i.e., that there is a choice of T, a and b so that Equation (3.1) becomes exactly the class of Bernoulli distributions. We write the Bernoulli distribution as: p(y;)  y(1)1y  exp(ylog(1y)log(1)) (cid:)(cid:) (cid:) (cid:)(cid:) (cid:)   exp log y log(1) . 1 Thus, the natural parameter is given by   log((1)). Interestingly, if we invert this definition for  by solving for  in terms of , we obtain   1(1e). This is the familiar sigmoid function! This will come up again when we derive logistic regression as a GLM. To complete the formulation of the Bernoulli distribution as an exponential family distribution, we also have T(y)  y a()  log(1)  log(1e) b(y)  1 This shows that the Bernoulli distribution can be written in the form of Equation (3.1), using an appropriate choice of T, a and b. Lets now move on to consider the Gaussian distribution. Recall that, when deriving linear regression, the value of 2 had no effect on our final choice of  and h (x). Thus, we can choose an arbitrary value for 2 without  changing anything. To simplify the derivation below, lets set 2  1.2 We 2If we leave 2 as a variable, the Gaussian distribution can also be shown to be in the exponentialfamily,where R2 isnowa2dimensionvectorthatdependsonbothand . ForthepurposesofGLMs,however,the2parametercanalsobetreatedbyconsidering a more general definition of the exponential family: p(y;,)  b(a,)exp((TT(y)  a())c()). Here, iscalledthedispersionparameter,andfortheGaussian,c()2; but given our simplification above, we wont need the more general definition for the examples we will consider here. then have: (cid:) (cid:) 1 1 p(y;)   exp  (y )2 2 2 (cid:) (cid:) (cid:) (cid:) 1 1 1   exp  y2 exp y  2 2 2 2 Thus, we see that the Gaussian is in the exponential family, with    T(y)  y a()  22  22  b(y)  (1 2)exp(y22). Therere many other distributions that are members of the exponen tial family: The multinomial (which well see later), the Poisson (for mod elling countdata; also see the problem set); the gamma and the exponen tial (for modelling continuous, nonnegative random variables, such as time intervals); the beta and the Dirichlet (for distributions over probabilities); and many more. In the next section, we will describe a general recipe for constructing models in which y (given x and ) comes from any of these distributions. 3.2 Constructing GLMs Suppose you would like to build a model to estimate the number y of cus tomers arriving in your store (or number of pageviews on your website) in any given hour, based on certain features x such as store promotions, recent advertising, weather, dayofweek, etc. We know that the Poisson distribu tion usually gives a good model for numbers of visitors. Knowing this, how can we come up with a model for our problem? Fortunately, the Poisson is an exponential family distribution, so we can apply a Generalized Linear Model (GLM). In this section, we will we will describe a method for constructing GLM models for problems such as these. More generally, consider a classification or regression problem where we would like to predict the value of some random variable y as a function of x. To derive a GLM for this problem, we will make the following three assumptions about the conditional distribution of y given x and about our model: 1. y  x;  ExponentialFamily(). I.e., given x and , the distribution of y follows some exponential family distribution, with parameter . 2. Given x, our goal is to predict the expected value of T(y) given x. In most of our examples, we will have T(y)  y, so this means we would like the prediction h(x) output by our learned hypothesis h to satisfy h(x)  E[yx]. (Note that this assumption is satisfied in the choices for h (x) for both logistic regression and linear regression. For  instance, in logistic regression, we had h (x)  p(y  1x;)  0p(y   0x;)1p(y  1x;)  E[yx;].) 3. The natural parameter  and the inputs x are related linearly:   Tx. (Or, if  is vectorvalued, then   Tx.) i i The third of these assumptions might seem the least well justified of the above, and it might be better thought of as a design choice in our recipe for designing GLMs, rather than as an assumption per se. These three assumptionsdesign choices will allow us to derive a very elegant class of learning algorithms, namely GLMs, that have many desirable properties such as ease of learning. Furthermore, the resulting models are often very effective for modelling different types of distributions over y; for example, we will shortly show that both logistic regression and ordinary least squares can both be derived as GLMs. 3.2.1 Ordinary least squares To show that ordinary least squares is a special case of the GLM family of models, consider the setting where the target variable y (also called the response variable in GLM terminology) is continuous, and we model the conditional distribution of y given x as a Gaussian N(,2). (Here,  may depend x.) So, we let the ExponentialFamily() distribution above be the Gaussian distribution. As we saw previously, in the formulation of the Gaussian as an exponential family distribution, we had   . So, we have h (x)  E[yx;]       Tx. The first equality follows from Assumption 2, above; the second equality followsfromthefactthatyx;  N(,2), andsoitsexpectedvalueisgiven by; thethirdequalityfollowsfromAssumption1(andourearlierderivation showing that    in the formulation of the Gaussian as an exponential family distribution); and the last equality follows from Assumption 3. 3.2.2 Logistic regression We now consider logistic regression. Here we are interested in binary classifi cation,soy  0,1. Giventhaty isbinaryvalued,itthereforeseemsnatural to choose the Bernoulli family of distributions to model the conditional dis tribution of y given x. In our formulation of the Bernoulli distribution as an exponential family distribution, we had   1(1  e). Furthermore, note that if yx;  Bernoulli(), then E[yx;]  . So, following a similar derivation as the one for ordinary least squares, we get: h (x)  E[yx;]     1(1e)  1(1eTx) So, this gives us hypothesis functions of the form h (x)  1(1eTx). If  you are previously wondering how we came up with the form of the logistic function 1(1  ez), this gives one answer: Once we assume that y condi tioned on x is Bernoulli, it arises as a consequence of the definition of GLMs and exponential family distributions. To introduce a little more terminology, the function g giving the distri butions mean as a function of the natural parameter (g()  E[T(y);]) is called the canonical response function. Its inverse, g1, is called the canonical link function. Thus, the canonical response function for the Gaussian family is just the identify function; and the canonical response function for the Bernoulli is the logistic function.3 3Manytextsuseg todenotethelinkfunction,andg1 todenotetheresponsefunction; but the notation were using here, inherited from the early machine learning literature, will be more consistent with the notation used in the rest of the class. Chapter 4 Generative learning algorithms So far, weve mainly been talking about learning algorithms that model p(yx;), the conditional distribution of y given x. For instance, logistic regression modeled p(yx;) as h (x)  g(Tx) where g is the sigmoid func  tion. In these notes, well talk about a different type of learning algorithm. Consider a classification problem in which we want to learn to distinguish between elephants (y  1) and dogs (y  0), based on some features of an animal. Given a training set, an algorithm like logistic regression or the perceptron algorithm (basically) tries to find a straight linethat is, a decision boundarythat separates the elephants and dogs. Then, to classify a new animal as either an elephant or a dog, it checks on which side of the decision boundary it falls, and makes its prediction accordingly. Heres a different approach. First, looking at elephants, we can build a model of what elephants look like. Then, looking at dogs, we can build a separate model of what dogs look like. Finally, to classify a new animal, we can match the new animal against the elephant model, and match it against the dog model, to see whether the new animal looks more like the elephants or more like the dogs we had seen in the training set. Algorithms that try to learn p(yx) directly (such as logistic regression), or algorithms that try to learn mappings directly from the space of inputs X to the labels 0,1, (such as the perceptron algorithm) are called discrim inative learning algorithms. Here, well talk about algorithms that instead try to model p(xy) (and p(y)). These algorithms are called generative learning algorithms. For instance, if y indicates whether an example is a dog (0) or an elephant (1), then p(xy  0) models the distribution of dogs features, and p(xy  1) models the distribution of elephants features. After modeling p(y) (called the class priors) and p(xy), our algorithm can then use Bayes rule to derive the posterior distribution on y given x: p(xy)p(y) p(yx)  . p(x) Here, the denominator is given by p(x)  p(xy  1)p(y  1)  p(xy  0)p(y  0) (you should be able to verify that this is true from the standard properties of probabilities), and thus can also be expressed in terms of the quantities p(xy) and p(y) that weve learned. Actually, if were calculating p(yx) in order to make a prediction, then we dont actually need to calculate the denominator, since p(xy)p(y) argmaxp(yx)  argmax y y p(x)  argmaxp(xy)p(y). y 4.1 Gaussian discriminant analysis The first generative learning algorithm that well look at is Gaussian discrim inant analysis (GDA). In this model, well assume that p(xy) is distributed according to a multivariate normal distribution. Lets talk briefly about the properties of multivariate normal distributions before moving on to the GDA model itself. 4.1.1 The multivariate normal distribution The multivariate normal distribution in ddimensions, also called the multi variate Gaussian distribution, is parameterized by a mean vector   Rd and a covariance matrix   Rdd, where   0 is symmetric and positive semidefinite. Also written N(,), its density is given by: (cid:) (cid:) 1 1 p(x;,)  exp  (x)T1(x) . (2)d212 2 In the equation above,  denotes the determinant of the matrix . For a random variable X distributed N(,), the mean is (unsurpris ingly) given by : (cid:) E[X]  xp(x;,)dx   x ThecovarianceofavectorvaluedrandomvariableZ isdefinedasCov(Z)  E[(Z E[Z])(Z E[Z])T]. This generalizes the notion of the variance of a realvaluedrandomvariable. ThecovariancecanalsobedefinedasCov(Z)  E[ZZT](E[Z])(E[Z])T. (You should be able to prove to yourself that these two definitions are equivalent.) If X  N(,), then Cov(X)  . Here are some examples of what the density of a Gaussian distribution looks like: 0. 0. 0. 0.2 0.2 0.2 0. 0. 0. 0.1 0.1 0.1 0. 0. 0. 3 3 3 2 1 0 1 2 3 3 2 1 0 1 2 3 2 1 0 1 2 3 3 2 1 0 1 2 3 2 1 0 1 2 3 3 2 1 0 1 2 3 The leftmost figure shows a Gaussian with mean zero (that is, the 2x1 zerovector) and covariance matrix   I (the 2x2 identity matrix). A Gaus sian with zero mean and identity covariance is also called the standard nor mal distribution. The middle figure shows the density of a Gaussian with zeromeanand  0.6I; andintherightmostfigureshowsonewith,   2I. We see that as  becomes larger, the Gaussian becomes more spreadout, and as it becomes smaller, the distribution becomes more compressed. Lets look at some more examples. 0. 0. 0. 0.2 0.2 0.2 0. 0. 0. 0.1 0.1 0.1 0. 0. 0. 3 3 3 2 2 2 1 1 1 0 0 0 1 2 3 3 2 1 0 1 2 3 1 2 3 3 2 1 0 1 2 3 1 2 3 3 2 1 0 1 2 3 The figures above show Gaussians with mean 0, and with covariance matrices respectively (cid:) (cid:) (cid:) (cid:) (cid:) (cid:) 1 0 1 0.5 1 0.8   ;   ;   . 0 1 0.5 1 0.8 1 The leftmost figure shows the familiar standard normal distribution, and we see that as we increase the offdiagonal entry in , the density becomes more compressed towards the  line (given by x  x ). We can see this more 1 2 clearly when we look at the contours of the same three densities: 3 3 3 2 2 2 1 1 1 0 0 0 1 1 1 2 2 2 3 3 3 3 2 1 0 1 2 3 3 2 1 0 1 2 3 3 2 1 0 1 2 3 Heres one last set of examples generated by varying : 3 3 3 2 2 2 1 1 1 0 0 0 1 1 1 2 2 2 3 3 3 3 2 1 0 1 2 3 3 2 1 0 1 2 3 3 2 1 0 1 2 3 The plots above used, respectively, (cid:) (cid:) (cid:) (cid:) (cid:) (cid:) 1 0.5 1 0.8 3 0.8   ;   ;   . 0.5 1 0.8 1 0.8 1 From the leftmost and middle figures, we see that by decreasing the off diagonal elements of the covariance matrix, the density now becomes com pressed again, but in the opposite direction. Lastly, as we vary the pa rameters, more generally the contours will form ellipses (the rightmost figure showing an example). As our last set of examples, fixing   I, by varying , we can also move the mean of the density around. 0. 0. 0. 0.2 0.2 0.2 0. 0. 0. 0.1 0.1 0.1 0. 0. 0. 3 3 3 2 1 0 1 2 3 3 2 1 0 1 2 3 2 1 0 1 2 3 3 2 1 0 1 2 3 2 1 0 1 2 3 3 2 1 0 1 2 3 The figures above were generated using   I, and respectively (cid:) (cid:) (cid:) (cid:) (cid:) (cid:) 1 0.5 1   ;   ;   . 0 0 1.5 4.1.2 The Gaussian discriminant analysis model When we have a classification problem in which the input features x are continuousvalued random variables, we can then use the Gaussian Discrim inant Analysis (GDA) model, which models p(xy) using a multivariate nor mal distribution. The model is: y  Bernoulli() xy  0  N( ,) 0 xy  1  N( ,) 1 Writing out the distributions, this is: p(y)  y(1)1y (cid:) (cid:) 1 1 p(xy  0)  exp  (x )T1(x ) (2)d212 2 0 0 (cid:) (cid:) 1 1 p(xy  1)  exp  (x )T1(x ) (2)d212 2 1 1 Here, the parameters of our model are , ,  and  . (Note that while 0 1 therere two different mean vectors  and  , this model is usually applied 0 1 using only one covariance matrix .) The loglikelihood of the data is given by n (cid:) (cid:)(, , ,)  log p(x(i),y(i);, , ,) 0 1 0 1 i1 n (cid:)  log p(x(i)y(i); , ,)p(y(i);). 0 1 i1 By maximizing (cid:) with respect to the parameters, we find the maximum like lihood estimate of the parameters (see problem set 1) to be: n 1 (cid:)   1y(i)  1 n i1 (cid:)n 1y(i)  0x(i)   i1 0 (cid:)n 1y(i)  0 i1 (cid:)n 1y(i)  1x(i)   i1 1 (cid:)n 1y(i)  1 i1 n 1 (cid:)   (x(i)  )(x(i)  )T. n y(i) y(i) i1 Pictorially, what the algorithm is doing can be seen in as follows: 1 0 1 2 3 4 5 6 7 2 1 0 1 2 3 4 5 6 7 Shown in the figure are the training set, as well as the contours of the two Gaussian distributions that have been fit to the data in each of the two classes. Note that the two Gaussians have contours that are the same shape and orientation, since they share a covariance matrix , but they have different means  and  . Also shown in the figure is the straight line 0 1 giving the decision boundary at which p(y  1x)  0.5. On one side of the boundary, well predict y  1 to be the most likely outcome, and on the other side, well predict y  0. 4.1.3 Discussion: GDA and logistic regression The GDA model has an interesting relationship to logistic regression. If we view the quantity p(y  1x;, , ,) as a function of x, well find that it 0 1 can be expressed in the form 1 p(y  1x;,, , )  , 0 1 1exp(Tx) where  is some appropriate function of ,, , .1 This is exactly the form 0 1 that logistic regressiona discriminative algorithmused to model p(y  1x). When would we prefer one model over another? GDA and logistic regres sion will, in general, give different decision boundaries when trained on the same dataset. Which is better? We just argued that if p(xy) is multivariate gaussian (with shared ), then p(yx) necessarily follows a logistic function. The converse, however, is not true; i.e., p(yx) being a logistic function does not imply p(xy) is multivariate gaussian. This shows that GDA makes stronger modeling as sumptions about the data than does logistic regression. It turns out that when these modeling assumptions are correct, then GDA will find better fits to the data, and is a better model. Specifically, when p(xy) is indeed gaus sian (with shared ), then GDA is asymptotically efficient. Informally, this means that in the limit of very large training sets (large n), there is no algorithm that is strictly better than GDA (in terms of, say, how accurately they estimate p(yx)). In particular, it can be shown that in this setting, GDA will be a better algorithm than logistic regression; and more generally, even for small training set sizes, we would generally expect GDA to better. In contrast, by making significantly weaker assumptions, logistic regres sion is also more robust and less sensitive to incorrect modeling assumptions. Therearemanydifferentsetsofassumptionsthatwouldleadtop(yx)taking the form of a logistic function. For example, if xy  0  Poisson( ), and 0 xy  1  Poisson( ), then p(yx) will be logistic. Logistic regression will 1 also work well on Poisson data like this. But if we were to use GDA on such dataand fit Gaussian distributions to such nonGaussian datathen the results will be less predictable, and GDA may (or may not) do well. To summarize: GDA makes stronger modeling assumptions, and is more data efficient (i.e., requires less training data to learn well) when the mod eling assumptions are correct or at least approximately correct. Logistic 1This uses the convention of redefining the x(i)s on the righthandside to be (d1) dimensional vectors by adding the extra coordinate x(i) 1; see problem set 1. 0 regression makes weaker assumptions, and is significantly more robust to deviations from modeling assumptions. Specifically, when the data is in deed nonGaussian, then in the limit of large datasets, logistic regression will almost always do better than GDA. For this reason, in practice logistic re gression is used more often than GDA. (Some related considerations about discriminative vs. generative models also apply for the Naive Bayes algo rithm that we discuss next, but the Naive Bayes algorithm is still considered a very good, and is certainly also a very popular, classification algorithm.) 4.2 Naive bayes (Option Reading) In GDA, the feature vectors x were continuous, realvalued vectors. Lets now talk about a different learning algorithm in which the x s are discrete j valued. For our motivating example, consider building an email spam filter using machine learning. Here, we wish to classify messages according to whether they are unsolicited commercial (spam) email, or nonspam email. After learning to do this, we can then have our mail reader automatically filter out the spam messages and perhaps place them in a separate mail folder. Classifying emails is one example of a broader set of problems called text classification. Lets say we have a training set (a set of emails labeled as spam or non spam). Well begin our construction of our spam filter by specifying the features x used to represent an email. j We will represent an email via a feature vector whose length is equal to the number of words in the dictionary. Specifically, if an email contains the jth word of the dictionary, then we will set x  1; otherwise, we let x  0. j j For instance, the vector   1 a 0 aardvark     0 aardwolf    .  . x   . .  . .    1  buy    . .  . .  .  . 0 zygmurgy is used to represent an email that contains the words a and buy, but not aardvark, aardwolf or zygmurgy.2 The set of words encoded into the feature vector is called the vocabulary, so the dimension of x is equal to the size of the vocabulary. Having chosen our feature vector, we now want to build a generative model. So, we have to model p(xy). But if we have, say, a vocabulary of words, then x  0,1 (x is a dimensional vector of 0s and 1s), andifweweretomodelxexplicitlywithamultinomialdistributionover the possible outcomes, then wed end up with a (1)dimensional parameter vector. This is clearly too many parameters. Tomodelp(xy),wewillthereforemakeaverystrongassumption. Wewill assume that the x s are conditionally independent given y. This assumption i iscalledtheNaive Bayes (NB) assumption,andtheresultingalgorithmis called the Naive Bayes classifier. For instance, if y  1 means spam email; buy is word and price is word ; then we are assuming that if I tell you y  1 (that a particular piece of email is spam), then knowledge of x (knowledge of whether buy appears in the message) will have no effect on your beliefs about the value of x (whether price appears). More formally, this can be written p(x y)  p(x y,x ). (Note that this is not the same as saying that x and x are independent, which would have been written p(x )  p(x x ); rather, we are only assuming that x and x are conditionally independent given y.) We now have: p(x ,...,x y) 1  p(x y)p(x y,x )p(x y,x ,x )p(x y,x ,...,x ) 1 2 1 3 1 2 1  p(x y)p(x y)p(x y)p(x y) 1 2 3 d (cid:)  p(x y) j j1 The first equality simply follows from the usual properties of probabilities, and the second equality used the NB assumption. We note that even though 2Actually, rather than looking through an English dictionary for the list of all English words, in practice it is more common to look through our training set and encode in our feature vector only the words that occur at least once there. Apart from reducing the number of words modeled and hence reducing our computational and space requirements, this also has the advantage of allowing us to modelinclude as a feature many words that may appear in your email (such as cs229) but that you wont find in a dictionary. Sometimes (as in the homework), we also exclude the very high frequency words (which willbewordslikethe,of,and; thesehighfrequency,contentfreewordsarecalled stop words) since they occur in so many documents and do little to indicate whether an email is spam or nonspam. theNaiveBayesassumptionisanextremelystrongassumptions,theresulting algorithm works well on many problems. Our model is parameterized by   p(x  1y  1),   p(x  jy1 j jy0 j 1y  0), and   p(y  1). As usual, given a training set (x(i),y(i));i  y 1,...,n, we can write down the joint likelihood of the data: n (cid:) L( , , )  p(x(i),y(i)). y jy0 jy1 i1 Maximizing this with respect to  , and  gives the maximum y jy0 jy1 likelihood estimates: (cid:)n 1x(i)  1y(i)  1   i1 j jy1 (cid:)n 1y(i)  1 i1 (cid:)n 1x(i)  1y(i)  0   i1 j jy0 (cid:)n 1y(i)  0 i1 (cid:)n 1y(i)  1   i1 y n In the equations above, the  symbol means and. The parameters have a very natural interpretation. For instance,  is just the fraction of the jy1 spam (y  1) emails in which word j does appear. Having fit all these parameters, to make a prediction on a new example with features x, we then simply calculate p(xy  1)p(y  1) p(y  1x)  p(x) (cid:) (cid:) (cid:)d p(x y  1) p(y  1) j1 j  , (cid:) (cid:) (cid:) (cid:) (cid:)d p(x y  1) p(y  1) (cid:)d p(x y  0) p(y  0) j1 j j1 j and pick whichever class has the higher posterior probability. Lastly, we note that while we have developed the Naive Bayes algorithm mainly for the case of problems where the features x are binaryvalued, the j generalization to where x can take values in 1,2,...,k  is straightforward. j j Here, wewouldsimplymodelp(x y)asmultinomialratherthanasBernoulli. j Indeed, even if some original input attribute (say, the living area of a house, as in our earlier example) were continuous valued, it is quite common to discretize itthat is, turn it into a small set of discrete valuesand apply Naive Bayes. For instance, if we use some feature x to represent living area, j we might discretize the continuous values as follows: Living area (sq. feet)      x 1 2 3 4 5 i Thus, for a house with living area square feet, we would set the value of the corresponding feature x to 3. We can then apply the Naive Bayes j algorithm, and model p(x y) with a multinomial distribution, as described j previously. When the original, continuousvalued attributes are not well modeled by a multivariate normal distribution, discretizing the features and using Naive Bayes (instead of GDA) will often result in a better classifier. 4.2.1 Laplace smoothing The Naive Bayes algorithm as we have described it will work fairly well for many problems, but there is a simple change that makes it work much better, especially for text classification. Lets briefly discuss a problem with the algorithm in its current form, and then talk about how we can fix it. Consider spamemail classification, and lets suppose that, we are in the year of 20xx, after completing CS229 and having done excellent work on the project, you decide around May 20xx to submit work you did to the NeurIPS conference for publication.3 Because you end up discussing the conference in your emails, you also start getting messages with the word neurips in it. But this is your first NeurIPS paper, and until this time, you had not previously seen any emails containing the word neurips; in particular neurips did not ever appear in your training set of spamnonspam emails. Assuming that neurips was the 35000th word in the dictionary, your Naive Bayes spam filter therefore had picked its maximum likelihood estimates of the parameters  to be y (cid:)n 1x(i)  1y(i)  1   i1  0 y1 (cid:)n 1y(i)  1 i1 (cid:)n 1x(i)  1y(i)  0   i1  0 y0 (cid:)n 1y(i)  0 i1 I.e., because it has never seen neurips before in either spam or nonspam training examples, it thinks the probability of seeing it in either type of email is zero. Hence, when trying to decide if one of these messages containing 3NeurIPS is one of the top machine learning conferences. The deadline for submitting a paper is typically in MayJune. neurips is spam, it calculates the class posterior probabilities, and obtains (cid:)d p(x y  1)p(y  1) j1 j p(y  1x)  (cid:)d p(x y  1)p(y  1) (cid:)d p(x y  0)p(y  0) j1 j j1 j 0  . 0 Thisisbecauseeachoftheterms (cid:)d p(x y)includesatermp(x y)  j1 j 0 that is multiplied into it. Hence, our algorithm obtains 00, and doesnt know how to make a prediction. Stating the problem more broadly, it is statistically a bad idea to esti mate the probability of some event to be zero just because you havent seen it before in your finite training set. Take the problem of estimating the mean of a multinomial random variable z taking values in 1,...,k. We can pa rameterize our multinomial with   p(z  j). Given a set of n independent j observations z(1),...,z(n), the maximum likelihood estimates are given by (cid:)n 1z(i)  j   i1 . j n As we saw previously, if we were to use these maximum likelihood estimates, then some of the  s might end up as zero, which was a problem. To avoid j this, we can use Laplace smoothing, which replaces the above estimate with 1 (cid:)n 1z(i)  j   i1 . j k n Here, weve added 1 to the numerator, and k to the denominator. Note that (cid:)k   1 still holds (check this yourself!), which is a desirable property j1 j since the  s are estimates for probabilities that we know must sum to 1. j Also,  (cid:) 0 for all values of j, solving our problem of probabilities being j estimated as zero. Under certain (arguably quite strong) conditions, it can be shown that the Laplace smoothing actually gives the optimal estimator of the  s. j Returning to our Naive Bayes classifier, with Laplace smoothing, we therefore obtain the following estimates of the parameters: 1 (cid:)n 1x(i)  1y(i)  1   i1 j jy1 2 (cid:)n 1y(i)  1 i1 1 (cid:)n 1x(i)  1y(i)  0   i1 j jy0 2 (cid:)n 1y(i)  0 i1 (Inpractice,itusuallydoesntmattermuchwhetherweapplyLaplacesmooth ing to  or not, since we will typically have a fair fraction each of spam and y nonspam messages, so  will be a reasonable estimate of p(y  1) and will y be quite far from 0 anyway.) 4.2.2 Event models for text classification To close off our discussion of generative learning algorithms, lets talk about one more model that is specifically for text classification. While Naive Bayes as weve presented it will work well for many classification problems, for text classification, there is a related model that does even better. In the specific context of text classification, Naive Bayes as presented uses the whats called the Bernoulli event model (or sometimes multivariate Bernoulli event model). In this model, we assumed that the way an email is generated is that first it is randomly determined (according to the class priors p(y)) whether a spammer or nonspammer will send you your next message. Then, the person sending the email runs through the dictionary, deciding whether to include each word j in that email independently and according to the probabilities p(x  1y)   . Thus, the probability of a j jy message was given by p(y) (cid:)d p(x y). j1 j Heres a different model, called the Multinomial event model. To describe this model, we will use a different notation and set of features for representing emails. We let x denote the identity of the jth word in the j email. Thus, x is now an integer taking values in 1,...,V, where V j is the size of our vocabulary (dictionary). An email of d words is now rep resented by a vector (x ,x ,...,x ) of length d; note that d can vary for 1 2 d different documents. For instance, if an email starts with A NeurIPS ..., then x  1 (a is the first word in the dictionary), and x  (if 1 2 neurips is the 35000th word in the dictionary). In the multinomial event model, we assume that the way an email is generated is via a random process in which spamnonspam is first deter mined (according to p(y)) as before. Then, the sender of the email writes the email by first generating x from some multinomial distribution over words 1 (p(x y)). Next, the second word x is chosen independently of x but from 1 2 1 the same multinomial distribution, and similarly for x , x , and so on, until 3 4 all d words of the email have been generated. Thus, the overall probability of a message is given by p(y) (cid:)d p(x y). Note that this formula looks like the j1 j one we had earlier for the probability of a message under the Bernoulli event model, but that the terms in the formula now mean very different things. In particular x y is now a multinomial, rather than a Bernoulli distribution. j The parameters for our new model are   p(y) as before,   y ky1 p(x  ky  1) (for any j) and   p(x  ky  0). Note that we have j ky0 j assumed that p(x y) is the same for all values of j (i.e., that the distribution j according to which a word is generated does not depend on its position j within the email). If we are given a training set (x(i),y(i));i  1,...,n where x(i)  (x(i),x(i),...,x(i)) (here, d is the number of words in the itraining example), 1 2 di i the likelihood of the data is given by n (cid:) L( , , )  p(x(i),y(i)) y ky0 ky1 i1 (cid:) (cid:) (cid:) n (cid:) di  p(x(i)y; , ) p(y(i); ). j ky0 ky1 y i1 j1 Maximizing this yields the maximum likelihood estimates of the parameters: (cid:)n (cid:)di 1x(i)  k y(i)  1 i1 j1 j   ky1 (cid:)n 1y(i)  1d i1 i (cid:)n (cid:)di 1x(i)  k y(i)  0 i1 j1 j   ky0 (cid:)n 1y(i)  0d i1 i (cid:)n 1y(i)  1   i1 . y n If we were to apply Laplace smoothing (which is needed in practice for good performance) when estimating  and  , we add 1 to the numerators ky0 ky1 and V to the denominators, and obtain: 1 (cid:)n (cid:)di 1x(i)  k y(i)  1 i1 j1 j   ky1 V (cid:)n 1y(i)  1d i1 i 1 (cid:)n (cid:)di 1x(i)  k y(i)  0 i1 j1 j   . ky0 V (cid:)n 1y(i)  0d i1 i While not necessarily the very best classification algorithm, the Naive Bayes classifieroftenworkssurprisinglywell. Itisoftenalsoaverygoodfirstthing to try, given its simplicity and ease of implementation. Chapter 5 Kernel methods 5.1 Feature maps Recall that in our discussion about linear regression, we considered the prob lem of predicting the price of a house (denoted by y) from the living area of the house (denoted by x), and we fit a linear function of x to the training data. What if the price y can be more accurately represented as a nonlinear function of x? In this case, we need a more expressive family of models than linear models. We start by considering fitting cubic functions y   x3 x2 x . 3 2 1 0 It turns out that we can view the cubic function as a linear function over the a different set of feature variables (defined below). Concretely, let the function  : R  R4 be defined as   1 (x)    x    R4. (5.1)  x2  x3 Let   R4 be the vector containing  , , , as entries. Then we can 0 1 2 3 rewrite the cubic function in x as:  x3  x2  x  T(x) 3 2 1 0 Thus, a cubic function of the variable x can be viewed as a linear function over the variables (x). To distinguish between these two sets of variables, in the context of kernel methods, we will call the original input value the input attributes of a problem (in this case, x, the living area). When the original input is mapped to some new set of quantities (x), we will call those new quantities the features variables. (Unfortunately, different authors use different terms to describe these two things in different contexts.) We will call  a feature map, which maps the attributes to the features. 5.2 LMS (least mean squares) with features We will derive the gradient descent algorithm for fitting the model T(x). First recall that for ordinary least square problem where we were to fit Tx, the batch gradient descent update is (see the first lecture note for its deriva tion): n (cid:)(cid:0) (cid:1)  :  y(i) h (x(i)) x(i)  i1 n (cid:)(cid:0) (cid:1) :  y(i) Tx(i) x(i). (5.2) i1 Let  : Rd  Rp be a feature map that maps attribute x (in Rd) to the features (x) in Rp. (In the motivating example in the previous subsection, we have d  1 and p  4.) Now our goal is to fit the function T(x), with  being a vector in Rp instead of Rd. We can replace all the occurrences of x(i) in the algorithm above by (x(i)) to obtain the new update: n (cid:)(cid:0) (cid:1)  :  y(i) T(x(i)) (x(i)) (5.3) i1 Similarly, the corresponding stochastic gradient descent update rule is (cid:0) (cid:1)  :  y(i) T(x(i)) (x(i)) (5.4) 5.3 LMS with the kernel trick The gradient descent update, or stochastic gradient update above becomes computationally expensive when the features (x) is highdimensional. For example, consider the direct extension of the feature map in equation (5.1) to highdimensional input x: suppose x  Rd, and let (x) be the vector that contains all the monomials of x with degree  3   1  x  1    x  2  .   .  .    x2   1    x x  1 2    x x (x)   1 3 . (5.5)  .   . .     x x   2 1   . .   .     x3   1   x2x   1 2  . . . The dimension of the features (x) is on the order of d3.1 This is a pro hibitively long vector for computational purpose  when d  , each update requires at least computing and storing a  dimensional vector, which is times slower than the update rule for for ordinary least squares updates (5.2). It may appear at first that such d3 runtime per update and memory usage are inevitable, because the vector  itself is of dimension p  d3, and we may need to update every entry of  and store it. However, we will introduce the kernel trick with which we will not need to store  explicitly, and the runtime can be significantly improved. For simplicity, we assume the initialize the value   0, and we focus on the iterative update (5.3). The main observation is that at any time,  can be represented as a linear combination of the vectors (x(1)),...,(x(n)). Indeed, we can show this inductively as follows. At initialization,   0  (cid:)n 0(x(i)). Assume at some point,  can be represented as i1 n (cid:)    (x(i)) (5.6) i i1 1Here,forsimplicity,weincludeallthemonomialswithrepetitions(sothat,e.g.,x x x 1 2 3 and x x x both appear in (x)). Therefore, there are totally 1dd2d3 entries in 2 3 1 (x). for some  ,...,  R. Then we claim that in the next round,  is still a 1 n linear combination of (x(1)),...,(x(n)) because n (cid:)(cid:0) (cid:1)  :  y(i) T(x(i)) (x(i)) i1 n n (cid:) (cid:)(cid:0) (cid:1)   (x(i)) y(i) T(x(i)) (x(i)) i i1 i1 n (cid:) (cid:0) (cid:1)  (  y(i) T(x(i)) )(x(i)) (5.7) i i1 (cid:) (cid:)(cid:) (cid:) newi You may realize that our general strategy is to implicitly represent the p dimensional vector  by a set of coefficients  ,..., . Towards doing this, 1 n we derive the update rule of the coefficients  ,..., . Using the equation 1 n above, we see that the new  depends on the old one via i (cid:0) (cid:1)  :   y(i) T(x(i)) (5.8) i i Here we still have the old  on the RHS of the equation. Replacing  by   (cid:)n  (x(j)) gives j1 j (cid:) (cid:) n i  1,...,n, :   y(i)  (cid:)  (x(j)) T (x(i)) i i j j1 We often rewrite (x(j)) T (x(i)) as (cid:)(x(j)),(x(i))(cid:) to emphasize that its the inner product of the two feature vectors. Viewing  s as the new representa i tionof,wehavesuccessfullytranslatedthebatchgradientdescentalgorithm into an algorithm that updates the value of  iteratively. It may appear that at every iteration, we still need to compute the values of (cid:)(x(j)),(x(i))(cid:) for all pairs of i,j, each of which may take roughly O(p) operation. However, two important properties come to rescue: 1. We can precompute the pairwise inner products (cid:)(x(j)),(x(i))(cid:) for all pairs of i,j before the loop starts. 2. For the feature map  defined in (5.5) (or many other interesting fea ture maps), computing (cid:)(x(j)),(x(i))(cid:) can be efficient and does not necessarily require computing (x(i)) explicitly. This is because: d (cid:) (cid:) (cid:) (cid:)(x),(z)(cid:)  1 x z  x x z z  x x x z z z i i i j i j i j k i j k i1 i,j1,...,d i,j,k1,...,d (cid:) (cid:)2 (cid:) (cid:)3 d d d (cid:) (cid:) (cid:)  1 x z  x z  x z i i i i i i i1 i1 i1  1(cid:)x,z(cid:)(cid:)x,z(cid:)2 (cid:)x,z(cid:)3 (5.9) Therefore, to compute (cid:)(x),(z)(cid:), we can first compute (cid:)x,z(cid:) with O(d) time and then take another constant number of operations to com pute 1(cid:)x,z(cid:)(cid:)x,z(cid:)2 (cid:)x,z(cid:)3. As you will see, the inner products between the features (cid:)(x),(z)(cid:) are essential here. We define the Kernel corresponding to the feature map  as a function that maps X X  R satisfying: 2 K(x,z) (cid:) (cid:)(x),(z)(cid:) (5.) To wrap up the discussion, we write the down the final algorithm as follows: 1. Compute all the values K(x(i),x(j)) (cid:) (cid:)(x(i)),(x(j))(cid:) using equa tion (5.9) for all i,j  1,...,n. Set  : 0. 2. Loop: (cid:) (cid:) n (cid:) i  1,...,n, :   y(i)   K(x(i),x(j)) (5.) i i j j1 Or in vector notation, letting K be the n  n matrix with K  ij K(x(i),x(j)), we have  :  ((cid:)y K) With the algorithm above, we can update the representation  of the vector  efficiently with O(n) time per update. Finally, we need to show that 2Recall that X is the space of the input x. In our running example, X Rd the knowledge of the representation  suffices to compute the prediction T(x). Indeed, we have n n T(x)  (cid:)  (x(i)) T (x)  (cid:)  K(x(i),x) (5.) i i i1 i1 You may realize that fundamentally all we need to know about the feature map () is encapsulated in the corresponding kernel function K(,). We will expand on this in the next section. 5.4 Properties of kernels In the last subsection, we started with an explicitly defined feature map , which induces the kernel function K(x,z) (cid:) (cid:)(x),(z)(cid:). Then we saw that the kernel function is so intrinsic so that as long as the kernel function is defined, the whole training algorithm can be written entirely in the language of the kernel without referring to the feature map , so can the prediction of a test example x (equation (5.).) Therefore, it would be tempted to define other kernel function K(,) and run the algorithm (5.). Note that the algorithm (5.) does not need to explicitly access the feature map , and therefore we only need to ensure the existence of the feature map , but do not necessarily need to be able to explicitly write  down. WhatkindsoffunctionsK(,)cancorrespondtosomefeaturemap? In other words, can we tell if there is some feature mapping  so that K(x,z)  (x)T(z) for all x, z? If we can answer this question by giving a precise characterization of valid kernel functions, then we can completely change the interface of selecting feature maps  to the interface of selecting kernel function K. Concretely, we can pick a function K, verify that it satisfies the characterization (so that there exists a feature map  that K corresponds to), and then we can run update rule (5.). The benefit here is that we dont have to be able to compute  or write it down analytically, and we only need to know its existence. We will answer this question at the end of this subsection after we go through several concrete examples of kernels. Suppose x,z  Rd, and lets first consider the function K(,) defined as: K(x,z)  (xTz)2. We can also write this as (cid:) (cid:)(cid:) (cid:) d d (cid:) (cid:) K(x,z)  x z x z i i j j i1 j1 d d (cid:)(cid:)  x x z z i j i j i1 j1 d (cid:)  (x x )(z z ) i j i j i,j1 Thus, we see that K(x,z)  (cid:)(x),(z)(cid:) is the kernel function that corre sponds to the the feature mapping  given (shown here for the case of d  3) by   x x 1 1  x 1 x 2     x 1 x 3     x 2 x 1    (x)   x x . 2 2    x x  2 3    x x  3 1    x 3 x 2  x x 3 3 Revisitingthecomputationalefficiencyperspectiveofkernel,notethatwhereas calculating the highdimensional (x) requires O(d2) time, finding K(x,z) takes only O(d) timelinear in the dimension of the input attributes. For another related example, also consider K(,) defined by K(x,z)  (xTz c)2 d d   (cid:) (cid:)  (x x )(z z ) ( 2cx )( 2cz )c2. i j i j i i i,j1 i1 (Check this yourself.) This function K is a kernel function that corresponds to the feature mapping (again shown for d  3)   x x 1 1 x x  1 2    x x  1 3    x x  2 1    x x  2 2    x x  2 3    (x)   x 3 x 1 ,    x 3 x 2      x 3 x 3      2cx 1     2cx   2    2cx  3 c and the parameter c controls the relative weighting between the x (first i order) and the x x (second order) terms. i j More broadly, the kernel K(x,z)  (xTz  c)k corresponds to a feature mapping to an (cid:0)dk(cid:1) feature space, corresponding of all monomials of the k form x x ...x that are up to order k. However, despite working in this i1 i2 i k O(dk)dimensional space, computing K(x,z) still takes only O(d) time, and hence we never need to explicitly represent feature vectors in this very high dimensional feature space. Kernels as similarity metrics. Now, lets talk about a slightly different view of kernels. Intuitively, (and there are things wrong with this intuition, but nevermind), if (x) and (z) are close together, then we might expect K(x,z)  (x)T(z) to be large. Conversely, if (x) and (z) are far apart say nearly orthogonal to each otherthen K(x,z)  (x)T(z) will be small. So, we can think of K(x,z) as some measurement of how similar are (x) and (z), or of how similar are x and z. Given this intuition, suppose that for some learning problem that youre working on, youve come up with some function K(x,z) that you think might be a reasonable measure of how similar x and z are. For instance, perhaps you chose (cid:) xz2(cid:) K(x,z)  exp  . 22 This is a reasonable measure of x and zs similarity, and is close to 1 when x and z are close, and near 0 when x and z are far apart. Does there exist a feature map  such that the kernel K defined above satisfies K(x,z)  (x)T(z)? Inthisparticularexample, theanswerisyes. Thiskerneliscalled the Gaussian kernel, and corresponds to an infinite dimensional feature mapping . We will give a precise characterization about what properties a function K needs to satisfy so that it can be a valid kernel function that corresponds to some feature map . Necessary conditions for valid kernels. Suppose for now that K is indeed a valid kernel corresponding to some feature mapping , and we will first see what properties it satisfies. Now, consider some finite set of n points (not necessarily the training set) x(1),...,x(n), and let a square, nbyn matrix K be defined so that its (i,j)entry is given by K  K(x(i),x(j)). ij This matrix is called the kernel matrix. Note that weve overloaded the notation and used K to denote both the kernel function K(x,z) and the kernel matrix K, due to their obvious close relationship. Now, if K is a valid kernel, then K  K(x(i),x(j))  (x(i))T(x(j))  ij (x(j))T(x(i))  K(x(j),x(i))  K , andhenceK mustbesymmetric. More ji over, letting  (x) denote the kth coordinate of the vector (x), we find that k for any vector z, we have (cid:)(cid:) zTKz  z K z i ij j i j (cid:)(cid:)  z (x(i))T(x(j))z i j i j (cid:)(cid:) (cid:)  z  (x(i)) (x(j))z i k k j i j k (cid:)(cid:)(cid:)  z  (x(i)) (x(j))z i k k j k i j (cid:) (cid:)2 (cid:) (cid:)  z  (x(i)) i k k i  0. The secondtolast step uses the fact that (cid:) a a  ( (cid:) a )2 for a  i,j i j i i i z  (x(i)). Since z was arbitrary, this shows that K is positive semidefinite i k (K  0). Hence, weve shown that if K is a valid kernel (i.e., if it corresponds to some feature mapping ), then the corresponding kernel matrix K  Rnn is symmetric positive semidefinite. Sufficient conditions for valid kernels. More generally, the condition above turns out to be not only a necessary, but also a sufficient, condition for K to be a valid kernel (also called a Mercer kernel). The following result is due to Mercer.3 Theorem (Mercer). Let K : Rd  Rd (cid:) R be given. Then for K to be a valid (Mercer) kernel, it is necessary and sufficient that for any x(1),...,x(n), (n  ), the corresponding kernel matrix is symmetric pos itive semidefinite. Given a function K, apart from trying to find a feature mapping  that corresponds to it, this theorem therefore gives another way of testing if it is a valid kernel. Youll also have a chance to play with these ideas more in problem set 2. In class, we also briefly talked about a couple of other examples of ker nels. For instance, consider the digit recognition problem, in which given an image (16x16 pixels) of a handwritten digit (09), we have to figure out which digit it was. Using either a simple polynomial kernel K(x,z)  (xTz)k or the Gaussian kernel, SVMs were able to obtain extremely good perfor mance on this problem. This was particularly surprising since the input attributes x were just dimensional vectors of the image pixel intensity values, and the system had no prior knowledge about vision, or even about which pixels are adjacent to which other ones. Another example that we briefly talked about in lecture was that if the objects x that we are trying to classify are strings (say, x is a list of amino acids, which strung together form a protein), then it seems hard to construct a reasonable, small set of features for most learning algorithms, especially if different strings have dif ferent lengths. However, consider letting (x) be a feature vector that counts the number of occurrences of each lengthk substring in x. If were consid ering strings of English letters, then there are 26k such strings. Hence, (x) is a 26k dimensional vector; even for moderate values of k, this is probably too big for us to efficiently work with. (e.g.,  .) However, using (dynamic programmingish) string matching algorithms, it is possible to ef ficiently compute K(x,z)  (x)T(z), so that we can now implicitly work in this 26kdimensional feature space, but without ever explicitly computing feature vectors in this space. 3Many texts present Mercers theorem in a slightly more complicated form involving L2 functions, but when the input attributes take values in Rd, the version given here is equivalent. Application of kernel methods: Weve seen the application of kernels to linear regression. In the next part, we will introduce the support vector machines to which kernels can be directly applied. dwell too much longer on ithere. Infact, theideaofkernelshassignificantlybroaderapplicabilitythan linear regression and SVMs. Specifically, if you have any learning algorithm that you can write in terms of only inner products (cid:)x,z(cid:) between input attribute vectors, then by replacing this with K(x,z) where K is a kernel, you can magically allow your algorithm to work efficiently in the high dimensional feature space corresponding to K. For instance, this kernel trick can be applied with the perceptron to derive a kernel perceptron algorithm. Many of the algorithms that well see later in this class will also be amenable to this method, which has come to be known as the kernel trick. Chapter 6 Support vector machines This set of notes presents the Support Vector Machine (SVM) learning al gorithm. SVMs are among the best (and many believe are indeed the best) offtheshelf supervised learning algorithms. To tell the SVM story, well need to first talk about margins and the idea of separating data with a large gap. Next, well talk about the optimal margin classifier, which will lead us into a digression on Lagrange duality. Well also see kernels, which give a way to apply SVMs efficiently in very high dimensional (such as infinite dimensional) feature spaces, and finally, well close off the story with the SMO algorithm, which gives an efficient implementation of SVMs. 6.1 Margins: intuition Well start our story on SVMs by talking about margins. This section will give the intuitions about margins and about the confidence of our predic tions; these ideas will be made formal in Section 6.3. Consider logistic regression, where the probability p(y  1x;) is mod eled by h (x)  g(Tx). We then predict 1 on an input x if and only if  h (x)  0.5, or equivalently, if and only if Tx  0. Consider a positive  training example (y  1). The larger Tx is, the larger also is h (x)  p(y   1x;), and thus also the higher our degree of confidence that the label is 1. Thus, informally we can think of our prediction as being very confident that y  1 if Tx (cid:) 0. Similarly, we think of logistic regression as confidently predicting y  0, if Tx (cid:) 0. Given a training set, again informally it seems that wed have found a good fit to the training data if we can find  so that Tx(i) (cid:) 0 whenever y(i)  1, and Tx(i) (cid:) 0 whenever y(i)  0, since this would reflect a very confident (and correct) set of classifications for all the training examples. This seems to be a nice goal to aim for, and well soon formalize this idea using the notion of functional margins. For a different type of intuition, consider the following figure, in which xs represent positive training examples, os denote negative training examples, a decision boundary (this is the line given by the equation Tx  0, and is also called the separating hyperplane) is also shown, and three points have also been labeled A, B and C. A (cid:0)(cid:1) B C (cid:0)(cid:1) (cid:0)(cid:1) Notice that the point A is very far from the decision boundary. If we are asked to make a prediction for the value of y at A, it seems we should be quite confident that y  1 there. Conversely, the point C is very close to the decision boundary, and while its on the side of the decision boundary on which we would predict y  1, it seems likely that just a small change to the decision boundary could easily have caused out prediction to be y  0. Hence, were much more confident about our prediction at A than at C. The point B lies inbetween these two cases, and more broadly, we see that if a point is far from the separating hyperplane, then we may be significantly more confident in our predictions. Again, informally we think it would be nice if, given a training set, we manage to find a decision boundary that allows us to make all correct and confident (meaning far from the decision boundary) predictions on the training examples. Well formalize this later using the notion of geometric margins. 6.2 Notation (option reading) To make our discussion of SVMs easier, well first need to introduce a new notation for talking about classification. We will be considering a linear classifier for a binary classification problem with labels y and features x. From now, well use y  1,1 (instead of 0,1) to denote the class labels. Also, rather than parameterizing our linear classifier with the vector , we will use parameters w,b, and write our classifier as h (x)  g(wTxb). w,b Here, g(z)  1 if z  0, and g(z)  1 otherwise. This w,b notation allows us to explicitly treat the intercept term b separately from the other parameters. (Wealsodroptheconventionwehadpreviouslyoflettingx  1 0 be an extra coordinate in the input feature vector.) Thus, b takes the role of what was previously  , and w takes the role of [ ... ]T. 0 1 d Note also that, from our definition of g above, our classifier will directly predict either 1 or 1 (cf. the perceptron algorithm), without first going through the intermediate step of estimating p(y  1) (which is what logistic regression does). 6.3 Functional and geometric margins (op tion reading) Lets formalize the notions of the functional and geometric margins. Given a training example (x(i),y(i)), we define the functional margin of (w,b) with respect to the training example as (i)  y(i)(wTx(i) b). Note that if y(i)  1, then for the functional margin to be large (i.e., for our prediction to be confident and correct), we need wTx(i)b to be a large positive number. Conversely, if y(i)  1, then for the functional margin to be large, we need wTx(i) b to be a large negative number. Moreover, if y(i)(wTx(i) b)  0, then our prediction on this example is correct. (Check this yourself.) Hence, a large functional margin represents a confident and a correct prediction. For a linear classifier with the choice of g given above (taking values in 1,1), theres one property of the functional margin that makes it not a verygoodmeasureofconfidence,however. Givenourchoiceofg,wenotethat if we replace w with 2w and b with 2b, then since g(wTxb)  g(2wTx2b), this would not change h (x) at all. I.e., g, and hence also h (x), depends w,b w,b only on the sign, but not on the magnitude, of wTxb. However, replacing (w,b) with (2w,2b) also results in multiplying our functional margin by a factor of 2. Thus, it seems that by exploiting our freedom to scale w and b, we can make the functional margin arbitrarily large without really changing anything meaningful. Intuitively, it might therefore make sense to impose some sort of normalization condition such as that w  1; i.e., we might 2 replace (w,b) with (ww ,bw ), and instead consider the functional 2 2 margin of (ww ,bw ). Well come back to this later. 2 2 Given a training set S  (x(i),y(i));i  1,...,n, we also define the function margin of (w,b) with respect to S as the smallest of the functional marginsoftheindividualtrainingexamples. Denotedby, thiscantherefore be written:   min (i). i1,...,n Next, lets talk about geometric margins. Consider the picture below: A w (i) B The decision boundary corresponding to (w,b) is shown, along with the vector w. Note that w is orthogonal (at ) to the separating hyperplane. (You should convince yourself that this must be the case.) Consider the point at A, which represents the input x(i) of some training example with label y(i)  1. Its distance to the decision boundary, (i), is given by the line segment AB. How can we find the value of (i)? Well, ww is a unitlength vector pointing in the same direction as w. Since A represents x(i), we therefore find that the point B is given by x(i) (i) ww. But this point lies on the decision boundary, and all points x on the decision boundary satisfy the equation wTxb  0. Hence, (cid:) (cid:) w wT x(i) (i) b  0. w Solving for (i) yields wTx(i) b (cid:) w (cid:)T b (i)   x(i)  . w w w This was worked out for the case of a positive training example at A in the figure, where being on the positive side of the decision boundary is good. More generally, we define the geometric margin of (w,b) with respect to a training example (x(i),y(i)) to be (cid:) (cid:) (cid:) w (cid:)T b (i)  y(i) x(i)  . w w Note that if w  1, then the functional margin equals the geometric marginthis thus gives us a way of relating these two different notions of margin. Also, the geometric margin is invariant to rescaling of the parame ters; i.e., if we replace w with 2w and b with 2b, then the geometric margin does not change. This will in fact come in handy later. Specifically, because of this invariance to the scaling of the parameters, when trying to fit w and b to training data, we can impose an arbitrary scaling constraint on w without changing anything important; for instance, we can demand that w  1, or w   5, or w bw   2, and any of these can be satisfied simply by 1 1 2 rescaling w and b. Finally, given a training set S  (x(i),y(i));i  1,...,n, we also define the geometric margin of (w,b) with respect to S to be the smallest of the geometric margins on the individual training examples:   min (i). i1,...,n 6.4 The optimal margin classifier (option read ing) Given a training set, it seems from our previous discussion that a natural desideratum is to try to find a decision boundary that maximizes the (ge ometric) margin, since this would reflect a very confident set of predictions on the training set and a good fit to the training data. Specifically, this will result in a classifier that separates the positive and the negative training examples with a gap (geometric margin). For now, we will assume that we are given a training set that is linearly separable; i.e., that it is possible to separate the positive and negative ex amples using some separating hyperplane. How will we find the one that achieves the maximum geometric margin? We can pose the following opti mization problem: max  ,w,b s.t. y(i)(wTx(i) b)  , i  1,...,n w  1. I.e., we want to maximize , subject to each training example having func tional margin at least . The w  1 constraint moreover ensures that the functional margin equals to the geometric margin, so we are also guaranteed that all the geometric margins are at least . Thus, solving this problem will result in (w,b) with the largest possible geometric margin with respect to the training set. If we could solve the optimization problem above, wed be done. But the w  1constraintisanasty(nonconvex)one, andthisproblemcertainly isnt in any format that we can plug into standard optimization software to solve. So, lets try transforming the problem into a nicer one. Consider:  max ,w,b w s.t. y(i)(wTx(i) b)  , i  1,...,n Here, were going to maximize w, subject to the functional margins all being at least . Since the geometric and functional margins are related by   w, this will give us the answer we want. Moreover, weve gotten rid of the constraint w  1 that we didnt like. The downside is that we now have a nasty (again, nonconvex) objective  function; and, we still dont w have any offtheshelf software that can solve this form of an optimization problem. Lets keep going. Recall our earlier discussion that we can add an arbi trary scaling constraint on w and b without changing anything. This is the key idea well use now. We will introduce the scaling constraint that the functional margin of w,b with respect to the training set must be 1:   1. Since multiplying w and b by some constant results in the functional margin being multiplied by that same constant, this is indeed a scaling constraint, and can be satisfied by rescaling w,b. Plugging this into our problem above, and noting that maximizing w  1w is the same thing as minimizing w2, we now have the following optimization problem: 1 min w2 w,b 2 s.t. y(i)(wTx(i) b)  1, i  1,...,n Weve now transformed the problem into a form that can be efficiently solved. The above is an optimization problem with a convex quadratic ob jective and only linear constraints. Its solution gives us the optimal mar gin classifier. This optimization problem can be solved using commercial quadratic programming (QP) code.1 While we could call the problem solved here, what we will instead do is make a digression to talk about Lagrange duality. This will lead us to our optimization problems dual form, which will play a key role in allowing us to use kernels to get optimal margin classifiers to work efficiently in very high dimensional spaces. The dual form will also allow us to derive an efficient algorithm for solving the above optimization problem that will typically do much better than generic QP software. 6.5 Lagrange duality (optional reading) Lets temporarily put aside SVMs and maximum margin classifiers, and talk about solving constrained optimization problems. Consider a problem of the following form: min f(w) w s.t. h (w)  0, i  1,...,l. i Some of you may recall how the method of Lagrange multipliers can be used to solve it. (Dont worry if you havent seen it before.) In this method, we define the Lagrangian to be l (cid:) L(w,)  f(w)  h (w) i i i1 1You may be familiar with linear programming, which solves optimization problems that have linear objectives and linear constraints. QP software is also widely available, which allows convex quadratic objectives and linear constraints. Here, the  s are called the Lagrange multipliers. We would then find i and set Ls partial derivatives to zero: L L  0;  0, w  i i and solve for w and . In this section, we will generalize this to constrained optimization prob lems in which we may have inequality as well as equality constraints. Due to time constraints, we wont really be able to do the theory of Lagrange duality justice in this class,2 but we will give the main ideas and results, which we will then apply to our optimal margin classifiers optimization problem. Considerthefollowing, whichwellcalltheprimaloptimizationproblem: min f(w) w s.t. g (w)  0, i  1,...,k i h (w)  0, i  1,...,l. i To solve it, we start by defining the generalized Lagrangian k l (cid:) (cid:) L(w,,)  f(w)  g (w)  h (w). i i i i i1 i1 Here, the  s and  s are the Lagrange multipliers. Consider the quantity i i  (w)  max L(w,,). P ,:i0 Here, the P subscript stands for primal. Let some w be given. If w violates any of the primal constraints (i.e., if either g (w)  0 or h (w) (cid:) 0 i i for some i), then you should be able to verify that k l (cid:) (cid:)  (w)  max f(w)  g (w)  h (w) (6.1) P i i i i ,:i0 i1 i1  . (6.2) Conversely, if the constraints are indeed satisfied for a particular value of w, then  (w)  f(w). Hence, P (cid:) f(w) if w satisfies primal constraints  (w)  P  otherwise. 2Readers interested in learning more about this topic are encouraged to read, e.g., R. T. Rockarfeller (), Convex Analysis, Princeton University Press. Thus,  takes the same value as the objective in our problem for all val P ues of w that satisfies the primal constraints, and is positive infinity if the constraints are violated. Hence, if we consider the minimization problem min (w)  min max L(w,,), P w w ,:i0 we see that it is the same problem (i.e., and has the same solutions as) our original, primal problem. For later use, we also define the optimal value of the objective to be p  min  (w); we call this the value of the primal w P problem. Now, lets look at a slightly different problem. We define  (,)  minL(w,,). D w Here, the D subscript stands for dual. Note also that whereas in the definition of  we were optimizing (maximizing) with respect to ,, here P we are minimizing with respect to w. We can now pose the dual optimization problem: max  (,)  max minL(w,,). D ,:i0 ,:i0 w This is exactly the same as our primal problem shown above, except that the order of the max and the min are now exchanged. We also define the optimal value of the dual problems objective to be d  max  (w). ,:i0 D Howaretheprimalandthedualproblemsrelated? Itcaneasilybeshown that d  max minL(w,,)  min max L(w,,)  p. ,:i0 w w ,:i0 (You should convince yourself of this; this follows from the maxmin of a function always being less than or equal to the minmax.) However, under certain conditions, we will have d  p, so that we can solve the dual problem in lieu of the primal problem. Lets see what these conditions are. Suppose f and the g s are convex,3 and the h s are affine.4 Suppose i i further that the constraints g are (strictly) feasible; this means that there i exists some w so that g (w)  0 for all i. i 3When f has a Hessian, then it is convex if and only if the Hessian is positive semi definite. For instance, f(w)  wTw is convex; similarly, all linear (and affine) functions are also convex. (A function f can also be convex without being differentiable, but we wont need those more general definitions of convexity here.) 4I.e., there exists a , b , so that h (w)  aTwb . Affine means the same thing as i i i i i linear, except that we also allow the extra intercept term b . i Underouraboveassumptions, theremustexistw,, sothatw isthe solution to the primal problem, , are the solution to the dual problem, and moreover p  d  L(w,,). Moreover, w, and  satisfy the KarushKuhnTucker (KKT) conditions, which are as follows:  L(w,,)  0, i  1,...,d (6.3) w i  L(w,,)  0, i  1,...,l (6.4)  i g (w)  0, i  1,...,k (6.5) i i g (w)  0, i  1,...,k (6.6) i   0, i  1,...,k (6.7) he primal and dual Moreover, if somew,, satisfy the KKT conditions, then it is also a solution to t problems. We draw attention to Equation (6.5), which is called the KKT dual complementarity condition. Specifically, it implies that if   0, then i g (w)  0. (I.e., the g (w)  0 constraint is active, meaning it holds with i i equality rather than with inequality.) Later on, this will be key for showing that the SVM has only a small number of support vectors; the KKT dual complementarity condition will also give us our convergence test when we talk about the SMO algorithm. 6.6 Optimal margin classifiers: the dual form (option reading) Note: The equivalence of optimization problem (6.8) and the optimization problem (6.), and the relationship between the primary and dual variables in equation (6.) are the most important take home messages of this section. Previously, weposedthefollowing(primal)optimizationproblemforfind ing the optimal margin classifier: 1 min w2 (6.8) w,b 2 s.t. y(i)(wTx(i) b)  1, i  1,...,n We can write the constraints as g (w)  y(i)(wTx(i) b)1  0. i We have one such constraint for each training example. Note that from the KKT dual complementarity condition, we will have   0 only for the train i ing examples that have functional margin exactly equal to one (i.e., the ones corresponding to constraints that hold with equality, g (w)  0). Consider i thefigurebelow, inwhichamaximummarginseparatinghyperplaneisshown by the solid line. The points with the smallest margins are exactly the ones closest to the decisionboundary; here,thesearethethreepoints(onenegativeandtwopos itive examples) that lie on the dashed lines parallel to the decision boundary. Thus, only three of the  snamely, the ones corresponding to these three i training exampleswill be nonzero at the optimal solution to our optimiza tion problem. These three points are called the support vectors in this problem. The fact that the number of support vectors can be much smaller than the size the training set will be useful later. Lets move on. Looking ahead, as we develop the dual form of the prob lem, one key idea to watch out for is that well try to write our algorithm in terms of only the inner product (cid:)x(i),x(j)(cid:) (think of this as (x(i))Tx(j)) between points in the input feature space. The fact that we can express our algorithm in terms of these inner products will be key when we apply the kernel trick. WhenweconstructtheLagrangianforouroptimizationproblemwehave: n 1 (cid:) (cid:2) (cid:3) L(w,b,)  w2   y(i)(wTx(i) b)1 . (6.9) i 2 i1 Note that therere only   but no   Lagrange multipliers, since the i i problem has only inequality constraints. Lets find the dual form of the problem. To do so, we need to first minimize L(w,b,) with respect to w and b (for fixed ), to get  , which D well do by setting the derivatives of L with respect to w and b to zero. We have: n (cid:)  L(w,b,)  w  y(i)x(i)  0 w i i1 This implies that n (cid:) w   y(i)x(i). (6.) i i1 As for the derivative with respect to b, we obtain n  (cid:) L(w,b,)   y(i)  0. (6.) i b i1 If we take the definition of w in Equation (6.) and plug that back into the Lagrangian (Equation 6.9), and simplify, we get n n n (cid:) 1 (cid:) (cid:) L(w,b,)    y(i)y(j)  (x(i))Tx(j) b  y(i). i i j i 2 i1 i,j1 i1 But from Equation (6.), the last term must be zero, so we obtain n n (cid:) 1 (cid:) L(w,b,)    y(i)y(j)  (x(i))Tx(j). i i j 2 i1 i,j1 Recall that we got to the equation above by minimizing L with respect to w and b. Putting this together with the constraints   0 (that we always i had) and the constraint (6.), we obtain the following dual optimization problem: n n (cid:) 1 (cid:) max W()    y(i)y(j)  (cid:)x(i),x(j)(cid:). (6.)  i i j 2 i1 i,j1 s.t.   0, i  1,...,n i n (cid:)  y(i)  0, i i1 You should also be able to verify that the conditions required for p  d and the KKT conditions (Equations 6.36.7) to hold are indeed satisfied in our optimization problem. Hence, we can solve the dual in lieu of solving the primal problem. Specifically, in the dual problem above, we have a maximization problem in which the parameters are the  s. Well talk later i aboutthespecificalgorithmthatweregoingtousetosolvethedualproblem, but if we are indeed able to solve it (i.e., find the s that maximize W() subject to the constraints), then we can use Equation (6.) to go back and findtheoptimalwsasafunctionofthes. Havingfoundw, byconsidering the primal problem, it is also straightforward to find the optimal value for the intercept term b as max wTx(i) min wTx(i) b   i:y(i)1 i:y(i)1 . (6.) 2 (Check for yourself that this is correct.) Before moving on, lets also take a more careful look at Equation (6.), which gives the optimal value of w in terms of (the optimal value of) . Suppose weve fit our models parameters to a training set, and now wish to make a prediction at a new point input x. We would then calculate wTxb, and predict y  1 if and only if this quantity is bigger than zero. But using (6.), this quantity can also be written: (cid:) n (cid:)T (cid:) wTxb   y(i)x(i) xb (6.) i i1 n (cid:)   y(i)(cid:)x(i),x(cid:)b. (6.) i i1 Hence, if weve found the  s, in order to make a prediction, we have to i calculate a quantity that depends only on the inner product between x and the points in the training set. Moreover, we saw earlier that the  s will all i be zero except for the support vectors. Thus, many of the terms in the sum abovewillbezero, andwereallyneedtofindonlytheinnerproductsbetween x and the support vectors (of which there is often only a small number) in order calculate (6.) and make our prediction. By examining the dual form of the optimization problem, we gained sig nificant insight into the structure of the problem, and were also able to write the entire algorithm in terms of only inner products between input feature vectors. In the next section, we will exploit this property to apply the ker nels to our classification problem. The resulting algorithm, support vector machines, will be able to efficiently learn in very high dimensional spaces. 6.7 Regularization and the nonseparable case (optional reading) The derivation of the SVM as presented so far assumed that the data is linearly separable. While mapping data to a high dimensional feature space via  does generally increase the likelihood that the data is separable, we cant guarantee that it always will be so. Also, in some cases it is not clear that finding a separating hyperplane is exactly what wed want to do, since that might be susceptible to outliers. For instance, the left figure below shows an optimal margin classifier, and when a single outlier is added in the upperleft region (right figure), it causes the decision boundary to make a dramatic swing, and the resulting classifier has a much smaller margin. To make the algorithm work for nonlinearly separable datasets as well as be less sensitive to outliers, we reformulate our optimization (using (cid:) 1 regularization) as follows: n 1 (cid:) min w2 C  ,w,b i 2 i1 s.t. y(i)(wTx(i) b)  1 , i  1,...,n i   0, i  1,...,n. i Thus, examples are now permitted to have (functional) margin less than 1, and if an example has functional margin 1 (with   0), we would pay i a cost of the objective function being increased by C . The parameter C i controls the relative weighting between the twin goals of making the w2 small (which we saw earlier makes the margin large) and of ensuring that most examples have functional margin at least 1. As before, we can form the Lagrangian: n n n 1 (cid:) (cid:) (cid:2) (cid:3) (cid:) L(w,b,,,r)  wTwC    y(i)(xTwb)1  r  . i i i i i 2 i1 i1 i1 Here, the  s and r s are our Lagrange multipliers (constrained to be  0). i i We wont go through the derivation of the dual again in detail, but after setting the derivatives with respect to w and b to zero as before, substituting them back in, and simplifying, we obtain the following dual form of the problem: n n (cid:) 1 (cid:) max W()    y(i)y(j)  (cid:)x(i),x(j)(cid:)  i i j 2 i1 i,j1 s.t. 0    C, i  1,...,n i n (cid:)  y(i)  0, i i1 As before, we also have that w can be expressed in terms of the  s as i given in Equation (6.), so that after solving the dual problem, we can con tinue to use Equation (6.) to make our predictions. Note that, somewhat surprisingly, in adding (cid:) regularization, the only change to the dual prob 1 lem is that what was originally a constraint that 0   has now become i 0    C. The calculation for b also has to be modified (Equation 6. is i no longer valid); see the comments in the next sectionPlatts paper. Also, the KKT dualcomplementarity conditions (which in the next sec tion will be useful for testing for the convergence of the SMO algorithm) are:   0  y(i)(wTx(i) b)  1 (6.) i   C  y(i)(wTx(i) b)  1 (6.) i 0    C  y(i)(wTx(i) b)  1. (6.) i Now, all that remains is to give an algorithm for actually solving the dual problem, which we will do in the next section. 6.8 The SMO algorithm (optional reading) The SMO (sequential minimal optimization) algorithm, due to John Platt, gives an efficient way of solving the dual problem arising from the derivation of the SVM. Partly to motivate the SMO algorithm, and partly because its interesting in its own right, lets first take another digression to talk about the coordinate ascent algorithm. 6.8.1 Coordinate ascent Consider trying to solve the unconstrained optimization problem maxW( , ,..., ). 1 2 n  Here, wethinkofW asjustsomefunctionoftheparameters s, andfornow i ignore any relationship between this problem and SVMs. Weve already seen two optimization algorithms, gradient ascent and Newtons method. The new algorithm were going to consider here is called coordinate ascent: Loop until convergence:  For i  1,...,n,   : argmax W( ,..., , , ,..., ). i i 1 i1 i i1 n   Thus,intheinnermostloopofthisalgorithm,wewillholdallthevariables exceptforsome fixed,andreoptimizeW withrespecttojusttheparameter i  . In the version of this method presented here, the innerloop reoptimizes i thevariablesinorder , ,..., , , ,.... (Amoresophisticatedversion 1 2 n 1 2 might choose other orderings; for instance, we may choose the next variable to update according to which one we expect to allow us to make the largest increase in W().) When the function W happens to be of such a form that the argmax in the inner loop can be performed efficiently, then coordinate ascent can be a fairly efficient algorithm. Heres a picture of coordinate ascent in action: 2.5 2 1.5 1 0.5 0 0.5 1 1.5 2 2 1.5 1 0.5 0 0.5 1 1.5 2 2.5 The ellipses in the figure are the contours of a quadratic function that we want to optimize. Coordinate ascent was initialized at (2,2), and also plottedinthefigureisthepaththatittookonitswaytotheglobalmaximum. Notice that on each step, coordinate ascent takes a step thats parallel to one of the axes, since only one variable is being optimized at a time. 6.8.2 SMO We close off the discussion of SVMs by sketching the derivation of the SMO algorithm. Heres the (dual) optimization problem that we want to solve: n n (cid:) 1 (cid:) max W()    y(i)y(j)  (cid:)x(i),x(j)(cid:). (6.)  i i j 2 i1 i,j1 s.t. 0    C, i  1,...,n (6.) i n (cid:)  y(i)  0. (6.) i i1 Lets say we have set of  s that satisfy the constraints (6.6.). Now, i suppose we want to hold  ,..., fixed, and take a coordinate ascent step 2 n and reoptimize the objective with respect to  . Can we make any progress? 1 The answer is no, because the constraint (6.) ensures that n (cid:)  y(1)    y(i). 1 i i2 Or, by multiplying both sides by y(1), we equivalently have n (cid:)   y(1)  y(i). 1 i i2 (This step used the fact that y(1)  1,1, and hence (y(1))2  1.) Hence,  is exactly determined by the other  s, and if we were to hold  ,..., 1 i 2 n fixed, then we cant make any change to  without violating the con 1 straint (6.) in the optimization problem. Thus, if we want to update some subject of the  s, we must update at i least two of them simultaneously in order to keep satisfying the constraints. This motivates the SMO algorithm, which simply does the following: Repeat till convergence  1. Select some pair  and  to update next (using a heuristic that i j tries to pick the two that will allow us to make the biggest progress towards the global maximum). 2. Reoptimize W() with respect to  and  , while holding all the i j other  s (k (cid:) i,j) fixed. k  To test for convergence of this algorithm, we can check whether the KKT conditions (Equations 6.6.) are satisfied to within some tol. Here, tol is the convergence tolerance parameter, and is typically set to around 0. to 0.. (See the paper and pseudocode for details.) The key reason that SMO is an efficient algorithm is that the update to  ,  can be computed very efficiently. Lets now briefly sketch the main i j ideas for deriving the efficient update. Lets say we currently have some setting of the  s that satisfy the con i straints (6.6.), and suppose weve decided to hold  ,..., fixed, and 3 n want to reoptimize W( , ,..., ) with respect to  and  (subject to 1 2 n 1 2 the constraints). From (6.), we require that n (cid:)  y(1)  y(2)    y(i). 1 2 i i3 Since the right hand side is fixed (as weve fixed  ,... ), we can just let 3 n it be denoted by some constant :  y(1)  y(2)  . (6.) 1 2 We can thus picture the constraints on  and  as follows: 1 2 C H y(1)y(2) 1 2  2 L  C 1 From the constraints (6.), we know that  and  must lie within the box 1 2 [0,C][0,C] shown. Also plotted is the line  y(1) y(2)  , on which we 1 2 know  and  must lie. Note also that, from these constraints, we know 1 2 L    H; otherwise, ( , ) cant simultaneously satisfy both the box 2 1 2 and the straight line constraint. In this example, L  0. But depending on what the line  y(1)  y(2)   looks like, this wont always necessarily be 1 2 the case; but more generally, there will be some lowerbound L and some upperbound H on the permissible values for  that will ensure that  ,  2 1 2 lie within the box [0,C][0,C]. Using Equation (6.), we can also write  as a function of  : 1 2   (  y(2))y(1). 1 2 (Check this derivation yourself; we again used the fact that y(1)  1,1 so that (y(1))2  1.) Hence, the objective W() can be written W( , ,..., )  W((  y(2))y(1), ,..., ). 1 2 n 2 2 n Treating  ,..., as constants, you should be able to verify that this is 3 n just some quadratic function in  . I.e., this can also be expressed in the 2 form a2 b c for some appropriate a, b, and c. If we ignore the box 2 2 constraints (6.) (or, equivalently, that L    H), then we can easily 2 maximizethisquadraticfunctionbysettingitsderivativetozeroandsolving. Well let new,unclipped denote the resulting value of  . You should also be 2 2 able to convince yourself that if we had instead wanted to maximize W with respect to but subject to thebox constraint, thenwe can findthe resulting 2 value optimal simply by taking new,unclipped and clipping it to lie in the 2 [L,H] interval, to get  H if new,unclipped  H  2 new  new,unclipped if L  new,unclipped  H 2 2 2  L if new,unclipped  L 2 Finally, having found the new, we can use Equation (6.) to go back and 2 find the optimal value of new. 1 Therere a couple more details that are quite easy but that well leave you to read about yourself in Platts paper: One is the choice of the heuristics used to select the next  ,  to update; the other is how to update b as the i j SMO algorithm is run. Part II Deep learning Chapter 7 Deep learning We now begin our study of deep learning. In this set of notes, we give an overview of neuralnetworks, discussvectorizationand discuss trainingneural networks with backpropagation. 7.1 Supervised learning with nonlinear mod els In the supervised learning setting (predicting y from the input x), suppose our modelhypothesis is h (x). In the past lectures, we have considered the  cases when h (x)  (cid:)x (in linear regression) or h (x)  (cid:)(x) (where (x)   is the feature map). A commonality of these two models is that they are linear in the parameters . Next we will consider learning general family of models that are nonlinear in both the parameters  and the inputs x. The most common nonlinear models are neural networks, which we will define staring from the next section. For this section, it suffices to think h (x) as  an abstract nonlinear model.1 Suppose (x(i),y(i))n are the training examples. We will define the i1 nonlinear model and the losscost function for learning it. Regression problems. For simplicity, we start with the case where the output is a real number, that is, y(i)  R, and thus the model h also outputs  a real number h (x)  R. We define the least square cost function for the  1Ifaconcreteexampleishelpful,perhapsthinkaboutthemodelh (x)2x22x2  1 1 2 2 2x2 in this subsection, even though its not a neural network. d d ith example (x(i),y(i)) as 1 J(i)()  (h (x(i))y(i))2, (7.1)  2 and define the meansquare cost function for the dataset as n 1 (cid:) J()  J(i)(), (7.2) n i1 which is same as in linear regression except that we introduce a constant 1n in front of the cost function to be consistent with the convention. Note that multiplying the cost function with a scalar will not change the local minima or global minima of the cost function. Also note that the underlying parameterization for h (x) is different from the case of linear regression,  even though the form of the cost function is the same meansquared loss. Throughout the notes, we use the words loss and cost interchangeably. Binary classification. Next we define the model and loss function for binary classification. Suppose the inputs x  Rd. Let h  : Rd  R be a  parameterized model (the analog of (cid:)x in logistic linear regression). We call the output h  (x)  R the logit. Analogous to Section 2.1, we use the   logistic function g() to turn the logit h (x) to a probability h (x)  [0,1]:     h (x)  g(h (x))  1(1exp(h (x)). (7.3)    We model the conditional distribution of y given x and  by P(y  1  x;)  h (x)  P(y  0  x;)  1h (x)  Following the same derivation in Section 2.1 and using the derivation in Remark 2.1.1, the negative likelihood loss function is equal to: J(i)()  logp(y(i)  x(i);)  (cid:) (h  (x(i)),y(i)) (7.4) logistic  Asdoneinequation(7.2), thetotallossfunctionisalsodefinedastheaverage of the loss function over individual training examples, J()  1 (cid:)n J(i)(). n i1 Multiclass classification. Following Section 2.3, we consider a classifica tion problem where the response variable y can take on any one of k values, i.e. y  1,2,...,k. Let h  : Rd  Rk be a parameterized model. We  call the outputs h  (x)  Rk the logits. Each logit corresponds to the predic  tion for one of the k classes. Analogous to Section 2.3, we use the softmax  function to turn the logits h (x) into a probability vector with nonnegative  entries that sum up to 1:  exp(h (x) )  j P(y  j  x;)  , (7.5) (cid:)k exp(h  (x) ) s1  s   where h (x) denotes the sth coordinate of h (x).  s  Similarly to Section 2.3, the loss function for a single training example (x(i),y(i)) is its negative loglikelihood: (cid:) exp(h  (x(i)) ) (cid:) J(i)()  logp(y(i)  x(i);)  log  y(i) . (7.6) (cid:)k exp(h  (x(i)) ) s1  s Using the notations of Section 2.3, we can simply write in an abstract way: J(i)()  (cid:) (h  (x(i)),y(i)). (7.7) ce  The loss function is also defined as the average of the loss function of indi vidual training examples, J()  1 (cid:)n J(i)(). n i1 We also note that the approach above can also be generated to any con ditional probabilistic model where we have an exponential distribution for  y, Exponentialfamily(y;), where   h (x) is a parameterized nonlinear  function of x. However, the most widely used situations are the three cases discussed above. Optimizers(SGD). Commonly,peopleusegradientdescent(GD),stochas tic gradient (SGD), or their variants to optimize the loss function J(). GDs update rule can be written as2  :  J() (7.8)  where   0 is often referred to as the learning rate or step size. Next, we introduce a version of the SGD (Algorithm 1), which is lightly different from that in the first lecture notes. 2Recall that, as defined in the previous lecture notes, we use the notation a : b to denote an operation (in a computer program) in which we set the value of a variable a to be equal to the value of b. In other words, this operation overwrites a with the value of b. In contrast, we will write a  b when we are asserting a statement of fact, that the value of a is equal to the value of b. Algorithm 1 Stochastic Gradient Descent 1: Hyperparameter: learning rate , number of total iteration n . iter 2: Initialize  randomly. 3: for i  1 to n do iter 4: Sample j uniformly from 1,...,n, and update  by  :  J(j)() (7.9)  Oftentimes computing the gradient of B examples simultaneously for the parameter  can be faster than computing B gradients separately due to hardware parallelization. Therefore, a minibatch version of SGD is most commonly used in deep learning, as shown in Algorithm 2. There are also other variants of the SGD or minibatch SGD with slightly different sampling schemes. Algorithm 2 Minibatch Stochastic Gradient Descent 1: Hyperparameters: learning rate , batch size B,  iterations n . iter 2: Initialize  randomly 3: for i  1 to n do iter 4: Sample B examples j ,...,j (without replacement) uniformly from 1 B 1,...,n, and update  by B  (cid:)  :   J(j k )() (7.)  B k1 With these generic algorithms, a typical deep learning model is learned with the following steps. 1. Define a neural network parametrization h (x),  which we will introduce in Section 7.2, and 2. write the backpropagation algorithm to compute the gradient of the loss function J(j)() efficiently, which will be covered in Section 7.4, and 3. run SGD or minibatch SGD (or other gradientbased optimizers) with the loss function J(). 7.2 Neural networks Neural networks refer to a broad type of nonlinear modelsparametrizations  h (x) that involve combinations of matrix multiplications and other entry  wise nonlinear operations. To have a unified treatment for regression prob  lem and classification problem, here we consider h (x) as the output of the   neural network. For regression problem, the final prediction h (x)  h (x),    andforclassificationproblem,h (x)isthelogitsandthepredictedprobability   will be h (x)  1(1exp(h (x)) (see equation 7.3) for binary classification    or h (x)  softmax(h (x)) for multiclass classification (see equation 7.5).   We will start small and slowly build up a neural network, step by step. A Neural Network with a Single Neuron. Recall the housing price prediction problem from before: given the size of the house, we want to predict the price. We will use it as a running example in this subsection. Previously, we fit a straight line to the graph of size vs. housing price. Now, instead of fitting a straight line, we wish to prevent negative housing prices by setting the absolute minimum price as zero. This produces a kink in the graph as shown in Figure 7.1. How do we represent such a function  with a single kink as h (x) with unknown parameter? (After doing so, we  can invoke the machinery in Section 7.1.)  We define a parameterized function h (x) with input x, parameterized by   , which outputs the price of the house y. Formally, h : x  y. Perhaps  one of the simplest parametrization would be h  (x)  max(wxb,0), where   (w,b)  R2 (7.)   Hereh (x)returnsasinglevalue: (wxb)orzero, whicheverisgreater. In  the context of neural networks, the function maxt,0 is called a ReLU (pro nounced raylu), or rectified linear unit, and often denoted by ReLU(t) (cid:) maxt,0. Generally,aonedimensionalnonlinearfunctionthatmapsRtoRsuchas  ReLUisoftenreferredtoasanactivation function. Themodelh (x)issaid  to have a single neuron partly because it has a single nonlinear activation function. (We will discuss more about why a nonlinear activation is called neuron.) When the input x  Rd has multiple dimensions, a neural network with a single neuron can be written as h  (x)  ReLU(w(cid:)xb), where w  Rd, b  R, and   (w,b) (7.)  housing prices 0 square feet ) ni( ecirp Figure 7.1: Housing prices with a kink in the graph. The term b is often referred to as the bias, and the vector w is referred to as the weight vector. Such a neural network has 1 layer. (We will define what multiple layers mean in the sequel.) Stacking Neurons. A more complex neural network may take the single neuron described above and stack them together such that one neuron passes its output as input into the next neuron, resulting in a more complex function. Letusnowdeepenthehousingpredictionexample. Inadditiontothesize of the house, suppose that you know the number of bedrooms, the zip code and the wealth of the neighborhood. Building neural networks is analogous to Lego bricks: you take individual bricks and stack them together to build complex structures. The same applies to neural networks: we take individual neurons and stack them together to create complex neural networks. Given these features (size, number of bedrooms, zip code, and wealth), we might then decide that the price of the house depends on the maximum family size it can accommodate. Suppose the family size is a function of the size of the house and number of bedrooms (see Figure 7.2). The zip code may provide additional information such as how walkable the neighborhood is(i.e., canyouwalktothegrocerystoreordoyouneedtodriveeverywhere). Combining the zip code with the wealth of the neighborhood may predict the quality of the local elementary school. Given these three derived features (family size, walkable, school quality), we may conclude that the price of the home ultimately depends on these three features. Size  Bedrooms Family Size Price y Walkable Zip Code School Quality Wealth Figure 7.2: Diagram of a small neural network for predicting housing prices. Formally, the input to a neural network is a set of input features x ,x ,x ,x . We denote the intermediate variables for family size, walk 1 2 3 4 able, and school quality by a ,a ,a (these a s are often referred to as 1 2 3 i hidden units or hidden neurons). We represent each of the a s as a neu i ral network with a single neuron with a subset of x ,...,x as inputs. Then 1 4 as in Figure 7.1, we will have the parameterization: a  ReLU( x  x  ) 1 1 1 2 2 3 a  ReLU( x  ) 2 4 3 5 a  ReLU( x  x  ) 3 6 3 7 4 8  where ( , , ) are parameters. Now we represent the final output h (x) 1 8  as another linear function with a ,a ,a as inputs, and we get3 1 2 3  h (x)   a  a  a  (7.)  9 1 2 3 where  contains all the parameters ( , , ). 1 Now we represent the output as a quite complex function of x with pa  rameters . Then you can use this parametrization h with the machinery of  Section 7.1 to learn the parameters . Inspiration from Biological Neural Networks. As the name suggests, artificial neural networks were inspired by biological neural networks. The hidden units a ,...,a correspond to the neurons in a biological neural net 1 m work, and the parameters  s correspond to the synapses. However, its i unclear how similar the modern deep artificial neural networks are to the bi ologicalones. Forexample, perhapsnotmanyneuroscientiststhinkbiological 3Typically, for multilayer neural network, at the end, near the output, we dont apply ReLU, especially when the output is not necessarily a positive number. neural networks could have layers, while some modern artificial neural networks do (we will elaborate more on the notion of layers.) Moreover, its an open question whether human brains update their neural networks in a way similar to the way that computer scientists learn artificial neural net works (using backpropagation, which we will introduce in the next section.). Twolayer FullyConnected Neural Networks. We constructed the neural network in equation (7.) using a significant amount of prior knowl edgebeliefabouthowthefamilysize, walkable, andschoolqualityare determined by the inputs. We implicitly assumed that we know the family size is an important quantity to look at and that it can be determined by only the size and  bedrooms. Such a prior knowledge might not be available for other applications. It would be more flexible and general to have a generic parameterization. A simple way would be to write the intermediate variable a as a function of all x ,...,x : 1 1 4 a  ReLU(w(cid:)xb ), where w  R4 and b  R (7.) 1 1 1 1 1 a  ReLU(w(cid:)xb ), where w  R4 and b  R 2 2 2 2 2 a  ReLU(w(cid:)xb ), where w  R4 and b  R 3 3 3 3 3  We still define h (x) using equation (7.) with a ,a ,a being defined as  1 2 3 above. Thus we have a socalled fullyconnected neural network because all the intermediate variables a s depend on all the inputs x s. i i For full generality, a twolayer fullyconnected neural network with m hidden units and d dimensional input x  Rd is defined as j  [1,...,m], z  w[1](cid:) xb[1] where w[1]  Rd,b[1]  R (7.) j j j j j a  ReLU(z ), j j a  [a ,...,a ](cid:)  Rm 1 m h  (x)  w[2](cid:) ab[2] where w[2]  Rm,b[2]  R, (7.)  Note that by default the vectors in Rd are viewed as column vectors, and in particular a is a column vector with components a ,a ,...,a . The indices 1 2 m [1] and [2] are used to distinguish two sets of parameters: the w[1]s (each of j which is a vector in Rd) and w[2] (which is a vector in Rm). We will have more of these later. Vectorization. Before we introduce neural networks with more layers and more complex structures, we will simplify the expressions for neural networks with more matrix and vector notations. Another important motivation of vectorization is the speed perspective in the implementation. In order to implement a neural network efficiently, one must be careful when using for loops. The most natural way to implement equation (7.) in code is perhaps to use a for loop. In practice, the dimensionalities of the inputs and hidden units are high. As a result, code will run very slowly if you use for loops. Leveraging the parallelism in GPUs iswas crucial for the progress of deep learning. This gave rise to vectorization. Instead of using for loops, vectorization takes advantage of matrix algebra and highly optimized numerical linear algebra packages (e.g., BLAS) to make neural network computations run quickly. Before the deep learning era, a for loop may have been sufficient on smaller datasets, but modern deep networks and stateoftheart datasets will be infeasible to run with for loops. We vectorize the twolayer fullyconnected neural network as below. We define a weight matrix W[1] in Rmd as the concatenation of all the vectors w[1]s in the following way: j   w[1](cid:)   1 W[1]      w 2 [ . 1](cid:)      Rmd (7.)  . .     w[1](cid:)  m Now by the definition of matrix vector multiplication, we can write z  [z ,...,z ](cid:)  Rm as 1 m  z 1    w 1 [1](cid:)    x 1   b[ 1 1]      . . . . . .           w 2 [ . . . 1](cid:)          x . . . 2          b[ 2 . . . 1]     (7.)   z m  w[1](cid:)  x d b[ m 1] m (cid:) (cid:)(cid:) (cid:) (cid:) (cid:)(cid:) (cid:) (cid:) (cid:)(cid:) (cid:) z  Rm1 (cid:) W[1]  (cid:)(cid:) Rmd (cid:) x  Rd1 b[1]  Rm1 Or succinctly, z  W[1]xb[1] (7.) We remark again that a vector in Rd in this notes, following the conventions previously established, is automatically viewed as a column vector, and can also be viewed as a d  1 dimensional matrix. (Note that this is different from numpy where a vector is viewed as a row vector in broadcasting.) Computing the activations a  Rm from z  Rm involves an element wise nonlinear application of the ReLU function, which can be computed in parallel efficiently. Overloading ReLU for elementwise application of ReLU (meaning, for a vector t  Rd, ReLU(t) is a vector such that ReLU(t)  i ReLU(t )), we have i a  ReLU(z) (7.) Define W[2]  [w[2](cid:) ]  R1m similarly. Then, the model in equa tion (7.) can be summarized as a  ReLU(W[1]xb[1]) h  (x)  W[2]ab[2] (7.)  Here  consists of W[1],W[2] (often referred to as the weight matrices) and b[1],b[2] (referred to as the biases). The collection of W[1],b[1] is referred to as thefirstlayer, andW[2],b[2] thesecondlayer. Theactivationaisreferredtoas the hidden layer. A twolayer neural network is also called onehiddenlayer neural network. Multilayer fullyconnected neural networks. With this succinct no tations, we can stack more layers to get a deeper fullyconnected neu ral network. Let r be the number of layers (weight matrices). Let W[1],...,W[r],b[1],...,b[r] be the weight matrices and biases of all the layers. Then a multilayer neural network can be written as a[1]  ReLU(W[1]xb[1]) a[2]  ReLU(W[2]a[1] b[2])  a[r1]  ReLU(W[r1]a[r2] b[r1]) h  (x)  W[r]a[r1] b[r] (7.)  We note that the weight matrices and biases need to have compatible dimensions for the equations above to make sense. If a[k] has dimension m , k then the weight matrix W[k] should be of dimension m m , and the bias k k1 b[k]  Rm k. Moreover, W[1]  Rm1d and W[r]  R1mr1. The total number of neurons in the network is m    m , and the 1 r total number of parameters in this network is (d1)m (m 1)m  1 1 2 (m 1)m . r1 r Sometimes for notational consistency we also write a[0]  x, and a[r]  h (x). Then we have simple recursion that  a[k]  ReLU(W[k]a[k1] b[k]),k  1,...,r1 (7.) Note that this would have be true for k  r if there were an additional ReLU in equation (7.), but often people like to make the last layer linear (aka without a ReLU) so that negative outputs are possible and its easier to interpret the last layer as a linear model. (More on the interpretability at the connection to kernel method paragraph of this section.) Other activation functions. The activation function ReLU can be re placed by many other nonlinear function () that maps R to R such as 1 (z)  (sigmoid) (7.) 1ez ez ez (z)  (tanh) (7.) ez ez (z)  maxz,z,  (0,1) (leaky ReLU) (7.) (cid:) (cid:) z z (z)  1erf( ) (GELU) (7.) 2 2 1 (z)  log(1exp(z)),  0 (Softplus) (7.)  The activation functions are plotted in Figure 7.3. Sigmoid and tanh are lessandlessusedthesedayspartlybecausetheirareboundedfrombothsides and the gradient of them vanishes as z goes to both positive and negative infinity (whereas all the other activation functions still have gradients as the input goes to positive infinity.) Softplus is not used very often either in practice and can be viewed as a smoothing of the ReLU so that it has a proper second order derivative. GELU and leaky ReLU are both variants of ReLU but they have some nonzero gradient even when the input is negative. GELU (or its slight variant) is used in NLP models such as BERT and GPT (which we will discuss in Chapter .) Why do we not use the identity function for (z)? That is, why not use (z)  z? Assume for sake of argument that b[1] and b[2] are zeros. Figure 7.3: Activation functions in deep learning. Suppose (z)  z, then for twolayer neural network, we have that h  (x)  W[2]a[1] (7.)   W[2](z[1]) by definition (7.)  W[2]z[1] since (z)  z (7.)  W[2]W[1]x from Equation (7.) (7.)  W  x where W   W[2]W[1] (7.) Notice how W[2]W[1] collapsed into W  . This is because applying a linear function to another linear function will  result in a linear function over the original input (i.e., you can construct a W such that W  x  W[2]W[1]x). This loses much of the representational power of the neural network as often times the output we are trying to predict has a nonlinear relationship with the inputs. Without nonlinear activation functions, the neural network will simply perform linear regression. Connection to the Kernel Method. Inthepreviouslectures,wecovered the concept of feature maps. Recall that the main motivation for feature maps is to represent functions that are nonlinear in the input x by (cid:)(x), where  are the parameters and (x), the feature map, is a handcrafted function nonlinear in the raw input x. The performance of the learning algorithms can significantly depends on the choice of the feature map (x). Oftentimespeopleusedomainknowledgetodesignthefeaturemap(x)that suits the particular applications. The process of choosing the feature maps is often referred to as feature engineering. We can view deep learning as a way to automatically learn the right feature map (sometimes also referred to as the representation) as follows. Suppose we denote by  the collection of the parameters in a fullyconnected neural networks (equation (7.)) except those in the last layer. Then we can abstract right a[r1] as a function of the input x and the parameters in : a[r1]   (x). Now we can write the model as  h  (x)  W[r] (x)b[r] (7.)    When  is fixed, then  () can viewed as a feature map, and therefore h (x)   is just a linear model over the features  (x). However, we will train the  neural networks, both the parameters in  and the parameters W[r],b[r] are optimized, and therefore we are not learning a linear model in the feature space, but also learning a good feature map  () itself so that its possi  ble to predict accurately with a linear model on top of the feature map. Therefore, deep learning tends to depend less on the domain knowledge of the particular applications and requires often less feature engineering. The penultimate layer a[r] is often (informally) referred to as the learned features or representations in the context of deep learning. Intheexampleofhousepriceprediction, afullyconnectedneuralnetwork does not need us to specify the intermediate quantity such family size, and may automatically discover some useful features in the last penultimate layer (the activation a[r1]), and use them to linearly predict the housing price. Often the feature map  representation obtained from one datasets (that is, the function  () can be also useful for other datasets, which indicates they  containessentialinformationaboutthedata. However,oftentimes,theneural network will discover complex features which are very useful for predicting the output but may be difficult for a human to understand or interpret. This is why some people refer to neural networks as a black box, as it can be difficult to understand the features it has discovered. 7.3 Modules in Modern Neural Networks The multilayer neural network introduced in equation (7.) of Section 7.2 is often called multilayer perceptron (MLP) these days. Modern neural net works used in practice are often much more complex and consist of multiple building blocks or multiple layers of building blocks. In this section, we will introduce some of the other building blocks and discuss possible ways to combine them. First, each matrix multiplication can be viewed as a building block. Con sider a matrix multiplication operation with parameters (W,b) where W is the weight matrix and b is the bias vector, operating on an input z, MM (z)  Wz b. (7.) W,b Note that we implicitly assume all the dimensions are chosen to be compat ible. We will also drop the subscripts under MM when they are clear in the context or just for convenience when they are not essential to the discussion. Then, the MLP can be written as as a composition of multiple matrix multiplication modules and nonlinear activation modules (which can also be viewed as a building block): MLP(x)  MM ((MM ((MM (x)))). (7.) W[r],b[r] W[r1],b[r1] W[1],b[1] Alternatively, when we drop the subscripts that indicate the parameters for convenience, we can write MLP(x)  MM((MM(MM(x)))). (7.) Note that in this lecture notes, by default, all the modules have different sets of parameters, and the dimensions of the parameters are chosen such that the composition is meaningful. Larger modules can be defined via smaller modules as well, e.g., one activation layer  and a matrix multiplication layer MM are often combined and called a layer in many papers. People often draw the architecture with the basic modules in a figure by indicating the dependency between these modules. E.g., see an illustration of an MLP in Figure 7.4, Left. Residual connections. One of the very influential neural network archi tecture for vision application is ResNet, which uses the residual connections that are essentially used in almost all largescale deep learning architectures these days. Using our notation above, a very much simplified residual block can be defined as Res(z)  z (MM((MM(z)))). (7.) A much simplified ResNet is a composition of many residual blocks followed by a matrix multiplication, ResNetS(x)  MM(Res(Res(Res(x)))). (7.) Layer 1 Layer   ... MLP() Layer 1 ... MM ![],[] Layer Res  Res MM ![],[]  ... ResNetS() Res ... Res  MM  MM Figure 7.4: Illustrative Figures for Architecture. Left: An MLP with r layers. Right: A residual network. We also draw the dependency of these modules in Figure 7.4, Right. We note that the ResNetS is still not the same as the ResNet architec ture introduced in the seminal paper [He et al., ] because ResNet uses convolution layers instead of vanilla matrix multiplication, and adds batch normalization between convolutions and activations. We will introduce con volutional layers and some variants of batch normalization below. ResNetS and layer normalization are part of the Transformer architecture that are widely used in modern large language models. Layer normalization. Layer normalization, denoted by LN in this text, is a module that maps a vector z  Rm to a more normalized vector LN(z)  Rm. It is oftentimes used after the nonlinear activations. We first define a submodule of the layer normalization, denoted by LNS.   z1  z2 LNS(z)    . , (7.)  .  .   zm  (cid:) where   (cid:)m i1 zi is the empirical mean of the vector z and   (cid:)m i1 (zi2) m m is the empirical standard deviation of the entries of z.4 Intuitively, LNS(z) is a vector that is normalized to having empirical mean zero and empirical standard deviation 1. 4Note that we divide by m instead of m1 in the empirical standard deviation here because we are interested in making the output of LNS(z) have sum of squares equal to 1 (as opposed to estimating the standard deviation in statistics.) Oftentimes zero mean and standard deviation 1 is not the most desired normalizationscheme,andthuslayernormintroducestoparameterslearnable scalars  and  as the desired mean and standard deviation, and use an affine transformation to turn the output of LNS(z) into a vector with mean  and standard deviation .    (cid:0)z1(cid:1)   (cid:0)z2  (cid:1)  LN(z)    LNS(z)   .  . (7.)  .  .     (cid:0)zm(cid:1)  Here the first occurrence of  should be technically interpreted as a vector with all the entries being . in We also note that  and  are also functions of z and shouldnt be treated as constants when computing the derivatives of layernorm. Moreover,  and  are learnable parameters and thus layernorm is a parameterized module (as opposed to the activation layer which doesnt have any parameters.) Scalinginvariant property. One important property of layer normalization is that it will make the model invariant to scaling of the parameters in the following sense. Suppose we consider composing LN with MM and get W,b a subnetwork LN(MM (z)). Then, we have that the output of this sub W,b network does not change when the parameter in MM is scaled: W,b LN(MM (z))  LN(MM (z)),  0. (7.) W,b W,b To see this, we first know that LNS() is scaleinvariant     z1 z1   z2 z2 LNS(z)    .      .   LNS(z). (7.)  .   .  . .     zm zm   Then we have LN(MM (z))   LNS(MM (z)) (7.) W,b W,b   LNS(MM (z)) (7.) W,b   LNS(MM (z)) (7.) W,b  LN(MM (z)). (7.) W,b Due to this property, most of the modern DL architectures for largescale computer vision and language applications have the following scaleinvariant property w.r.t all the weights that are not at the last layer. Suppose the network f has last layer weights W , and all the rest of the weights are last denote by W. Then, we have f (x)  f (x) for all   0. Here, W ,W W ,W last last the last layers weights are special because there are typically no layernorm or batchnorm after the last layers weights. Other normalization layers. Thereareseveralothernormalizationlayersthat aim to normalize the intermediate layers of the neural networks to a more fixed and controllable scaling, such as batchnormalization [?], and group normalization [?]. Batch normalization and group normalization are more often used in computer vision applications whereas layer norm is used more often in language applications. Convolutional Layers. Convolutional Neural Networks are neural net works that consist of convolution layers (and many other modules), and are particularly useful for computer vision applications. For the simplicity of exposition, we focus on 1D convolution in this text and only briefly mention 2D convolution informally at the end of this subsection. (2D convolution is more suitable for images which have two dimensions. 1D convolution is also used in natural language processing.) We start by introducing a simplified version of the 1D convolution layer, denoted by Conv1DS() which is a type of matrix multiplication layer with a special structure. The parameters of Conv1DS are a filter vector w  Rk where k is called the filter size (oftentimes k (cid:) m), and a bias scalar b. Oftentimes the filter is also called a kernel (but it does not have much to do with the kernel in kernel method.) For simplicity, we assume k  2(cid:)1 is an odd number. We first pad zeros to the input vector z in the sense that we let z  z  ..  z  0 and z  z  ..  z  0, and treat 1(cid:) 1(cid:)1 0 m1 m2 m(cid:) z as an (m2(cid:))dimension vector. Conv1DS outputs a vector of dimension Rm where each output dimension is a linear combination of subsets of z s j with coefficients from w, 2(cid:)1 (cid:) Conv1DS(z)  w z w z w z  w z . i 1 i(cid:) 2 i(cid:)1 2(cid:)1 i(cid:) j i(cid:)(j1) j1 (7.) Therefore, one can view Conv1DS as a matrix multiplication with shared parameters: Conv1DS(z)  Qz, where  w  w 0 0       0  (cid:)1 2(cid:)1 w  w w 0       0  (cid:) 2(cid:) 2(cid:)1    . .    .      w1  w (cid:)1    w 2(cid:)1 0    0     0 w1     w 2(cid:) w 2(cid:)1 0   0    .  Q . . (7.)  .       . . .      0      0 w1   w 2(cid:)1     . .    .  0        0 w1  w (cid:)1 Note that Q  Q for all i,j  2,...,m, and thus convoluation is a i,j i1,j1 matrix multiplication with parameter sharing. We also note that computing the convolution only takes O(km) times but computing a generic matrix multiplication takes O(m2) time. Convolution has k parameters but generic matrixmultiplicationwillhavem2 parameters. Thusconvolutionissupposed to be much more efficient than a generic matrix multiplication (as long as the additional structure imposed does not hurt the flexibility of the model to fit the data). We also note that in practice there are many variants of the convolutional layersthatwedefinehere,e.g.,thereareotherwaystopadzerosorsometimes thedimensionoftheoutputoftheconvolutionallayerscouldbedifferentfrom the input. We omit some of this subtleties here for simplicity. The convolutional layers used in practice have also many channels and the simplified version above corresponds to the 1channel version. Formally, Conv1D takes in C vectors z ,...,z  Rm as inputs, where C is referred 1 C to as the number of channels. In other words, the more general version, denoted by Conv1D, takes in a matrix as input, which is the concatenation of z ,...,z and has dimension mC. It can output C(cid:) vectors of dimension 1 C m, denoted by Conv1D(z) ,...,Conv1D(z) , where C(cid:) is referred to as the 1 C(cid:) output channel, or equivalently a matrix of dimension mC(cid:). Each of the output is a sum of the simplified convolutions applied on various channels. C (cid:) i  [C(cid:)],Conv1D(z)  Conv1DS (z ). (7.) i i,j j j1 Note that each Conv1DS are modules with different parameters, and i,j thus the total number of parameters is k (the number of parameters in a Conv1DS) CC(cid:) (the number of Conv1DS s)  kCC(cid:). In contrast, a i.j generic linear mapping from RmC and RmC(cid:) has m2CC(cid:) parameters. The parameters can also be represented as a threedimensional tensor of dimen sion k C C(cid:). 2D convolution (brief). A 2D convolution with one channel, denoted by Conv2DS, is analogous to the Conv1DS, but takes a 2dimensional input z  Rmm and applies a filter of size k  k, and outputs Conv2DS(z)  Rmm. The full 2D convolutional layer, denoted by Conv2D, takes in a sequence of matrices z ,...,z  Rmm, or equivalently a 3D ten 1 C sor z  (z ,...,z )  RmmC and outputs a sequence of matrices, 1 C Conv2D(z) ,...,Conv2D(z)  Rmm, which can also be viewed as a 3D 1 C(cid:) tensor in RmmC(cid:). Each channel of the output is sum of the outcomes of applying Conv2DS layers on all the input channels. C (cid:) i  [C(cid:)],Conv2D(z)  Conv2DS (z ). (7.) i i,j j j1 Because there are CC(cid:) number of Conv2DS modules and each of the Conv2DS module has k2 parameters, the total number of parameters is CC(cid:)k2. The parameters can also be viewed as a 4D tensor of dimension C C(cid:) k k. 7.4 Backpropagation In this section, we introduce backpropgation or autodifferentiation, which computes the gradient of the loss J() efficiently. We will start with an informal theorem that states that as long as a realvalued function f can be efficiently computedevaluated by a differentiable network or circuit, then its gradient can be efficiently computed in a similar time. We will then show how to do this concretely for neural networks. Because the formality of the general theorem is not the main focus here, we will introduce the terms with informal definitions. By a differentiable circuit or a differentiable network, we mean a composition of a sequence of differentiable arithmetic operations (additions, subtraction, multiplication, divisions, etc) and elementary differentiable functions (ReLU, exp, log, sin, cos, etc.). Let the size of the circuit be the total number of such operations and elementary functions. We assume that each of the operations and func tions, and their derivatives or partial derivatives ecan be computed in O(1) time. Theorem 7.4.1: [backpropagation or autodifferentiation, informally stated] Suppose a differentiable circuit of size N computes a realvalued function f : R(cid:)  R. Then, the gradient f can be computed in time O(N), by a circuit of size O(N).5 We note that the loss function J(j)() for jth example can be indeed computed by a sequence of operations and functions involving additions, subtraction, multiplications, and nonlinear activations. Thus the theorem suggests that we should be able to compute the J(j)() in a similar time to that for computing J(j)() itself. This does not only apply to the fully connected neural network introduced in the Section 7.2, but also many other types of neural networks that uses more advance modules. We remark that autodifferentiation or backpropagation is already imple mented in all the deep learning packages such as tensorflow and pytorch, and thus in practice, in most of cases a researcher does not need to write their backpropagation algorithms. However, understanding it is very helpful for gaining insights into the working of deep learning. Organization of the rest of the section. In Section 7.4.1, we will start review ing the basic Chain rule with a new perspective that is particularly useful for understanding backpropgation. Section 7.4.2 will introduce the general strategy for backpropagation. Section 7.4.2 will discuss how to compute the socalled backward function for basic modules used in neural networks, and Section 7.4.4 will put everything together to get a concrete backprop algo rithm for MLPs. 7.4.1 Preliminaries on partial derivatives Suppose a scalar variable J depend on some variables z (which could be a scalar, matrix, or highorder tensor), we write J as the partial derivatives z of J w.r.t to the variable z. We stress that the convention here is that J z has exactly the same dimension as z itself. For example, if z  Rmn, then J  Rmn, and the (i,j)entry of J is equal to J . z z zij Remark 7.4.2: WhenbothJ andz arenotscalars, thepartialderivativesof J w.r.t z becomes either a matrix or tensor and the notation becomes some what tricky. Besides the mathematical or notational challenges in dealing 5We note if the output of the function f does not depend on some of the input co ordinates, then we set by default the gradient w.r.t that coordinate to zero. Setting to zerodoesnotcounttowardsthetotalruntimehereinouraccountingscheme. Thisiswhy whenN (cid:), wecancomputethegradientinO(N)time, whichmightbepotentiallyeven less than (cid:). with these partial derivatives of multivariate functions, they are also expen sive to compute and store, and thus rarely explicitly constructed empirically. The experience of authors of this note is that its generally more productive to think only about derivatives of scalar function w.r.t to vector, matrices, or tensors. For example, in this note, we will not deal with derivatives of multivariate functions. Chain rule. We review the chain rule in calculus but with a perspective and notions that are more relevant for autodifferentiation. Consider a scalar variable J which is obtained by the composition of f and g on some variable z, z  Rm u  g(z)  Rn J  f(u)  R. (7.) The same derivations below can be easily extend to the cases when z and u are matrices or tensors; but we insist that the final variable J is a scalar. (See also Remark 7.4.2.) Let u  (u ,...,u ) and let g(z)  (g (z), ,g (z)). 1 n 1 n Then, the standard chain rule gives us that n J (cid:) J g j i  1,...,m,   . (7.) z u z i j i j1 Alternatively, when z and u are both vectors, in a vectorized notation: g1  gn  J    . . . z1 ...  . . . z1  J . (7.) z   u g1  gn zm zm In other words, the backward function is always a linear map from J to u J, though note that the mapping itself can depend on z in complex ways. z The matrix on the RHS of (7.) is actually the transpose of the Jacobian matrixofthefunctiong. However, wedonotdiscussindepthaboutJacobian matrices to avoid complications. Part of the reason is that when z is a matrix (or tensor), to write an analog of equation (7.), one has to either flatten z into a vector or introduce additional notations on tensormatrix product. In this sense, equation (7.) is more convenient and effective to use in all cases. Forexample, whenz  Rrs isamatrix, wecaneasilyrewriteequation(7.) to n J (cid:) J g j i,k,   . (7.) z u z ik j ik j1 which will indeed be used in some of the derivations in Section 7.4.3. Key interpretation of the chain rule. We can view the formula above (equa tion(7.)or (7.))asawaytocompute J from J. Considerthefollowing z u abstractproblem. SupposeJ dependsonz viauasdefinedinequation(7.). However, suppose the function f is not given or the function f is complex, but we are given the value of J. Then, the formula in equation (7.) gives u us a way to compute J from J. z u J J chainrule,formula(7.)  . (7.) u onlyrequiresinfoaboutg()andz z Moreover, this formula only involves knowledge about g (more precisely gj). zi We will repeatedly use this fact in situations where g is a building blocks of a complex network f. Empirically, its often useful to modularized the mapping in (7.) or (7.) into a blackbox, and mathematically its also convenient to define a notation for it.6 We use B[g,z] to define the function that maps J to J, u z and write (cid:) (cid:) J J  B[g,z] . (7.) z u We call B[g,z] the backward function for the module g. Note that when z is fixed, B[g,z] is merely a linear map from Rn to Rm. Using equation (7.), we have m (cid:) g j (B[g,z](v))  v . (7.) i j z i j1 Or in vectorized notation, using (7.), we have g1  gn  B[g,z](v)    . . . z1 ...  . . . z1 v. (7.)   g1  gn zm zm 6e.g., the function is the .backward() method of the module in pytorch. and therefore B[g,z] can be viewed as a matrix. However, in reality, z will be changing and thus the backward mapping has to be recomputed for different zs while g is often fixed. Thus, empirically, the backward function B[g,z](v) is often viewed as a function which takes in z (the input to g) and v (a vector that is supposed to be the gradient of some variable J w.r.t to the output of g) as the inputs, and outputs a vector that is supposed to be the gradient of J w.r.t to z. 7.4.2 General strategy of backpropagation We discuss the general strategy of autodifferentiation in this section to build a highlevel understanding. Then, we will instantiate the approach to con crete neural networks. We take the viewpoint that neural networks are com plex compositions of small building blocks such as MM, , Conv2D, LN, etc., defined in Section 7.3. Note that the losses (e.g., meansquared loss, or the crossentropy loss) can also be abstractly viewed as additional modules. Thus, we can abstractly write the loss function J (on a single example (x,y)) as a composition of many modules:7 J  M (M (M (x))). (7.) k k1 1  For example, for a binary classification problem with a MLP h (x) (de  fined in equation (7.) and (7.)), the loss function has ber written in the form of equation (7.) with M  MM , M  , M  MM , 1 W[1],b[1] 2 3 W[2],b[2] ..., and M  MM and M  (cid:) . k1 W[r],b[r] k logistic We can see from this example that some modules involve parameters, and other modules might only involve a fixed set of operations. For generality, we assume that eachj M involves a set of parameters [i], though [i] could i possibly be an empty set when M is a fixed operation such as the nonlinear i activations. We will discuss more on the granularity of the modularization, but so far we assume all the modules M s are simple enough. i We introduce the intermediate variables for the computation in (7.). 7Technically, we should write J M (M (M (x)),y). However, y is treated as a k k1 1 constant for the purpose of computing the derivatives w.r.t to the parameters, and thus we can view it as part of M for the sake of simplicity of notations. k Let u[0]  x u[1]  M (u[0]) 1 u[2]  M (u[1]) 2 . . . J  u[k]  M (u[k1]). (F) k Backpropgation consists of two passes, the forward pass and backward pass. In the forward pass, the algorithm simply computes u[1],...,u[k] from i  1,...,k, sequentially using the definition in (F), and save all the in termediate variables u[i]s in the memory. In the backward pass, we first compute the derivatives w.r.t to the intermediate variables, that is, J ,..., J , sequentially in this backward u[k] u[1] order, and then compute the derivatives of the parameters J from J and [i] u[i] u[i1]. These two type of computations can be also interleaved with each other because J only depends on J and u[i1] but not any J with [i] u[i] u[k] k  i. We first see why J can be computed efficiently from J and u[i1] u[i1] u[i] by invoking the discussion in Section 7.4.1 on the chain rule. We in stantiate the discussion by setting u  u[i] and z  u[i1], and f(u)  M (M (M (u[i]))), and g()  M (). Note that f is very complex k k1 i1 i but we dont need any concrete information about f. Then, the conclusive equation (7.) corresponds to J J chainrule  . (7.) u[i] u[i1] only requires info about Mi() and u[i1] More precisely, we can write, following equation (7.) (cid:) (cid:) J J  B[M ,u[i1]] . (B1) u[i1] i u[i] Instantiating the chain rule with z  [i] and u  u[i], we also have (cid:) (cid:) J J  B[M ,[i]] . (B2) [i] i u[i] See Figure 7.5 for an illustration of the algorithm.  ...   ! ...    [ ,[!]]   [!]  !  []   [,[!]]    [!]  [!] ...   ... [ ,]   ! [,]    [ ,!] !   Forward pass Backward pass Figure 7.5: Backpropagation. Remark 7.4.3: [Computational efficiency and granularity of the modules] The main underlying purpose of treating a complex network as compositions ofsmallmodulesisthatsmallmodulestendtohaveefficientlyimplementable backward function. In fact, the backward functions of all the atomic modules such as addition, multiplication and ReLU can be computed as efficiently as the the evaluation of these modules (up to multiplicative constant factor). Using this fact, we can prove Theorem 7.4.1 by viewing neural networks as compositions of many atomic operations, and invoking the backpropagation discussed above. However, in practice, its oftentimes more convenient to modularize the networks using modules on the level of matrix multiplication, layernorm, etc. As we will see, naive implementation of these operations backward functions also have the same runtime as the evaluation of these functions. 7.4.3 Backward functions for basic modules Using the general strategy in Section 7.4.2, it suffices to compute the back ward function for all modules M s used in the networks. We compute the i backwardfunctionforthebasicmoduleMM, activations, andlossfunctions in this section. Backward function for MM. Suppose MM (z)  Wzb is a matrix multi W,b plicationmodulewherez  Rm andW  Rnm. Then, usingequation(7.), we have for v  Rn (Wzb)1  (Wzb)n  B[MM,z](v)    . . . z1 ...  . . . z1 v. (7.)   (Wzb)1  (Wzb)n zm zm Using the fact that i  [m],j  [n],(Wzb)j  bj(cid:)m k1 W jk z k  W , we zi zi ji have B[MM,z](v)  W(cid:)v  Rm. (7.) In the derivation above, we have treated MM as a function of z. If we treat MM as a function of W and b, then we can also compute the backward function for the parameter variables W and b. Its less convenient to use equation (7.) because the variable W is a matrix and the matrix in (7.) will be a 4th order tensor that is challenging for us to mathematically write down. We use (7.) instead: (cid:) m (Wz b) (cid:) m  (cid:)m W z (B[MM,W](v))  k v  s1 ks s v  v z . ij k k i j W W ij ij k1 k1 (7.) In vectorized notation, we have B[MM,W](v)  vz(cid:)  Rnm. (7.) Using equation (7.) for the variable b, we have, (Wzb)1  (Wzb)n  B[MM,b](v)    . . . b1 ...  . . . b1 v  v. (7.)   (Wzb)1  (Wzb)n bn bn Here we used that (Wzb)j  0 if i (cid:) j and (Wzb)j  1 if i  j. bi bi The computational efficiency for computing the backward function is O(mn), the same as evaluating the result of matrix multiplication up to constant factor. Backward function for the activations. Suppose M(z)  (z) where  is an elementwise activation function and z  Rm. Then, using equation (7.), we have (z1)  (zm) B[,z](v)    . . . z1 ...  . . . z1 v (7.)   (z1)  (zm) zm zm  diag((cid:)(z ), ,(cid:)(z ))v (7.) 1 m  (cid:)(z)(cid:)v  Rm. (7.) Here, we used the fact that (zj)  0 when j (cid:) i, diag( ,..., ) denotes zi 1 m the diagonal matrix with  ,..., on the diagonal, and (cid:) denotes the 1 m elementwise product of two vectors with the same dimension, and (cid:)() is the elementwise application of the derivative of the activation function . Regarding computation efficiency, we note that at the first sight, equa tion (7.) appears to indicate the backward function takes O(m2) time, but equation (7.) shows that its implementable in O(m) time (which is the same as the time for evaluating of the function.) We are not supposed to be surprised by that the possibility of simplifying equation (7.) to (7.)if we use smaller modules, that is, treating the vectortovector nonlinear ac tivation as m scalartoscalar nonlinear activation, then its more obvious that the backward pass should have similar time to the forward pass. Backward function for loss functions. When a module M takes in a vector z and outputs a scalar, by equation (7.), the backward function takes in a scalar v and outputs a vector with entries (B[M,z](v))  Mv. Therefore, i zi in vectorized notation, B[M,z](v)  M v. z Recall that squared loss (cid:) (z,y)  1(z  y)2. Thus, B[(cid:) ,z](v)  MSE 2 MSE 1(zy)2 2 v  (z y)v. z For logistics loss, by equation (2.6), we have (cid:) (t,y) logistic B[(cid:) ,t](v)  v  (1(1exp(t))y)v. (7.) logistic t For crossentropy loss, by equation (2.), we have (cid:) (t,y) ce B[(cid:) ,t](v)  v  (e )v, (7.) ce y t where   softmax(t). 7.4.4 Backpropagation for MLPs Given the backward functions for every module needed in evaluating the loss of an MLP, we follow the strategy in Section 7.4.2 to compute the gradient of the loss w.r.t to the hidden activations and the parameters. We consider the an rlayer MLP with a logistic loss. The loss function can be computed via a sequence of operations (that is, the forward pass), z[1]  MM (x), W[1],b[1] a[1]  (z[1]) z[2]  MM (a[1]) W[2],b[2] a[2]  (z[2]) . . . z[r]  MM (a[r1]) W[r],b[r] J  (cid:) (z[r],y). (7.) logistic We apply the backward function sequentially in a backward order. First, we have that (cid:) (cid:) J J  B[(cid:) ,z[r]]  B[(cid:) ,z[r]](1). (7.) z[r] logistic J logistic Then, we iteratively compute J and J s by repeatedly invoking the chain a[i] z[i] rule (equation (7.)), (cid:) (cid:) J J  B[MM,a[r1]] a[r1] z[r] (cid:) (cid:) J J  B[,z[r1]] z[r1] a[r1] . . . (cid:) (cid:) J J  B[,z[1]] . (7.) z[1] a[1] Numerically, we compute these quantities by repeatedly invoking equa tions (7.) and (7.) with different choices of variables. We note that the intermediate values of a[i] and z[i] are used in the back propagation (equation (7.)), and therefore these values need to be stored in the memory after the forward pass. Next, we compute the gradient of the parameters by invoking equa tions (7.) and (7.), (cid:) (cid:) J J  B[MM,W[r]] W[r] z[r] (cid:) (cid:) J J  B[MM,b[r]] b[r] z[r] . . . (cid:) (cid:) J J  B[MM,W[1]] W[1] z[1] (cid:) (cid:) J J  B[MM,b[1]] . (7.) b[1] z[1] We also note that the block of computations in equations (7.) can be interleaved with the block of computation in equations (7.) because the J and J can be computed as soon as J is computed. W[i] b[i] z[i] Putting all of these together, and explicitly invoking the equa tions(7.),(7.)and(7.),wehavethefollowingalgorithm(Algorithm3). Algorithm 3 Backpropagation for multilayer neural networks. 1: Forward pass. Compute and store the values of a[k]s, z[k]s, and J using the equations (7.). 2: Backward pass. Compute the gradient of loss J with respect to z[r]: J (cid:0) (cid:1)  B[(cid:) ,z[r]](1)  1(1exp(z[r]))y . (7.) z[r] logistic 3: for k  r1 to 0 do 4: Compute the gradient with respect to parameters W[k1] and b[k1]. (cid:) (cid:) J J  B[MM,W[k1]] W[k1] z[k1] J  a[k](cid:) . (7.) z[k1] (cid:) (cid:) J J  B[MM,b[k1]] b[k1] z[k1] J  . (7.) z[k1] 5: When k  1, compute the gradient with respect to z[k] and a[k]. (cid:) (cid:) J J  B[,a[k]] a[k] z[k1] J  W[k1](cid:) . (7.) z[k1] (cid:) (cid:) J J  B[,z[k]] z[k] a[k] J  (cid:)(z[k])(cid:) . (7.) a[k] 7.5 Vectorization over training examples As we discussed in Section 7.1, in the implementation of neural networks, we will leverage the parallelism across the multiple examples. This means that we will need to write the forward pass (the evaluation of the outputs) of the neural network and the backward pass (backpropagation) for multiple training examples in matrix notation. The basic idea. The basic idea is simple. Suppose you have a training set with three examples x(1),x(2),x(3). The firstlayer activations for each example are as follows: z[1](1)  W[1]x(1) b[1] z[1](2)  W[1]x(2) b[1] z[1](3)  W[1]x(3) b[1] Note the difference between square brackets [], which refer to the layer num ber, and parenthesis (), which refer to the training example number. In tuitively, one would implement this using a for loop. It turns out, we can vectorize these operations as well. First, define:      X   x(1) x(2) x(3)   Rd3 (7.)    Note that we are stacking training examples in columns and not rows. We can then combine this into a single unified formulation:      Z[1]   z[1](1) z[1](2) z[1](3)   W[1]X b[1] (7.)    You may notice that we are attempting to add b[1]  R41 to W[1]X  R43. Strictly following the rules of linear algebra, this is not allowed. In practice however, this addition is performed using broadcasting. We create an intermediate  b[1]  R43:       b[1]   b[1] b[1] b[1]  (7.)    We can then perform the computation: Z[1]  W[1]X   b[1]. Often times, it is not necessary to explicitly construct  b[1]. By inspecting the dimensions in (7.), you can assume b[1]  R41 is correctly broadcast to W[1]X  R43. The matricization approach as above can easily generalize to multiple layers, with one subtlety though, as discussed below. ComplicationsSubtlety in the Implementation. All the deep learn ing packages or implementations put the data points in the rows of a data matrix. (If the data point itself is a matrix or tensor, then the data are con centrated along the zeroth dimension.) However, most of the deep learning papers use a similar notation to these notes where the data points are treated as column vectors.8 There is a simple conversion to deal with the mismatch: in the implementation, all the columns become row vectors, row vectors be come column vectors, all the matrices are transposed, and the orders of the matrix multiplications are flipped. In the example above, using the row ma jor convention, the data matrix is X  R3d, the first layer weight matrix has dimensionality d  m (instead of m  d as in the two layer neural net section), and the bias vector b[1]  R1m. The computation for the hidden activation becomes Z[1]  XW[1] b[1]  R3m (7.) 8The instructor suspects that this is mostly because in mathematics we naturally mul tiply a matrix to a vector on the left hand side. Part III Generalization and regularization Chapter 8 Generalization This chapter discusses tools to analyze and understand the generaliza tion of machine learning models, i.e, their performances on unseen test examples. Recall that for supervised learning problems, given a train ing dataset (x(i),y(i))n , we typically learn a model h by minimizing a i1  losscost function J(), which encourages h to fit the data. E.g., when  the loss function is the least square loss (aka mean squared error), we have J()  1 (cid:)n (y(i)  h (x(i)))2. This loss function for training purposes is n i1  oftentimes referred to as the training losserrorcost. However, minimizing the training loss is not our ultimate goalit is merely our approach towards the goal of learning a predictive model. The most important evaluation metric of a model is the loss on unseen test exam ples, which is oftentimes referred to as the test error. Formally, we sample a test example (x,y) from the socalled test distribution D, and measure the models error on it, by, e.g., the mean squared error, (h (x)y)2. The ex  pected losserror over the randomness of the test example is called the test losserror,1 L()  E [(y h (x))2] (8.1) (x,y)D  Note that the measurement of the error involves computing the expectation, andinpractice,itcanbeapproximatedbytheaverageerroronmanysampled test examples, which are referred to as the test dataset. Note that the key difference here between training and test datasets is that the test examples 1In theoretical and statistical literature, we oftentimes call the uniform distribution over the training set (x(i),y(i))n , denoted by D(cid:), an empirical distribution, and call i1 D the population distribution. Partly because of this, the training loss is also referred to as the empirical lossriskerror, and the test loss is also referred to as the population lossriskerror. are unseen, in the sense that the training procedure has not used the test examples. In classical statistical learning settings, the training examples are also drawn from the same distribution as the test distribution D, but still the test examples are unseen by the learning procedure whereas the training examples are seen.2 Because of this key difference between training and test datasets, even if they are both drawn from the same distribution D, the test error is not necessarily always close to the training error.3 As a result, successfully min imizing the training error may not always lead to a small test error. We typically say the model overfits the data if the model predicts accurately on the training dataset but doesnt generalize well to other test examples, that is, if the training error is small but the test error is large. We say the model underfits the data if the training error is relatively large4 (and in this case, typically the test error is also relatively large.) This chapter studies how the test error is influenced by the learning pro cedure, especially the choice of model parameterizations. We will decompose the test error into bias and variance terms and study how each of them is affected by the choice of model parameterizations and their tradeoffs. Using the biasvariance tradeoff, we will discuss when overfitting and underfitting will occur and be avoided. We will also discuss the double descent phe nomenon in Section 8.2 and some classical theoretical results in Section 8.3. 2These days, researchers have increasingly been more interested in the setting with domain shift, that is, the training distribution and test distribution are different. 3the difference between test error and training error is often referred to as the gener alization gap. The term generalization error in some literature means the test error, and in some other literature means the generalization gap. 4e.g., larger than the intrinsic noise level of the data in regression problems. 8.1 Biasvariance tradeoff 1.5 1.0 0.5 0.0 0.0 0.2 0.4 0.6 0.8 1.0 x y training dataset 1.5 training data ground truth h 1.0 0.5 0.0 0.0 0.2 0.4 0.6 0.8 1.0 x y test dataset test data ground truth h Figure 8.1: A running example of training and test dataset for this section. As an illustrating example, we consider the following training dataset and testdataset, whicharealsoshowninFigure8.1. Thetraininginputsx(i)sare randomly chosen and the outputs y(i) are generated by y(i)  h(cid:)(x(i))(i) where the function h(cid:)() is a quadratic function and is shown in Figure 8.1 as the solid line, and (i) is the a observation noise assumed to be generated from  N(0,2). A test example (x,y) also has the same inputoutput relationship y  h(cid:)(x) where   N(0,2). Its impossible to predict the noise , and therefore essentially our goal is to recover the function h(cid:)(). We will consider the test error of learning various types of models. When talking about linear regression, we discussed the problem of whether to fit a simple model such as the linear y     x, or a more complex 0 1 model such as the polynomial y    x x5. 0 1 5 We start with fitting a linear model, as shown in Figure 8.2. The best fitted linear model cannot predict y from x accurately even on the training dataset, let alone on the test dataset. This is because the true relationship between y and x is not linearany linear model is far away from the true function h(cid:)(). As a result, the training error is large and this is a typical situation of underfitting. 1.5 1.0 0.5 0.0 0.0 0.2 0.4 0.6 0.8 1.0 x y 1.5 training data best fit linear model 1.0 0.5 0.0 0.0 0.2 0.4 0.6 0.8 1.0 x y test data best fit linear model Figure 8.2: The best fit linear model has large training and test errors. The issue cannot be mitigated with more training exampleseven with a very large amount of, or even infinite training examples, the best fitted linear model is still inaccurate and fails to capture the structure of the data (Figure 8.3). Even if the noise is not present in the training data, the issue still occurs (Figure 8.4). Therefore, the fundamental bottleneck here is the linear model familys inability to capture the structure in the datalinear models cannot represent the true quadratic function h(cid:), but not the lack of the data. Informally, we define the bias of a model to be the test error even if we were to fit it to a very (say, infinitely) large training dataset. Thus, in this case, the linear model suffers from large bias, and underfits (i.e., fails to capture structure exhibited by) the data. 1.5 1.0 0.5 0.0 0.0 0.2 0.4 0.6 0.8 1.0 x y fitting linear models on a large dataset 1.5 training data ground truth h best fit linear model 1.0 0.5 0.0 0.0 0.2 0.4 0.6 0.8 1.0 x Figure 8.3: The best fit linear model on a much larger dataset still has a large training error. y fitting linear models on a noiseless dataset training data ground truth h best fit linear model Figure 8.4: The best fit linear model on a noiseless dataset also has a large trainingtest error. Next, we fit a 5thdegree polynomial to the data. Figure 8.5 shows that it fails to learn a good model either. However, the failure pattern is different from the linear model case. Specifically, even though the learnt 5thdegree polynomial did a very good job predicting y(i)s from x(i)s for training ex amples, it does not work well on test examples (Figure 8.5). In other words, the model learnt from the training set does not generalize well to other test examplesthe test error is high. Contrary to the behavior of linear models, the bias of the 5th degree polynomials is smallif we were to fit a 5th de gree polynomial to an extremely large dataset, the resulting model would be close to a quadratic function and be accurate (Figure 8.6). This is because the family of 5th degree polynomials contains all the quadratic functions (setting       0 results in a quadratic function), and, therefore, 5 4 3 5th degree polynomials are in principle capable of capturing the structure of the data. 1.5 1.0 0.5 0.0 0.0 0.2 0.4 0.6 0.8 1.0 x y 1.5 training data best fit 5th degree model 1.0 0.5 0.0 0.0 0.2 0.4 0.6 0.8 1.0 x y test data ground truth h best fit 5th degree model Figure 8.5: Best fit 5th degree polynomial has zero training error, but still has a large test error and does not recover the the ground truth. This is a classic situation of overfitting. 1.5 1.0 0.5 0.0 0.0 0.2 0.4 0.6 0.8 1.0 x y fitting 5th degree model on large dataset training data best fit 5th degree model ground truth h Figure 8.6: The best fit 5th degree polynomial on a huge dataset nearly recovers the groundtruthsuggesting that the culprit in Figure 8.5 is the variance (or lack of data) but not bias. The failure of fitting 5th degree polynomials can be captured by another component of the test error, called variance of a model fitting procedure. Specifically, when fitting a 5th degree polynomial as in Figure 8.7, there is a large risk that were fitting patterns in the data that happened to be present in our small, finite training set, but that do not reflect the wider pattern of the relationship between x and y. These spurious patterns in the training set are (mostly) due to the observation noise (i), and fitting these spurious patters results in a model with large test error. In this case, we say the model has a large variance. 1.5 1.0 0.5 0.0 0.0 0.2 0.4 0.6 0.8 1.0 x y 1.5 training data best fit 5th degree model 1.0 0.5 0.0 0.0 0.2 0.4 0.6 0.8 1.0 x y 1.5 training data best fit 5th degree model 1.0 0.5 0.0 0.0 0.2 0.4 0.6 0.8 1.0 x y fitting 5th degree model on different datasets training data best fit 5th degree model Figure 8.7: The best fit 5th degree models on three different datasets gen erated from the same distribution behave quite differently, suggesting the existence of a large variance. The variance can be intuitively (and mathematically, as shown in Sec tion 8.1.1) characterized by the amount of variations across models learnt on multiple different training datasets (drawn from the same underlying dis tribution). The spurious patterns are specific to the randomness of the noise (and inputs) in a particular dataset, and thus are different across mul tiple training datasets. Therefore, overfitting to the spurious patterns of multiple datasets should result in very different models. Indeed, as shown in Figure 8.7, the models learned on the three different training datasets are quite different, overfitting to the spurious patterns of each datasets. Often, there is a tradeoff between bias and variance. If our model is too simple and has very few parameters, then it may have large bias (but small variance), and it typically may suffer from underfittng. If it is too complex and has very many parameters, then it may suffer from large variance (but have smaller bias), and thus overfitting. See Figure 8.8 for a typical tradeoff between bias and variance. Model Complexity rorrE Optimal Tradeoff Test Error ( Bias2Variance) Variance Bias2 Figure 8.8: An illustration of the typical biasvariance tradeoff. As we will see formally in Section 8.1.1, the test error can be decomposed as a summation of bias and variance. This means that the test error will have a convex curve as the model complexity increases, and in practice we should tune the model complexity to achieve the best tradeoff. For instance, in the example above, fitting a quadratic function does better than either of the extremes of a first or a 5th degree polynomial, as shown in Figure 8.9. 1.5 1.0 0.5 0.0 0.0 0.2 0.4 0.6 0.8 1.0 x y 1.5 training data best fit quadratic model 1.0 0.5 0.0 0.0 0.2 0.4 0.6 0.8 1.0 x y test data best fit quadratic model ground truth h Figure 8.9: Best fit quadratic model has small training and test error because quadratic model achieves a better tradeoff. Interestingly, the biasvariance tradeoff curves or the test error curves do not universally follow the shape in Figure 8.8, at least not universally whenthemodelcomplexityis simplymeasuredbythenumberofparameters. (We will discuss the socalled double descent phenomenon in Section 8.2.) Nevertheless, the principle of biasvariance tradeoff is perhaps still the first resort when analyzing and predicting the behavior of test errors. 8.1.1 A mathematical decomposition (for regression) To formally state the biasvariance tradeoff for regression problems, we con sider the following setup (which is an extension of the beginning paragraph of Section 8.1).  Draw a training dataset S  x(i),y(i)n such that y(i)  h(cid:)(x(i))(i) i1 where (i)  N(0,2).  Train a model on the dataset S, denoted by h  . S  Take a test example (x,y) such that y  h(cid:)(x) where   N(0,2), and measure the expected test error (averaged over the random draw of the training set S and the randomness of ) MSE(x)  E [(y h (x))2] (8.2) S, S We will decompose the MSE into a bias and variance term. We start by stating a following simple mathematical tool that will be used twice below. Claim 8.1.1: Suppose A and B are two independent real random variables and E[A]  0. Then, E[(AB)2]  E[A2]E[B2]. As a corollary, because a random variable A is independent with a con stant c, when E[A]  0, we have E[(Ac)2]  E[A2]c2. The proof of the claim follows from expanding the square: E[(AB)2]  E[A2]E[B2]2E[AB]  E[A2]E[B2]. Here we used the independence to show that E[AB]  E[A]E[B]  0. Using Claim 8.1.1 with A   and B  h(cid:)(x)h  (x), we have S MSE(x)  E[(y h (x))2]  E[( (h(cid:)(x)h (x)))2] (8.3) S S  E[2]E[(h(cid:)(x)h (x))2] (by Claim 8.1.1) S  2 E[(h(cid:)(x)h (x))2] (8.4) S Then, letsdefineh (x)  E [h (x)]astheaveragemodelthemodel avg S S obtained by drawing an infinite number of datasets, training on them, and averaging their predictions on x. Note that h is a hypothetical model for avg analytical purposes that can not be obtained in reality (because we dont 5Forsimplicity,thetestinputxisconsideredtobefixedhere,butthesameconceptual message holds when we average over the choice of xs. 6The subscript under the expectation symbol is to emphasize the variables that are considered as random by the expectation operation. have infinite number of datasets). It turns out that for many cases, h avg is (approximately) equal to the the model obtained by training on a single datasetwithinfinitesamples. Thus, wecanalsointuitivelyinterpreth this avg way, which is consistent with our intuitive definition of bias in the previous subsection. WecanfurtherdecomposeMSE(x)bylettingc  h(cid:)(x)h (x)(whichis avg a constant that does not depend on the choice of S!) and A  h (x)h (x) avg S in the corollary part of Claim 8.1.1: MSE(x)  2 E[(h(cid:)(x)h (x))2] (8.5) S  2 (h(cid:)(x)h (x))2 E[(h h (x))2] (8.6) avg avg S  2 (h(cid:)(x)h (x))2var(h (x)) (8.7) avg S (cid:)(cid:)(cid:)(cid:) (cid:) (cid:)(cid:) (cid:) (cid:) (cid:)(cid:) (cid:) unavoidable (cid:)bias2 (cid:)variance Wecallthesecondtermthebias(square)andthethirdtermthevariance. As discussed before, the bias captures the part of the error that are introduced due to the lack of expressivity of the model. Recall that h can be thought avg ofasthebestpossiblemodellearnedevenwithinfinitedata. Thus, thebiasis not due to the lack of data, but is rather caused by that the family of models fundamentally cannot approximate the h(cid:). For example, in the illustrating example in Figure 8.2, because any linear model cannot approximate the true quadratic function h(cid:), neither can h , and thus the bias term has to avg be large. The variance term captures how the random nature of the finite dataset introduces errors in the learned model. It measures the sensitivity of the learned model to the randomness in the dataset. It often decreases as the size of the dataset increases. There is nothing we can do about the first term 2 as we can not predict the noise  by definition. Finally, we note that the biasvariance decomposition for classification is much less clear than for regression problems. There have been several proposals, but there is as yet no agreement on what is the right andor the most useful formalism. 8.2 The double descent phenomenon Modelwise double descent. Recent works have demonstrated that the test error can present a double descent phenomenon in a range of machine learning models including linear models and deep neural networks.7 The conventional wisdom, as discussed in Section 8.1, is that as we increase the model complexity, the test error first decreases and then increases, as illus trated in Figure 8.8. However, in many cases, we empirically observe that the test error can have a second descentit first decreases, then increases to a peak around when the model size is large enough to fit all the training data very well, and then decreases again in the socalled overparameterized regime, where the number of parameters is larger than the number of data points. See Figure 8. for an illustration of the typical curves of test errors against model complexity (measured by the number of parameters). To some extent,theoverparameterizedregimewiththeseconddescentisconsideredas new to the machine learning communitypartly because lightlyregularized, overparameterized models are only extensively used in the deep learning era. A practical implication of the phenomenon is that one should not hold back from scaling into and experimenting with overparametrized models because the test error may well decrease again to a level even smaller than the previ ous lowest point. Actually, in many cases, larger overparameterized models always lead to a better test performance (meaning there wont be a second ascent after the second descent).  parameters rorretset classical regime: modern regime: biasvariance tradeoff overparameterization typicallywhen  parameters is sufficient to fit the data Figure 8.: A typical modelwise double descent phenomenon. As the num ber of parameters increases, the test error first decreases when the number of parameters is smaller than the training data. Then in the overparameterized regime, the test error decreases again. 7The discovery of the phenomenon perhaps dates back to Opper [, ], and has been recently popularized by Belkin et al. [], Hastie et al. [], etc. Samplewise double descent. A priori, we would expect that more training examples always lead to smaller test errorsmore samples give strictly more information for the algorithm to learn from. However, recent work [Nakkiran, ] observes that the test error is not monotonically de creasing as we increase the sample size. Instead, as shown in Figure 8., the test error decreases, and then increases and peaks around when the number of examples (denoted by n) is similar to the number of parameters (denoted by d), and then decreases again. We refer to this as the samplewise dou ble descent phenomenon. To some extent, samplewise double descent and modelwise double descent are essentially describing similar phenomenathe test error is peaked when n  d. Explanation and mitigation strategy. The samplewise double descent, or, in particular, the peak of test error at n  d, suggests that the existing trainingalgorithmsevaluatedintheseexperimentsarefarfromoptimalwhen n  d. We will be better off by tossing away some examples and run the algorithms with a smaller sample size to steer clear of the peak. In other words, in principle, there are other algorithms that can achieve smaller test error when n  d, but the algorithms evaluated in these experiments fail to do so. The suboptimality of the learning procedure appears to be the culprit of the peak in both samplewise and modelwise double descent. Indeed, with an optimallytuned regularization (which will be discussed more in Section 9), the test error in the n  d regime can be dramatically improved, and the modelwise and samplewise double descent are both mit igated. See Figure 8.. The intuition above only explains the peak in the modelwise and sample wise double descent, but does not explain the second descent in the model wise double descentwhy overparameterized models are able to generalize so well. The theoretical understanding of overparameterized models is an ac tive research area with many recent advances. A typical explanation is that the commonlyused optimizers such as gradient descent provide an implicit regularization effect (which will be discussed in more detail in Section 9.2). In other words, even in the overparameterized regime and with an unregular ized loss function, the model is still implicitly regularized, and thus exhibits a better test performance than an arbitrary solution that fits the data. For example, for linear models, when n (cid:) d, the gradient descent optimizer with zero initialization finds the minimum norm solution that fits the data (in stead of an arbitrary solution that fits the data), and the minimum norm reg ularizer turns out to be a sufficiently good for the overparameterized regime (but its not a good regularizer when n  d, resulting in the peak of test error). 2. 1. 1. 1. 1. 0. 0. 0. 0. 0 Num Samples rorrE tseT Test Error vs.  Samples Test Error Figure 8.: Left: The samplewise double descent phenomenon for linear models. Right: Thesamplewisedoubledescentwithdifferentregularization strength for linear models. Using the optimal regularization parameter  (optimally tuned for each n, shown in green solid curve) mitigates double descent. Setup: The data distribution of (x,y) is x  N(0,I ) and y  d x(cid:) N(0,2) where d  ,  0.5 and (cid:)(cid:)  1.8 2 Finally, we also remark that the double descent phenomenon has been mostly observed when the model complexity is measured by the number of parameters. It is unclear if and when the number of parameters is the best complexity measure of a model. For example, in many situations, the norm of the models is used as a complexity measure. As shown in Figure 8. right, for a particular linear case, if we plot the test error against the norm of the learnt model, the double descent phenomenon no longer occurs. This is partly because the norm of the learned model is also peaked around n  d (See Figure 8. (middle) or Belkin et al. [], Mei and Montanari [], and discussions in Section .8 of James et al. []). For deep neural networks, the correct complexity measure is even more elusive. The study of double descent phenomenon is an active research topic. 8ThefigureisreproducedfromFigure1ofNakkiranetal.[]. Similarphenomenon are also observed in Hastie et al. [], Mei and Montanari [] 1.0 0.8 0.6 0.4 0.2 0.0 0  parameters rorre tset test error vs.  params 0 0  parameters mron norm vs.  params 1.0 0.8 0.6 0.4 0.2 0.0 0 norm rorre tset dn sretemarap  test error vs. norm 0 Figure8.: Left: Thedoubledescentphenomenon, wherethenumberofpa rameters is used as the model complexity. Middle: The norm of the learned model is peaked around n  d. Right: The test error against the norm of the learnt model. The color bar indicate the number of parameters and the arrows indicates the direction of increasing model size. Their relationship are closer to the convention wisdom than to a double descent. Setup: We consider a linear regression with a fixed dataset of size n  . The input x is a random ReLU feature on FashionMNIST, and output y  R10 is the onehot label. This is the same setting as in Section 5.2 of Nakkiran et al. []. 8.3 Sample complexity bounds (optional readings) 8.3.1 Preliminaries In this set of notes, we begin our foray into learning theory. Apart from being interesting and enlightening in its own right, this discussion will also help us hone our intuitions and derive rules of thumb about how to best apply learning algorithms in different settings. We will also seek to answer a few questions: First, can we make formal the biasvariance tradeoff that was just discussed? This will also eventually lead us to talk about model selection methods, which can, for instance, automatically decide what order polynomial to fit to a training set. Second, in machine learning its really generalizationerrorthatwecareabout, butmostlearningalgorithmsfittheir models to the training set. Why should doing well on the training set tell us anything about generalization error? Specifically, can we relate error on the training set to generalization error? Third and finally, are there conditions under which we can actually prove that learning algorithms will work well? We start with two simple but very useful lemmas. Lemma. (The union bound). Let A ,A ,...,A be k different events (that 1 2 k may not be independent). Then P(A A )  P(A )...P(A ). 1 k 1 k In probability theory, the union bound is usually stated as an axiom (and thus we wont try to prove it), but it also makes intuitive sense: The probability of any one of k events happening is at most the sum of the probabilities of the k different events. Lemma. (Hoeffding inequality) Let Z ,...,Z be n independent and iden 1 n tically distributed (iid) random variables drawn from a Bernoulli() distri bution. I.e., P(Z  1)  , and P(Z  0)  1. Let    (1n) (cid:)n Z i i i1 i be the mean of these random variables, and let any   0 be fixed. Then P(    )  2exp(22n) Thislemma(whichinlearningtheoryisalsocalledtheChernoff bound)  says that if we take the average of n Bernoulli() random variablesto be our estimate of , then the probability of our being far from the true value is small, so long as n is large. Another way of saying this is that if you have a biased coin whose chance of landing on heads is , then if you toss it n times and calculate the fraction of times that it came up heads, that will be a good estimate of  with high probability (if n is large). Using just these two lemmas, we will be able to prove some of the deepest and most important results in learning theory. To simplify our exposition, lets restrict our attention to binary classifica tion in which the labels are y  0,1. Everything well say here generalizes to other problems, including regression and multiclass classification. WeassumewearegivenatrainingsetS  (x(i),y(i));i  1,...,nofsize n, wherethetrainingexamples(x(i),y(i))aredrawniidfromsomeprobability distribution D. For a hypothesis h, we define the training error (also called the empirical risk or empirical error in learning theory) to be n 1 (cid:) (h)  1h(x(i)) (cid:) y(i). n i1 This is just the fraction of training examples that h misclassifies. When we want to make explicit the dependence of (h) on the training set S, we may also write this a  (h). We also define the generalization error to be S (h)  P (h(x) (cid:) y). (x,y)D I.e. this is the probability that, if we now draw a new example (x,y) from the distribution D, h will misclassify it. Note that we have assumed that the training data was drawn from the same distribution D with which were going to evaluate our hypotheses (in the definition of generalization error). This is sometimes also referred to as one of the PAC assumptions.9 Consider the setting of linear classification, and let h (x)  1Tx  0.  Whats a reasonable way of fitting the parameters ? One approach is to try to minimize the training error, and pick    argmin(h ).   Wecallthisprocessempirical risk minimization(ERM),andtheresulting  hypothesis output by the learning algorithm is h  h . We think of ERM  as the most basic learning algorithm, and it will be this algorithm that we 9PAC stands for probably approximately correct, which is a framework and set of assumptions under which numerous results on learning theory were proved. Of these, the assumption of training and testing on the same distribution, and the assumption of the independently drawn training examples, were the most important. focus on in these notes. (Algorithms such as logistic regression can also be viewed as approximations to empirical risk minimization.) In our study of learning theory, it will be useful to abstract away from the specific parameterization of hypotheses and from issues such as whether were using a linear classifier. We define the hypothesis class H used by a learning algorithm to be the set of all classifiers considered by it. For linear classification, H  h : h (x)  1Tx  0,  Rd1 is thus the set of   all classifiers over X (the domain of the inputs) where the decision boundary is linear. More broadly, if we were studying, say, neural networks, then we could let H be the set of all classifiers representable by some neural network architecture. Empiricalriskminimizationcannowbethoughtofasaminimizationover theclassoffunctionsH, inwhichthelearningalgorithmpicksthehypothesis:  h  argmin(h) hH 8.3.2 The case of finite H Lets start by considering a learning problem in which we have a finite hy pothesis class H  h ,...,h  consisting of k hypotheses. Thus, H is just a 1 k set of k functions mapping from X to 0,1, and empirical risk minimization  selects h to be whichever of these k functions has the smallest training error.  We would like to give guarantees on the generalization error of h. Our strategy for doing so will be in two parts: First, we will show that (h) is a reliable estimate of (h) for all h. Second, we will show that this implies an  upperbound on the generalization error of h. Take any one, fixed, h  H. Consider a Bernoulli random variable Z i whose distribution is defined as follows. Were going to sample (x,y)  D. Then, we set Z  1h (x) (cid:) y. I.e., were going to draw one example, i and let Z indicate whether h misclassifies it. Similarly, we also define Z  i j 1h (x(j)) (cid:) y(j). Since our training set was drawn iid from D, Z and the i Z s have the same distribution. j We see that the misclassification probability on a randomly drawn examplethat is, (h)is exactly the expected value of Z (and Z ). More j over, the training error can be written n 1 (cid:) (h )  Z . i j n j1 Thus, (h ) is exactly the mean of the n random variables Z that are drawn i j iid from a Bernoulli distribution with mean (h ). Hence, we can apply the i Hoeffding inequality, and obtain P((h )(h )  )  2exp(22n). i i This shows that, for our particular h , training error will be close to i generalization error with high probability, assuming n is large. But we dont justwanttoguaranteethat(h )willbe closeto(h )(withhighprobability) i i for just only one particular h . We want to prove that this will be true i simultaneously for all h  H. To do so, let A denote the event that (h ) i i (h )  . Weve already shown that, for any particular A , it holds true i i that P(A )  2exp(22n). Thus, using the union bound, we have that i P(h  H.(h )(h )  )  P(A A ) i i 1 k k (cid:)  P(A ) i i1 k (cid:)  2exp(22n) i1  2kexp(22n) If we subtract both sides from 1, we find that P(h  H.(h )(h )  )  P(h  H.(h )(h )  ) i i i i  12kexp(22n) (The  symbol means not.) So, with probability at least 1  2kexp(22n), we have that (h) will be within  of (h) for all h  H. This is called a uniform convergence result, because this is a bound that holds simultaneously for all (as opposed to just one) h  H. In the discussion above, what we did was, for particular values of n and , give a bound on the probability that for some h  H, (h)(h)  . There are three quantities of interest here: n, , and the probability of error; we can bound either one in terms of the other two. For instance, we can ask the following question: Given  and some   0, how large must n be before we can guarantee that with probability at least 1  , training error will be within  of generalization error? By setting   2kexp(22n) and solving for n, [you should convince yourself this is the right thing to do!], we find that if 1 2k n  log , 22  then with probability at least 1  , we have that (h)  (h)   for all h  H. (Equivalently, this shows that the probability that (h)(h)   for some h  H is at most .) This bound tells us how many training examples we need in order make a guarantee. The training set size n that a certain method or algorithm requires in order to achieve a certain level of performance is also called the algorithms sample complexity. The key property of the bound above is that the number of training examples needed to make this guarantee is only logarithmic in k, the number of hypotheses in H. This will be important later. Similarly, we can also hold n and  fixed and solve for  in the previous equation, and show [again, convince yourself that this is right!] that with probability 1, we have that for all h  H, (cid:) 1 2k (h)(h)  log . 2n  Now,letsassumethatuniformconvergenceholds,i.e.,that(h)(h)   for all h  H. What can we prove about the generalization of our learning  algorithm that picked h  argmin (h)? hH Defineh  argmin (h)tobethebestpossiblehypothesisinH. Note hH that h is the best that we could possibly do given that we are using H, so it makes sense to compare our performance to that of h. We have:   (h)  (h)  (h)  (h)2   Thefirstlineusedthefactthat(h)(h)   (byouruniformconvergence  assumption). The second used the fact that h was chosen to minimize (h), and hence (h  )  (h) for all h, and in particular (h  )  (h). The third line used the uniform convergence assumption again, to show that (h)  (h)  . So, what weve shown is the following: If uniform convergence  occurs, then the generalization error of h is at most 2 worse than the best possible hypothesis in H! Lets put all this together into a theorem. Theorem. Let H  k, and let any n, be fixed. Then with probability at least 1, we have that (cid:) (cid:) (cid:) 1 2k  (h)  min(h) 2 log . hH 2n   This is proved by letting  equal the  term, using our previous argu ment that uniform convergence occurs with probability at least 1  , and then noting that uniform convergence implies (h) is at most 2 higher than (h)  min (h) (as we showed previously). hH This also quantifies what we were saying previously saying about the biasvariance tradeoff in model selection. Specifically, suppose we have some hypothesis class H, and are considering switching to some much larger hy pothesis class H(cid:)  H. If we switch to H(cid:), then the first term min (h) h can only decrease (since wed then be taking a min over a larger set of func tions). Hence, by learning using a larger hypothesis class, our bias can  only decrease. However, if k increases, then the second 2  term would also increase. This increase corresponds to our variance increasing when we use a larger hypothesis class. By holding  and  fixed and solving for n like we did before, we can also obtain the following sample complexity bound:  Corollary. Let H  k, and let any , be fixed. Then for (h)  min (h)2 to hold with probability at least 1, it suffices that hH 1 2k n  log 22  (cid:) (cid:) 1 k  O log , 2  8.3.3 The case of infinite H We have proved some useful theorems for the case of finite hypothesis classes. But many hypothesis classes, including any parameterized by real numbers (as in linear classification) actually contain an infinite number of functions. Can we prove similar results for this setting? Lets start by going through something that is not the right argument. Better and more general arguments exist, but this will be useful for honing our intuitions about the domain. Suppose we have an H that is parameterized by d real numbers. Since we are using a computer to represent real numbers, and IEEE doubleprecision floating point (doubles in C) uses bits to represent a floating point num ber, this means that our learning algorithm, assuming were using double precision floating point, is parameterized by 64d bits. Thus, our hypothesis class really consists of at most k  264d different hypotheses. From the Corol lary at the end of the previous section, we therefore find that, to guarantee (h  )  (h)2, with to hold with probability at least 1, it suffices that (cid:) (cid:) (cid:) (cid:) n  O 1 log 264d  O d log 1  O (d). (The , subscripts indicate 2  2  , that the last bigO is hiding constants that may depend on  and .) Thus, the number of training examples needed is at most linear in the parameters of the model. The fact that we relied on bit floating point makes this argument not entirely satisfying, but the conclusion is nonetheless roughly correct: If what we try to do is minimize training error, then in order to learn well using a hypothesis class that has d parameters, generally were going to need on the order of a linear number of training examples in d. (At this point, its worth noting that these results were proved for an al gorithm that uses empirical risk minimization. Thus, while the linear depen dence of sample complexity on d does generally hold for most discriminative learning algorithms that try to minimize training error or some approxima tion to training error, these conclusions do not always apply as readily to discriminative learning algorithms. Giving good theoretical guarantees on many nonERM learning algorithms is still an area of active research.) The other part of our previous argument thats slightly unsatisfying is that it relies on the parameterization of H. Intuitively, this doesnt seem like it should matter: We had written the class of linear classifiers as h (x)   1  x  x  0, with n1 parameters  ,..., . But it could 0 1 1 d d 0 d also be written h (x)  1(u2  v2)  (u2  v2)x  (u2  v2)x  0 u,v 0 0 1 1 1 d d d with 2d2 parameters u ,v . Yet, both of these are just defining the same i i H: The set of linear classifiers in d dimensions. To derive a more satisfying argument, lets define a few more things. Given a set S  x(i),...,x(D) (no relation to the training set) of points x(i)  X, we say that H shatters S if H can realize any labeling on S. I.e., if for any set of labels y(1),...,y(D), there exists some h  H so that h(x(i))  y(i) for all i  1,...D. Given a hypothesis class H, we then define its VapnikChervonenkis dimension, written VC(H), to be the size of the largest set that is shattered by H. (If H can shatter arbitrarily large sets, then VC(H)  .) For instance, consider the following set of three points: (cid:0)(cid:1) (cid:0)(cid:1) x 2 (cid:0)(cid:1) x 1 Can the set H of linear classifiers in two dimensions (h(x)  1  x  0 1 1  x  0) can shatter the set above? The answer is yes. Specifically, we 2 2 see that, for any of the eight possible labelings of these points, we can find a linear classifier that obtains zero training error on them: x x x x 2 2 2 2 x x x x 1 1 1 1 x x x x 2 2 2 2 x x x x 1 1 1 1 Moreover, it is possible to show that there is no set of 4 points that this hypothesis class can shatter. Thus, the largest set that H can shatter is of size 3, and hence VC(H)  3. Note that the VC dimension of H here is 3 even though there may be sets of size 3 that it cannot shatter. For instance, if we had a set of three points lying in a straight line (left figure), then there is no way to find a linear separator for the labeling of the three points shown below (right figure): (cid:0)(cid:1) x x (cid:0)(cid:1) 2 2 (cid:0)(cid:1) x x 1 1 In order words, under the definition of the VC dimension, in order to prove that VC(H) is at least D, we need to show only that theres at least one set of size D that H can shatter. The following theorem, due to Vapnik, can then be shown. (This is, many would argue, the most important theorem in all of learning theory.) Theorem. Let H be given, and let D  VC(H). Then with probability at least 1, we have that for all h  H, (cid:)(cid:) (cid:) D n 1 1 (h)(h)  O log  log . n D n  Thus, with probability at least 1, we also have that: (cid:)(cid:) (cid:) D n 1 1 (h  )  (h)O log  log . n D n  Inotherwords,ifahypothesisclasshasfiniteVCdimension,thenuniform convergence occurs as n becomes large. As before, this allows us to give a bound on (h) in terms of (h). We also have the following corollary:  Corollary. For (h)(h)   to hold for all h  H (and hence (h)  (h)2) with probability at least 1, it suffices that n  O (D). , In other words, the number of training examples needed to learn well using H is linear in the VC dimension of H. It turns out that, for most hypothesis classes, the VC dimension (assuming a reasonable parameter ization) is also roughly linear in the number of parameters. Putting these together, we conclude that for a given hypothesis class H (and for an algo rithm that tries to minimize training error), the number of training examples needed to achieve generalization error close to that of the optimal classifier is usually roughly linear in the number of parameters of H. Chapter 9 Regularization and model selection 9.1 Regularization Recall that as discussed in Section 8.1, overftting is typically a result of using too complex models, and we need to choose a proper model complexity to achieve the optimal biasvariance tradeoff. When the model complexity is measured by the number of parameters, we can vary the size of the model (e.g., the width of a neural net). However, the correct, informative complex ity measure of the models can be a function of the parameters (e.g., (cid:) norm 2 of the parameters), which may not necessarily depend on the number of pa rameters. In such cases, we will use regularization, an important technique in machine learning, control the model complexity and prevent overfitting. Regularization typically involves adding an additional term, called a reg ularizer and denoted by R() here, to the training losscost function: J ()  J()R() (9.1)  Here J is often called the regularized loss, and   0 is called the regular  ization parameter. The regularizer R() is a nonnegative function (in almost all cases). In classical methods, R() is purely a function of the parameter , but some modern approach allows R() to depend on the training dataset.1 The regularizer R() is typically chosen to be some measure of the com plexity of the model . Thus, when using the regularized loss, we aim to find a model that both fit the data (a small loss J()) and have a small 1Here our notations generally omit the dependency on the training dataset for simplicitywewriteJ()eventhoughitobviouslyneedstodependonthetrainingdataset. model complexity (a small R()). The balance between the two objectives is controlled by the regularization parameter . When   0, the regularized loss is equivalent to the original loss. When  is a sufficiently small positive number, minimizing the regularized loss is effectively minimizing the original losswiththeregularizerasthetiebreaker. Whentheregularizerisextremely large, then the original loss is not effective (and likely the model will have a large bias.) The most commonly used regularization is perhaps (cid:) regularization, 2 where R()  1(cid:)(cid:)2. It encourages the optimizer to find a model with 2 2 small (cid:) norm. In deep learning, its oftentimes referred to as weight de 2 cay, because gradient descent with learning rate  on the regularized loss R () is equivalent to shrinkingdecaying  by a scalar factor of 1 and  then applying the standard gradient   J ()  J()   (1) J() (9.2) (cid:) (cid:)(cid:) (cid:) decayingweights Besides encouraging simpler models, regularization can also impose in ductive biases or structures on the model parameters. For example, suppose we had a prior belief that the number of nonzeros in the groundtruth model parameters is small,2which is oftentimes called sparsity of the model, we can impose a regularization on the number of nonzeros in , denoted by (cid:)(cid:) , to leverage such a prior belief. Imposing additional structure of the 0 parameters narrows our search space and makes the complexity of the model family smaller,e.g., the family of sparse models can be thought of as having lower complexity than the family of all models, and thus tends to lead to a better generalization. On the other hand, imposing additional structure may risk increasing the bias. For example, if we regularize the sparsity strongly but no sparse models can predict the label accurately, we will suffer from large bias (analogously to the situation when we use linear models to learn data than can only be represented by quadratic functions in Section 8.1.) The sparsity of the parameters is not a continuous function of the param eters, and thus we cannot optimize it with (stochastic) gradient descent. A common relaxation is to use R()  (cid:)(cid:) as a continuous surrogate.3 1 2For linear models, this means the model just uses a few coordinates of the inputs to make an accurate prediction. 3There has been a rich line of theoretical work that explains why (cid:)(cid:) is a good sur 1 rogate for encouraging sparsity, but its beyond the scope of this course. An intuition is: assuming the parameter is on the unit sphere, the parameter with smallest (cid:) norm also 1 The R()  (cid:)(cid:) (also called LASSO) and R()  1(cid:)(cid:)2 are perhaps 1 2 2 among the most commonly used regularizers for linear models. Other norm and powers of norms are sometimes also used. The (cid:) norm regularization is 2 much more commonly used with kernel methods because (cid:) regularization is 1 typically not compatible with the kernel trick (the optimal solution cannot be written as functions of inner products of features.) In deep learning, the most commonly used regularizer is (cid:) regularization 2 or weight decay. Other common ones include dropout, data augmentation, regularizing the spectral norm of the weight matrices, and regularizing the Lipschitzness of the model, etc. Regularization in deep learning is an ac tive research area, and its known that there is another implicit source of regularization, as discussed in the next section. 9.2 Implicit regularization effect (optional reading) Theimplicitregularizationeffectofoptimizers, orimplicitbiasoralgorithmic regularization, is a new conceptphenomenon observed in the deep learning era. It largely refers to that the optimizers can implicitly impose structures on parameters beyond what has been imposed by the regularized loss. In most classical settings, the loss or regularized loss has a unique global minimum, and thus any reasonable optimizer should converge to that global minimum and cannot impose any additional preferences. However, in deep learning, oftentimes the loss or regularized loss has more than one (approx imate) global minima, and difference optimizers may converge to different global minima. Though these global minima have the same or similar train ing losses, they may be of different nature and have dramatically different generalization performance. See Figures 9.1 and 9.2 and its caption for an illustration and some experiment results. For example, its possible that one global minimum gives a much more Lipschitz or sparse model than others and thus has a better test error. It turns out that many commonlyused op timizers (or their components) prefer or bias towards finding global minima of certain properties, leading to a better test performance. happen to be the sparsest parameter with only 1 nonzero coordinate. Thus, sparsity and (cid:) norm gives the same extremal points to some extent. 1  ssol Figure 9.1: An Illustration that different global minima of the training loss can have different test performance. Figure 9.2: Left: Performance of neural networks trained by two different learning rates schedules on the CIFAR dataset. Although both exper iments used exactly the same regularized losses and the optimizers fit the training data perfectly, the models generalization performance differ much. Right: On a different synthetic dataset, optimizers with different initializa tions have the same training error but different generalization performance.4 In summary, the takehome message here is that the choice of optimizer does not only affect minimizing the training loss, but also imposes implicit regularization and affects the generalization of the model. Even if your cur rent optimizer already converges to a small training error perfectly, you may still need to tune your optimizer for a better generalization, . 4The setting is the same as in Woodworth et al. [], HaoChen et al. [] One may wonder which components of the optimizers bias towards what type of global minima and what type of global minima may generalize bet ter. These are open questions that researchers are actively investigating. Empirical and theoretical research have offered some clues and heuristics. In many (but definitely far from all) situations, among those setting where optimization can succeed in minimizing the training loss, the use of larger initial learning rate, smaller initialization, smaller batch size, and momen tum appears to help with biasing towards more generalizable solutions. A conjecture (that can be proven in certain simplified case) is that stochas ticity in the optimization process help the optimizer to find flatter global minima (global minima where the curvature of the loss is small), and flat global minima tend to give more Lipschitz models and better generalization. Characterizing the implicit regularization effect formally is still a challenging open research question. 9.3 Model selection via cross validation Suppose we are trying select among several different models for a learning problem. For instance, we might be using a polynomial regression model h (x)  g(   x   x2     xk), and wish to decide if k should be  0 1 2 k 0, 1, ..., or . How can we automatically select a model that represents a good tradeoff between the twin evils of bias and variance5? Alternatively, suppose we want to automatically choose the bandwidth parameter  for locally weighted regression, or the parameter C for our (cid:) regularized SVM. 1 How can we do that? For the sake of concreteness, in these notes we assume we have some finite set of models M  M ,...,M  that were trying to select among. 1 d For instance, in our first example above, the model M would be an ith i degree polynomial regression model. (The generalization to infinite M is not hard.6) Alternatively, if we are trying to decide between using an SVM, a neural network or logistic regression, then M may contain these models. 5Given that we said in the previous set of notes that bias and variance are two very different beasts, some readers may be wondering if we should be calling them twin evils here. Perhaps itd be better to think of them as nonidentical twins. The phrase the fraternal twin evils of bias and variance doesnt have the same ring to it, though. 6If we are trying to choose from an infinite set of models, say corresponding to the possible values of the bandwidth   R, we may discretize  and consider only a finite number of possible values for it. More generally, most of the algorithms described here can all be viewed as performing optimization search in the space of models, and we can perform this search over infinite model classes as well. Cross validation. Lets suppose we are, as usual, given a training set S. Given what we know about empirical risk minimization, heres what might initially seem like a algorithm, resulting from using empirical risk minimiza tion for model selection: 1. Train each model M on S, to get some hypothesis h . i i 2. Pick the hypotheses with the smallest training error. This algorithm does not work. Consider choosing the degree of a poly nomial. The higher the degree of the polynomial, the better it will fit the training set S, and thus the lower the training error. Hence, this method will always select a highvariance, highdegree polynomial model, which we saw previously is often poor choice. Heres an algorithm that works better. In holdout cross validation (also called simple cross validation), we do the following: 1. Randomly split S into S (say,  of the data) and S (the remain train cv ing ). Here, S is called the holdout cross validation set. cv 2. Train each model M on S only, to get some hypothesis h . i train i 3. Select and output the hypothesis h that had the smallest error  (h ) i Scv i on the hold out cross validation set. (Here  (h) denotes the average Scv error of h on the set of examples in S .) The error on the hold out cv validation set is also referred to as the validation error. By testingvalidating on a set of examples S that the models were not cv trained on, we obtain a better estimate of each hypothesis h s true general i izationtest error. Thus, this approach is essentially picking the model with the smallest estimated generalizationtest error. The size of the validation set depends on the total number of available examples. Usually, somewhere between 1413 of the data is used in the hold out cross validation set, and  is a typical choice. However, when the total dataset is huge, validation set can be a smaller fraction of the total examples as long as the absolute number of validation examples is decent. For example, for the ImageNet dataset that has about 1M training images, the validation set is sometimes set to be 50K images, which is only about 5 of the total examples. Optionally, step 3 in the algorithm may also be replaced with selecting the model M according to argmin  (h ), and then retraining M on the i i Scv i i entire training set S. (This is often a good idea, with one exception being learning algorithms that are be very sensitive to perturbations of the initial conditions andor data. For these methods, M doing well on S does not i train necessarily mean it will also do well on S , and it might be better to forgo cv this retraining step.) The disadvantage of using hold out cross validation is that it wastes about  of thedata. Even if wewere to take the optional step of retraining the model on the entire training set, its still as if were trying to find a good model for a learning problem in which we had 0.7n training examples, rather than n training examples, since were testing models that were trained on only 0.7n examples each time. While this is fine if data is abundant andor cheap, in learning problems in which data is scarce (consider a problem with n  , say), wed like to do something better. Here is a method, called kfold cross validation, that holds out less data each time: 1. Randomly split S into k disjoint subsets of mk training examples each. Lets call these subsets S ,...,S . 1 k 2. For each model M , we evaluate it as follows: i For j  1,...,k Train the model M on S S S S (i.e., train i 1 j1 j1 k on all the data except S ) to get some hypothesis h . j ij Test the hypothesis h on S , to get  (h ). ij j Sj ij The estimated generalization error of model M is then calculated i as the average of the  (h )s (averaged over j). Sj ij 3. Pick the model M with the lowest estimated generalization error, and i retrain that model on the entire training set S. The resulting hypothesis is then output as our final answer. A typical choice for the number of folds to use here would be k  . While the fraction of data held out each time is now 1kmuch smaller than beforethis procedure may also be more computationally expensive than holdout cross validation, since we now need train to each model k times. While k  is a commonly used choice, in problems in which data is really scarce, sometimes we will use the extreme choice of k  m in order to leave out as little data as possible each time. In this setting, we would repeatedly train on all but one of the training examples in S, and test on that heldout example. The resulting m  k errors are then averaged together to obtain our estimate of the generalization error of a model. This method has its own name; since were holding out one training example at a time, this method is called leaveoneout cross validation. Finally, even though we have described the different versions of cross vali dationasmethodsforselectingamodel, theycanalsobeusedmoresimplyto evaluate a single model or algorithm. For example, if you have implemented some learning algorithm and want to estimate how well it performs for your application (or if you have invented a novel learning algorithm and want to report in a technical paper how well it performs on various test sets), cross validation would give a reasonable way of doing so. 9.4 Bayesian statistics and regularization In this section, we will talk about one more tool in our arsenal for our battle against overfitting. At the beginning of the quarter, we talked about parameter fitting using maximum likelihood estimation (MLE), and chose our parameters according to n (cid:)   argmax p(y(i)x(i);). MLE  i1 Throughout our subsequent discussions, we viewed  as an unknown param eter of the world. This view of the  as being constantvalued but unknown is taken in frequentist statistics. In the frequentist this view of the world,  is not randomit just happens to be unknownand its our job to come up with statistical procedures (such as maximum likelihood) to try to estimate this parameter. An alternative way to approach our parameter estimation problems is to take the Bayesian view of the world, and think of  as being a random variable whose value is unknown. In this approach, we would specify a prior distribution p() on  that expresses our prior beliefs about the parameters. Given a training set S  (x(i),y(i))n , when we are asked to i1 make a prediction on a new value of x, we can then compute the posterior distribution on the parameters p(S)p() p(S)  p(S) (cid:0)(cid:)n p(y(i)x(i),) (cid:1) p()  i1 (9.3) (cid:) ( (cid:)n p(y(i)x(i),)p())d  i1 In the equation above, p(y(i)x(i),) comes from whatever model youre using for your learning problem. For example, if you are using Bayesian logistic re gression, thenyoumightchoosep(y(i)x(i),)  h (x(i))y(i)(1h (x(i)))(1y(i)),   where h (x(i))  1(1exp(Tx(i))).7  When we are given a new test example x and asked to make it prediction on it, we can compute our posterior distribution on the class label using the posterior distribution on : (cid:) p(yx,S)  p(yx,)p(S)d (9.4)  In the equation above, p(S) comes from Equation (9.3). Thus, for example, if the goal is to the predict the expected value of y given x, then we would output8 (cid:) E[yx,S]  yp(yx,S)dy y The procedure that weve outlined here can be thought of as doing fully Bayesian prediction, where our prediction is computed by taking an average with respect to the posterior p(S) over . Unfortunately, in general it is computationally very difficult to compute this posterior distribution. This is because it requires taking integrals over the (usually highdimensional)  as in Equation (9.3), and this typically cannot be done in closedform. Thus, in practice we will instead approximate the posterior distribution for . One common approximation is to replace our posterior distribution for  (as in Equation 9.4) with a single point estimate. The MAP (maximum a posteriori) estimate for  is given by n (cid:)   argmax p(y(i)x(i),)p(). (9.5) MAP  i1 Note that this is the same formulas as for the MLE (maximum likelihood) estimate for , except for the prior p() term at the end. In practical applications, a common choice for the prior p() is to assume that  N(0,2I). Usingthischoiceofprior,thefittedparameters will MAP have smaller norm than that selected by maximum likelihood. In practice, this causes the Bayesian MAP estimate to be less susceptible to overfitting than the ML estimate of the parameters. For example, Bayesian logistic regression turns out to be an effective algorithm for text classification, even though in text classification we usually have d (cid:) n. 7Since we are now viewing  as a random variable, it is okay to condition on it value, and write p(yx,) instead of p(yx;). 8The integral below would be replaced by a summation if y is discretevalued. Part IV Unsupervised learning Chapter Clustering and the kmeans algorithm In the clustering problem, we are given a training set x(1),...,x(n), and want to group the data into a few cohesive clusters. Here, x(i)  Rd as usual; but no labels y(i) are given. So, this is an unsupervised learning problem. The kmeans clustering algorithm is as follows: 1. Initialize cluster centroids  , ,...,  Rd randomly. 1 2 k 2. Repeat until convergence:  For every i, set c(i) : argminx(i)  2. j j For each j, set (cid:)n 1c(i)  jx(i)  : i1 . j (cid:)n 1c(i)  j i1  In the algorithm above, k (a parameter of the algorithm) is the number of clusters we want to find; and the cluster centroids  represent our current j guessesforthepositionsofthecentersoftheclusters. Toinitializethecluster centroids (in step 1 of the algorithm above), we could choose k training examples randomly, and set the cluster centroids to be equal to the values of these k examples. (Other initialization methods are also possible.) The innerloop of the algorithm repeatedly carries out two steps: (i) Assigning each training example x(i) to the closest cluster centroid  , and j Figure .1: Kmeans algorithm. Training examples are shown as dots, and cluster centroids are shown as crosses. (a) Original dataset. (b) Random ini tial cluster centroids (in this instance, not chosen to be equal to two training examples). (cf) Illustration of running two iterations of kmeans. In each iteration, we assign each training example to the closest cluster centroid (shown by painting the training examples the same color as the cluster centroid to which is assigned); then we move each cluster centroid to the mean of the points assigned to it. (Best viewed in color.) Images courtesy Michael Jordan. (ii) Moving each cluster centroid  to the mean of the points assigned to it. j Figure .1 shows an illustration of running kmeans. Is the kmeans algorithm guaranteed to converge? Yes it is, in a certain sense. In particular, let us define the distortion function to be: n (cid:) J(c,)  x(i)  2 c(i) i1 Thus, J measures the sum of squared distances between each training exam ple x(i) and the cluster centroid  to which it has been assigned. It can c(i) be shown that kmeans is exactly coordinate descent on J. Specifically, the innerloop of kmeans repeatedly minimizes J with respect to c while holding  fixed, and then minimizes J with respect to  while holding c fixed. Thus, J must monotonically decrease, and the value of J must converge. (Usu ally, this implies that c and  will converge too. In theory, it is possible for kmeans to oscillate between a few different clusteringsi.e., a few different values for c andor that have exactly the same value of J, but this almost never happens in practice.) The distortion function J is a nonconvex function, and so coordinate descent on J is not guaranteed to converge to the global minimum. In other words, kmeans can be susceptible to local optima. Very often kmeans will work fine and come up with very good clusterings despite this. But if you are worried about getting stuck in bad local minima, one common thing to do is run kmeans many times (using different random initial values for the cluster centroids  ). Then, out of all the different clusterings found, pick j the one that gives the lowest distortion J(c,). Chapter EM algorithms Inthissetofnotes,wediscusstheEM(ExpectationMaximization)algorithm for density estimation. .1 EM for mixture of Gaussians Suppose that we are given a training set x(1),...,x(n) as usual. Since we are in the unsupervised learning setting, these points do not come with any labels. We wish to model the data by specifying a joint distribution p(x(i),z(i))  p(x(i)z(i))p(z(i)). Here, z(i)  Multinomial() (where   0, (cid:)k   1, j j1 j and the parameter  gives p(z(i)  j)), and x(i)z(i)  j  N( , ). We j j j let k denote the number of values that the z(i)s can take on. Thus, our model posits that each x(i) was generated by randomly choosing z(i) from 1,...,k, and then x(i) was drawn from one of k Gaussians depending on z(i). This is called the mixture of Gaussians model. Also, note that the z(i)s are latent random variables, meaning that theyre hiddenunobserved. This is what will make our estimation problem difficult. The parameters of our model are thus ,  and . To estimate them, we can write down the likelihood of our data: n (cid:) (cid:)(,,)  logp(x(i);,,) i1 n k (cid:) (cid:)  log p(x(i)z(i);,)p(z(i);). i1 z(i)1 However, if we set to zero the derivatives of this formula with respect to the parameters and try to solve, well find that it is not possible to find the maximum likelihood estimates of the parameters in closed form. (Try this yourself at home.) The random variables z(i) indicate which of the k Gaussians each x(i) had come from. Note that if we knew what the z(i)s were, the maximum likelihood problem would have been easy. Specifically, we could then write down the likelihood as n (cid:) (cid:)(,,)  logp(x(i)z(i);,)logp(z(i);). i1 Maximizing this with respect to ,  and  gives the parameters: n 1 (cid:)   1z(i)  j, j n i1 (cid:)n 1z(i)  jx(i)   i1 , j (cid:)n 1z(i)  j i1 (cid:)n 1z(i)  j(x(i)  )(x(i)  )T   i1 j j . j (cid:)n 1z(i)  j i1 Indeed, we see that if the z(i)s were known, then maximum likelihood estimation becomes nearly identical to what we had when estimating the parameters of the Gaussian discriminant analysis model, except that here the z(i)s playing the role of the class labels.1 However, in our density estimation problem, the z(i)s are not known. What can we do? The EM algorithm is an iterative algorithm that has two main steps. Applied to our problem, in the Estep, it tries to guess the values of the z(i)s. In the Mstep, it updates the parameters of our model based on our guesses. Since in the Mstep we are pretending that the guesses in the first part were correct, the maximization becomes easy. Heres the algorithm: Repeat until convergence:  (Estep) For each i,j, set w(i) : p(z(i)  jx(i);,,) j 1There are other minor differences in the formulas here from what wed obtained in PS1 with Gaussian discriminant analysis, first because weve generalized the z(i)s to be multinomial rather than Bernoulli, and second because here we are using a different  j for each Gaussian. (Mstep) Update the parameters: n 1 (cid:)  : w(i), j n j i1 (cid:)n w(i)x(i)  : i1 j , j (cid:)n w(i) i1 j (cid:)n w(i)(x(i)  )(x(i)  )T  : i1 j j j j (cid:)n w(i) i1 j  In the Estep, we calculate the posterior probability of our parameters the z(i)s, given the x(i) and using the current setting of our parameters. I.e., using Bayes rule, we obtain: p(x(i)z(i)  j;,)p(z(i)  j;) p(z(i)  jx(i);,,)  (cid:)k p(x(i)z(i)  l;,)p(z(i)  l;) l1 Here, p(x(i)z(i)  j;,) is given by evaluating the density of a Gaussian with mean  and covariance  at x(i); p(z(i)  j;) is given by  , and so j j j on. The values w(i) calculated in the Estep represent our soft guesses2 for j the values of z(i). Also, you should contrast the updates in the Mstep with the formulas we had when the z(i)s were known exactly. They are identical, except that in steadoftheindicatorfunctions1z(i)  jindicatingfromwhichGaussian each datapoint had come, we now instead have the w(i)s. j The EMalgorithm is also reminiscent of the Kmeans clustering algo rithm, except that instead of the hard cluster assignments c(i), we instead have the soft assignments w(i). Similar to Kmeans, it is also susceptible j to local optima, so reinitializing at several different initial parameters may be a good idea. Its clear that the EM algorithm has a very natural interpretation of repeatedly trying to guess the unknown z(i)s; but how did it come about, and can we make any guarantees about it, such as regarding its convergence? In the next set of notes, we will describe a more general view of EM, one 2The term soft refers to our guesses being probabilities and taking values in [0,1]; in contrast, a hard guess is one that represents a single best guess (such as taking values in 0,1 or 1,...,k). that will allow us to easily apply it to other estimation problems in which there are also latent variables, and which will allow us to give a convergence guarantee. .2 Jensens inequality WebeginourdiscussionwithaveryusefulresultcalledJensens inequality Let f be a function whose domain is the set of real numbers. Recall that f is a convex function if f(cid:)(cid:)(x)  0 (for all x  R). In the case of f taking vectorvalued inputs, this is generalized to the condition that its hessian H is positive semidefinite (H  0). If f(cid:)(cid:)(x)  0 for all x, then we say f is strictly convex (in the vectorvalued case, the corresponding statement is that H must be positive definite, written H  0). Jensens inequality can then be stated as follows: Theorem. Let f be a convex function, and let X be a random variable. Then: E[f(X)]  f(EX). Moreover, if f is strictly convex, then E[f(X)]  f(EX) holds true if and only if X  E[X] with probability 1 (i.e., if X is a constant). Recallourconventionofoccasionallydroppingtheparentheseswhenwrit ing expectations, so in the theorem above, f(EX)  f(E[X]). For an interpretation of the theorem, consider the figure below. f(a) f E[f(X)] f(b) f(EX) a E[X] b Here, f is a convex function shown by the solid line. Also, X is a random variable that has a 0.5 chance of taking the value a, and a 0.5 chance of taking the value b (indicated on the xaxis). Thus, the expected value of X is given by the midpoint between a and b. We also see the values f(a), f(b) and f(E[X]) indicated on the yaxis. Moreover, the value E[f(X)] is now the midpoint on the yaxis between f(a) and f(b). From our example, we see that because f is convex, it must be the case that E[f(X)]  f(EX). Incidentally, quite a lot of people have trouble remembering which way the inequality goes, and remembering a picture like this is a good way to quickly figure out the answer. Remark. Recall that f is [strictly] concave if and only if f is [strictly] convex (i.e., f(cid:)(cid:)(x)  0 or H  0). Jensens inequality also holds for concave functions f, but with the direction of all the inequalities reversed (E[f(X)]  f(EX), etc.). .3 General EM algorithms Suppose we have an estimation problem in which we have a training set x(1),...,x(n) consisting of n independent examples. We have a latent vari able model p(x,z;) with z being the latent variable (which for simplicity is assumed to take finite number of values). The density for x can be obtained by marginalized over the latent variable z: (cid:) p(x;)  p(x,z;) (.1) z We wish to fit the parameters  by maximizing the loglikelihood of the data, defined by n (cid:) (cid:)()  logp(x(i);) (.2) i1 We can rewrite the objective in terms of the joint density p(x,z;) by n (cid:) (cid:)()  logp(x(i);) (.3) i1 n (cid:) (cid:)  log p(x(i),z(i);). (.4) i1 z(i) But, explicitly finding the maximum likelihood estimates of the parameters  may be hard since it will result in difficult nonconvex optimization prob lems.3 Here, the z(i)s are the latent random variables; and it is often the case that if the z(i)s were observed, then maximum likelihood estimation would be easy. In such a setting, the EM algorithm gives an efficient method for max imum likelihood estimation. Maximizing (cid:)() explicitly might be difficult, and our strategy will be to instead repeatedly construct a lowerbound on (cid:) (Estep), and then optimize that lowerbound (Mstep).4 It turns out that the summation (cid:)n is not essential here, and towards a i1 simpler exposition of the EM algorithm, we will first consider optimizing the thelikelihoodlogp(x)fora single example x. Afterwederivethealgorithm for optimizing logp(x), we will convert it to an algorithm that works for n examples by adding back the sum to each of the relevant equations. Thus, now we aim to optimize logp(x;) which can be rewritten as (cid:) logp(x;)  log p(x,z;) (.5) z (cid:) Let Q be a distribution over the possible values of z. That is, Q(z)  1, z Q(z)  0). Consider the following:5 (cid:) logp(x;)  log p(x,z;) z (cid:) p(x,z;)  log Q(z) (.6) Q(z) z (cid:) p(x,z;)  Q(z)log (.7) Q(z) z The last step of this derivation used Jensens inequality. Specifically, f(x)  logx is a concave function, since f(cid:)(cid:)(x)  1x2  0 over its domain 3Its mostly an empirical observation that the optimization problem is difficult to op timize. 4Empirically, the Estep and Mstep can often be computed more efficiently than op timizing the function (cid:)() directly. However, it doesnt necessarily mean that alternating the two steps can always converge to the global optimum of (cid:)(). Even for mixture of Gaussians, the EM algorithm can either converge to a global optimum or get stuck, de pendingonthepropertiesofthetrainingdata. Empirically, forrealworlddata, oftenEM can converge to a solution with relatively high likelihood (if not the optimum), and the theory behind it is still largely not understood. 5If z were continuous, then Q would be a density, and the summations over z in our discussion are replaced with integrals over z. x  R. Also, the term (cid:) (cid:) (cid:) p(x,z;) Q(z) Q(z) z in the summation is just an expectation of the quantity [p(x,z;)Q(z)] with respect to z drawn according to the distribution given by Q.6 By Jensens inequality, we have (cid:) (cid:) (cid:)(cid:) (cid:) (cid:) (cid:)(cid:) p(x,z;) p(x,z;) f E  E f , zQ zQ Q(z) Q(z) where the z  Q subscripts above indicate that the expectations are with respect to z drawn from Q. This allowed us to go from Equation (.6) to Equation (.7). Now, for any distribution Q, the formula (.7) gives a lowerbound on logp(x;). There are many possible choices for the Qs. Which should we choose? Well, if we have some current guess  of the parameters, it seems natural to try to make the lowerbound tight at that value of . I.e., we will make the inequality above hold with equality at our particular value of . To make the bound tight for a particular value of , we need for the step involving Jensens inequality in our derivation above to hold with equality. For this to be true, we know it is sufficient that the expectation be taken over a constantvalued random variable. I.e., we require that p(x,z;)  c Q(z) for some constant c that does not depend on z. This is easily accomplished by choosing Q(z)  p(x,z;). (cid:) Actually, since we know Q(z)  1 (because it is a distribution), this z further tells us that p(x,z;) Q(z)  (cid:) p(x,z;) z p(x,z;)  p(x;)  p(zx;) (.8) 6We note that the notion p(x,z;) only makes sense if Q(z)(cid:)0 whenever p(x,z;)(cid:)0. Q(z) Here we implicitly assume that we only consider those Q with such a property. Thus, we simply set the Qs to be the posterior distribution of the zs given x and the setting of the parameters . Indeed, we can directly verify that when Q(z)  p(zx;), then equa tion (.7) is an equality because (cid:) p(x,z;) (cid:) p(x,z;) Q(z)log  p(zx;)log Q(z) p(zx;) z z (cid:) p(zx;)p(x;)  p(zx;)log p(zx;) z (cid:)  p(zx;)logp(x;) z (cid:)  logp(x;) p(zx;) z (cid:)  logp(x;) (because p(zx;)  1) z For convenience, we call the expression in Equation (.7) the evidence lower bound (ELBO) and we denote it by (cid:) p(x,z;) ELBO(x;Q,)  Q(z)log (.9) Q(z) z With this equation, we can rewrite equation (.7) as Q,,x, logp(x;)  ELBO(x;Q,) (.) Intuitively, the EM algorithm alternatively updates Q and  by a) set ting Q(z)  p(zx;) following Equation (.8) so that ELBO(x;Q,)  logp(x;) for x and the current , and b) maximizing ELBO(x;Q,) w.r.t  while fixing the choice of Q. Recall that all the discussion above was under the assumption that we aim to optimize the loglikelihood logp(x;) for a single example x. It turns out that with multiple training examples, the basic idea is the same and we only needs to take a sum over examples at relevant places. Next, we will build the evidence lower bound for multiple training examples and make the EM algorithm formal. Recallwehaveatrainingsetx(1),...,x(n). Notethattheoptimalchoice of Q is p(zx;), and it depends on the particular example x. Therefore here we will introduce n distributions Q ,...,Q , one for each example x(i). For 1 n each example x(i), we can build the evidence lower bound (cid:) p(x(i),z(i);) logp(x(i);)  ELBO(x(i);Q ,)  Q (z(i))log i i Q (z(i)) i z(i) Taking sum over all the examples, we obtain a lower bound for the log likelihood (cid:) (cid:)()  ELBO(x(i);Q ,) (.) i i (cid:)(cid:) p(x(i),z(i);)  Q (z(i))log i Q (z(i)) i i z(i) For any set of distributions Q ,...,Q , the formula (.) gives a lower 1 n bound on (cid:)(), and analogous to the argument around equation (.8), the Q that attains equality satisfies i Q (z(i))  p(z(i)x(i);) i Thus, we simply set the Q s to be the posterior distribution of the z(i)s i given x(i) with the current setting of the parameters . Now, for this choice of the Q s, Equation (.) gives a lowerbound on i the loglikelihood (cid:) that were trying to maximize. This is the Estep. In the Mstep of the algorithm, we then maximize our formula in Equation (.) with respect to the parameters to obtain a new setting of the s. Repeatedly carrying out these two steps gives us the EM algorithm, which is as follows: Repeat until convergence  (Estep) For each i, set Q (z(i)) : p(z(i)x(i);). i (Mstep) Set n (cid:)  : argmax ELBO(x(i);Q ,) i  i1 (cid:)(cid:) p(x(i),z(i);)  argmax Q (z(i))log . (.)  i Q i (z(i)) i z(i)  How do we know if this algorithm will converge? Well, suppose (t) and (t1) are the parameters from two successive iterations of EM. We will now prove that (cid:)((t))  (cid:)((t1)), which shows EM always monotonically im proves the loglikelihood. The key to showing this result lies in our choice of the Q s. Specifically, on the iteration of EM in which the parameters had i started out as (t), we would have chosen Q(t)(z(i)) : p(z(i)x(i);(t)). We i saw earlier that this choice ensures that Jensens inequality, as applied to get Equation (.), holds with equality, and hence n (cid:) (cid:)((t))  ELBO(x(i);Q(t),(t)) (.) i i1 The parameters (t1) are then obtained by maximizing the right hand side of the equation above. Thus, n (cid:) (cid:)((t1))  ELBO(x(i);Q(t),(t1)) i i1 (because ineqaulity (.) holds for all Q and ) n (cid:)  ELBO(x(i);Q(t),(t)) (see reason below) i i1  (cid:)((t)) (by equation (.)) where the last inequality follows from that (t1) is chosen explicitly to be n (cid:) argmax ELBO(x(i);Q(t),) i  i1 Hence, EM causes the likelihood to converge monotonically. In our de scription of the EM algorithm, we said wed run it until convergence. Given the result that we just showed, one reasonable convergence test would be to check if the increase in (cid:)() between successive iterations is smaller than some tolerance parameter, and to declare convergence if EM is improving (cid:)() too slowly. Remark. If we define (by overloading ELBO()) (cid:) n (cid:)(cid:) p(x(i),z(i);) ELBO(Q,)  ELBO(x(i);Q ,)  Q (z(i))log i i Q (z(i)) i i1 i z(i) (.) then we know (cid:)()  ELBO(Q,) from our previous derivation. The EM can also be viewed an alternating maximization algorithm on ELBO(Q,), in which the Estep maximizes it with respect to Q (check this yourself), and the Mstep maximizes it with respect to . .3.1 Other interpretation of ELBO Let ELBO(x;Q,)  (cid:) Q(z)log p(x,z;) be defined as in equation (.9). z Q(z) There are several other forms of ELBO. First, we can rewrite ELBO(x;Q,)  E [logp(x,z;)]E [logQ(z)] zQ zQ  E [logp(xz;)]D (Q(cid:)p ) (.) zQ KL z where we use p to denote the marginal distribution of z (under the distri z bution p(x,z;)), and D () denotes the KL divergence KL (cid:) Q(z) D (Q(cid:)p )  Q(z)log (.) KL z p(z) z In many cases, the marginal distribution of z does not depend on the param eter . In this case, we can see that maximizing ELBO over  is equivalent to maximizing the first term in (.). This corresponds to maximizing the conditional likelihood of x conditioned on z, which is often a simpler question than the original question. Another form of ELBO() is (please verify yourself) ELBO(x;Q,)  logp(x)D (Q(cid:)p ) (.) KL zx where p is the conditional distribution of z given x under the parameter zx . This forms shows that the maximizer of ELBO(Q,) over Q is obtained when Q  p , which was shown in equation (.8) before. zx .4 Mixture of Gaussians revisited Armed with our general definition of the EM algorithm, lets go back to our old example of fitting the parameters ,  and  in a mixture of Gaussians. For the sake of brevity, we carry out the derivations for the Mstep updates only for  and  , and leave the updates for  as an exercise for the reader. j j The Estep is easy. Following our algorithm derivation above, we simply calculate w(i)  Q (z(i)  j)  P(z(i)  jx(i);,,). j i Here, Q (z(i)  j) denotes the probability of z(i) taking the value j under i the distribution Q . i Next, in theMstep, we need tomaximize, with respect to ourparameters ,,, the quantity (cid:) n (cid:) p(x(i),z(i);,,) Q (z(i))log i Q (z(i)) i i1 z(i) (cid:) n (cid:) k p(x(i)z(i)  j;,)p(z(i)  j;)  Q (z(i)  j)log i Q (z(i)  j) i i1 j1 (cid:0) (cid:1) n k 1 exp 1(x(i)  )T1(x(i)  )   (cid:)(cid:) w(i)log (2)d2j12 2 j j j j j w(i) i1 j1 j Lets maximize this with respect to  . If we take the derivative with respect l to  , we find l (cid:0) (cid:1) n k 1 exp 1(x(i)  )T1(x(i)  )   (cid:)(cid:) w(i)log (2)d2j12 2 j j j j  l j w(i) i1 j1 j n k (cid:)(cid:) 1   w(i) (x(i)  )T1(x(i)  )  l j 2 j j j i1 j1 n 1 (cid:)  w(i) 2T1x(i) T1 2 l  l l l l l l i1 n  (cid:) w(i)(cid:0) 1x(i) 1 (cid:1) l l l l i1 Setting this to zero and solving for  therefore yields the update rule l (cid:)n w(i)x(i)  : i1 l , l (cid:)n w(i) i1 l which was what we had in the previous set of notes. Lets do one more example, and derive the Mstep update for the param eters  . Grouping together only the terms that depend on  , we find that j j we need to maximize n k (cid:)(cid:) w(i)log . j j i1 j1 However, there is an additional constraint that the  s sum to 1, since they j represent the probabilities   p(z(i)  j;). To deal with the constraint j that (cid:)k   1, we construct the Lagrangian j1 j n k k (cid:)(cid:) (cid:) L()  w(i)log (  1), j j j i1 j1 j1 where  is the Lagrange multiplier.7 Taking derivatives, we find  (cid:) n w(i) j L()     j j i1 Setting this to zero and solving, we get (cid:)n w(i)   i1 j j  I.e.,   (cid:)n w(i). Using the constraint that (cid:)   1, we easily find j i1 j j j that   (cid:)n (cid:)k w(i)  (cid:)n 1  n. (This used the fact that w(i)  i1 j1 j i1 j Q (z(i)  j), and since probabilities sum to 1, (cid:) w(i)  1.) We therefore i j j have our Mstep updates for the parameters  : j n 1 (cid:)  : w(i). j n j i1 The derivation for the Mstep updates to  are also entirely straightfor j ward. .5 Variational inference and variational autoencoder (optional reading) Loosely speaking, variational autoencoder Kingma and Welling [] gen erally refers to a family of algorithms that extend the EM algorithms to more complex models parameterized by neural networks. It extends the technique of variational inference with the additional reparametrization trick which will be introduced below. Variational autoencoder may not give the best performance for many datasets, but it contains several central ideas about howtoextendEMalgorithmstohighdimensionalcontinuouslatentvariables 7Wedontneedtoworryabouttheconstraintthat 0,becauseaswellshortlysee, j the solution well find from this derivation will automatically satisfy that anyway. with nonlinear models. Understanding it will likely give you the language and backgrounds to understand various recent papers related to it. As a running example, we will consider the following parameterization of p(x,z;) by a neural network. Let  be the collection of the weights of a neural network g(z;) that maps z  Rk to Rd. Let z  N(0,I ) (.) kk xz  N(g(z;),2I ) (.) dd Here I denotes identity matrix of dimension k by k, and  is a scalar that kk we assume to be known for simplicity. For the Gaussian mixture models in Section .4, the optimal choice of Q(z)  p(zx;) for each fixed , that is the posterior distribution of z, can be analytically computed. In many more complex models such as the model(.), itsintractabletocomputetheexacttheposteriordistribution p(zx;). Recall that from equation (.), ELBO is always a lower bound for any choice of Q, and therefore, we can also aim for finding an approximation of the true posterior distribution. Often, one has to use some particular form to approximate the true posterior distribution. Let Q be a family of Qs that we are considering, and we will aim to find a Q within the family of Q that is closest to the true posterior distribution. To formalize, recall the definition of the ELBO lower bound as a function of Q and  defined in equation (.) (cid:) n (cid:)(cid:) p(x(i),z(i);) ELBO(Q,)  ELBO(x(i);Q ,)  Q (z(i))log i i Q (z(i)) i i1 i z(i) Recall that EM can be viewed as alternating maximization of ELBO(Q,). Here instead, we optimize the EBLO over Q  Q maxmaxELBO(Q,) (.) QQ  Now the next question is what form of Q (or what structural assumptions tomakeaboutQ)allowsustoefficientlymaximizetheobjectiveabove. When the latent variable z are highdimensional discrete variables, one popular as sumption is the mean field assumption, which assumes that Q (z) gives a i distribution with independent coordinates, or in other words, Q can be de i composed into Q (z)  Q1(z )Qk(z ). There are tremendous applications i i 1 i k of mean field assumptions to learning generative models with discrete latent variables, and we refer to Blei et al. [] for a survey of these models and their impact to a wide range of applications including computational biology, computational neuroscience, social sciences. We will not get into the details about the discrete latent variable cases, and our main focus is to deal with continuous latent variables, which requires not only mean field assumptions, but additional techniques. When z  Rk is a continuous latent variable, there are several decisions to maketowardssuccessfullyoptimizing(.). Firstweneedtogiveasuccinct representation of the distribution Q because it is over an infinite number of i points. A natural choice is to assume Q is a Gaussian distribution with some i mean and variance. We would also like to have more succinct representation of the means of Q of all the examples. Note that Q (z(i)) is supposed to i i approximate p(z(i)x(i);). It would make sense let all the means of the Q s i be some function of x(i). Concretely, let q(;),v(;) be two functions that map from dimension d to k, which are parameterized by  and , we assume that Q  N(q(x(i);),diag(v(x(i);))2) (.) i Here diag(w) means the k k matrix with the entries of w  Rk on the diagonal. In other words, the distribution Q is assumed to be a Gaussian i distribution with independent coordinates, and the mean and standard de viations are governed by q and v. Often in variational autoencoder, q and v are chosen to be neural networks.8 In recent deep learning literature, often q,v are called encoder (in the sense of encoding the data into latent code), whereas g(z;) if often referred to as the decoder. WeremarkthatQ ofsuchforminmanycasesareveryfarfromagoodap i proximationofthetrueposteriordistribution. However, someapproximation is necessary for feasible optimization. In fact, the form of Q needs to satisfy i other requirements (which happened to be satisfied by the form (.)) Before optimizing the ELBO, lets first verify whether we can efficiently evaluate the value of the ELBO for fixed Q of the form (.) and . We rewrite the ELBO as a function of ,, by (cid:) n (cid:) p(x(i),z(i);) (cid:) ELBO(,,)  E log , (.) z(i)Qi Q (z(i)) i i1 where Q  N(q(x(i);),diag(v(x(i);))2) i Note that to evaluate Q (z(i)) inside the expectation, we should be able to i compute the density of Q . To estimate the expectation E , we i z(i)Qi 8q andv canalsoshareparameters. Wesweepthislevelofdetailsundertheruginthis note. should be able to sample from distribution Q so that we can build an i empirical estimator with samples. It happens that for Gaussian distribution Q  N(q(x(i);),diag(v(x(i);))2), we are able to be both efficiently. i NowletsoptimizetheELBO.Itturnsoutthatwecanrungradientascent over ,, instead of alternating maximization. There is no strong need to compute the maximum over each variable at a much greater cost. (For Gaus sian mixture model in Section .4, computing the maximum is analytically feasibleandrelativelycheap, andthereforewedidalternatingmaximization.) Mathematically, let  be the learning rate, the gradient ascent step is  :  ELBO(,,)   :  ELBO(,,)   :   ELBO(,,)  Computing the gradient over  is simple because (cid:) n (cid:) p(x(i),z(i);) (cid:)  ELBO(,,)   E log   z(i)Qi Q (z(i)) i i1 n (cid:) (cid:2) (cid:3)   E logp(x(i),z(i);)  z(i)Qi i1 n (cid:) (cid:2) (cid:3)  E  logp(x(i),z(i);) , (.) z(i)Qi  i1 But computing the gradient over  and  is tricky because the sam pling distribution Q depends on  and . (Abstractly speaking, the is i sue we face can be simplified as the problem of computing the gradi ent E [f()] with respect to variable . We know that in general, zQ  E [f()] (cid:) E [f()] because the dependency of Q on  has to be zQ zQ    taken into account as well. ) The idea that comes to rescue is the socalled reparameterization trick: we rewrite z(i)  Q  N(q(x(i);),diag(v(x(i);))2) in an equivalent i way: z(i)  q(x(i);)v(x(i);)(cid:)(i) where (i)  N(0,I ) (.) kk Here x (cid:) y denotes the entrywise product of two vectors of the same dimension. Here we used the fact that x  N(,2) is equivalent to that x   with  N(0,1). Wemostlyjustusedthisfactineverydimension simultaneously for the random variable z(i)  Q . i With this reparameterization, we have that (cid:) p(x(i),z(i);) (cid:) E log (.) z(i)Qi Q (z(i)) i (cid:) p(x(i),q(x(i);)v(x(i);)(cid:)(i);) (cid:)  E log (i)N(0,1) Q (q(x(i);)v(x(i);)(cid:)(i)) i It follows that (cid:) p(x(i),z(i);) (cid:)  E log  z(i)Qi Q (z(i)) i (cid:) p(x(i),q(x(i);)v(x(i);)(cid:)(i);) (cid:)   E log  (i)N(0,1) Q (q(x(i);)v(x(i);)(cid:)(i)) i (cid:) p(x(i),q(x(i);)v(x(i);)(cid:)(i);) (cid:)  E  log (i)N(0,1)  Q (q(x(i);)v(x(i);)(cid:)(i)) i We can now sample multiple copies of (i)s to estimate the the expecta tion in the RHS of the equation above.9 We can estimate the gradient with respect to  similarly, and with these, we can implement the gradient ascent algorithm to optimize the ELBO over ,,. Therearenotmanyhighdimensionaldistributionswithanalyticallycom putable density function are known to be reparameterizable. We refer to Kingma and Welling [] for a few other choices that can replace Gaussian distribution. 9Empirically people sometimes just use one sample to estimate it for maximum com putational efficiency. Chapter Principal components analysis Inthissetofnotes, wewilldevelopamethod, PrincipalComponentsAnalysis (PCA), that tries to identify the subspace in which the data approximately lies. PCA is computationally efficient: it will require only an eigenvector calculation (easily done with the eig function in Matlab). Suppose we are given a dataset x(i);i  1,...,n of attributes of n dif ferent types of automobiles, such as their maximum speed, turn radius, and so on. Let x(i)  Rd for each i (d (cid:) n). But unknown to us, two different attributessome x and x respectively give a cars maximum speed mea i j sured in miles per hour, and the maximum speed measured in kilometers per hour. These two attributes are therefore almost linearly dependent, up to only small differences introduced by rounding off to the nearest mph or kph. Thus, the data really lies approximately on an n1 dimensional subspace. How can we automatically detect, and perhaps remove, this redundancy? For a less contrived example, consider a dataset resulting from a survey of pilots for radiocontrolled helicopters, where x(i) is a measure of the piloting 1 skill of pilot i, and x(i) captures how much heshe enjoys flying. Because 2 RC helicopters are very difficult to fly, only the most committed students, ones that truly enjoy flying, become good pilots. So, the two attributes x and x are strongly correlated. Indeed, we might posit that that the 1 2 data actually likes along some diagonal axis (the u direction) capturing the 1 intrinsic piloting karma of a person, with only a small amount of noise lying off this axis. (See figure.) How can we automatically compute this u 1 direction? x 1 )tnemyojne( x 2 u 1 u 2 (skill) We will shortly develop the PCA algorithm. But prior to running PCA per se, typically we first preprocess the data by normalizing each feature to have mean 0 and variance 1. We do this by subtracting the mean and dividing by the empirical standard deviation: x(i)  x(i)  j j j  j where   1 (cid:)n x(i) and 2  1 (cid:)n (x(i) )2 are the mean variance of j n i1 j j n i1 j j feature j, respectively. Subtracting  zeros out the mean and may be omitted for data known j to have zero mean (for instance, time series corresponding to speech or other acoustic signals). Dividing by the standard deviation  rescales each coor j dinate to have unit variance, which ensures that different attributes are all treated on the same scale. For instance, if x was cars maximum speed in 1 mph (taking values in the high tens or low hundreds) and x were the num 2 ber of seats (taking values around 24), then this renormalization rescales the different attributes to make them more comparable. This rescaling may be omitted if we had a priori knowledge that the different attributes are all on the same scale. One example of this is if each data point represented a grayscale image, and each x(i) took a value in 0,1,..., corresponding j to the intensity value of pixel j in image i. Now, having normalized our data, how do we compute the major axis of variation uthat is, the direction on which the data approximately lies? One way is to pose this problem as finding the unit vector u so that when the data is projected onto the direction corresponding to u, the variance of the projected data is maximized. Intuitively, the data starts off with some amount of varianceinformation in it. We would like to choose a direction u so that if we were to approximate the data as lying in the directionsubspace corresponding to u, as much as possible of this variance is still retained. Consider the following dataset, on which we have already carried out the normalization steps: Now, suppose we pick u to correspond the the direction shown in the figure below. The circles denote the projections of the original data onto this line. (cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0)(cid:1)(cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0) (cid:0) (cid:1) (cid:1)(cid:0) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1)(cid:0) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) We see that the projected data still has a fairly large variance, and the points tend to be far from zero. In contrast, suppose had instead picked the following direction: (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0) (cid:0) (cid:1) (cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0)(cid:1)(cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:1)(cid:0) (cid:0) (cid:1) (cid:1) (cid:0) (cid:0) (cid:1) (cid:1)(cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:0) (cid:0) (cid:0) (cid:1) (cid:1) (cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) (cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1)(cid:0)(cid:1) Here, the projections have a significantly smaller variance, and are much closer to the origin. We would like to automatically select the direction u corresponding to the first of the two figures shown above. To formalize this, note that given a unit vector u and a point x, the length of the projection of x onto u is given by xTu. I.e., if x(i) is a point in our dataset (one of the crosses in the plot), then its projection onto u (the corresponding circle in the figure) is distance xTu from the origin. Hence, to maximize the variance of the projections, we would like to choose a unitlength u so as to maximize: n n 1 (cid:) (x(i)T u)2  1 (cid:) uTx(i)x(i)T u n n i1 i1 (cid:) (cid:) n  uT 1 (cid:) x(i)x(i)T u. n i1 We easily recognize that the maximizing this subject to (cid:)u(cid:)  1 gives the 2 principal eigenvector of   1 (cid:)n x(i)x(i)T , which is just the empirical n i1 covariance matrix of the data (assuming it has zero mean).1 To summarize, we have found that if we wish to find a 1dimensional subspace with with to approximate the data, we should choose u to be the principal eigenvector of . More generally, if we wish to project our data into a kdimensional subspace (k  d), we should choose u ,...,u to be the 1 k top k eigenvectors of . The u s now form a new, orthogonal basis for the i data.2 Then, to represent x(i) in this basis, we need only compute the corre sponding vector   uTx(i) 1 uTx(i) y(i)   2 .   Rk.  .  .   uTx(i) k Thus, whereas x(i)  Rd, the vector y(i) now gives a lower, kdimensional, approximationrepresentation for x(i). PCA is therefore also referred to as a dimensionality reduction algorithm. The vectors u ,...,u are called 1 k the first k principal components of the data. Remark. Although we have shown it formally only for the case of k  1, using wellknown properties of eigenvectors it is straightforward to show that 1If you havent seen this before, try using the method of Lagrange multipliers to max imize uTu subject to that uTu1. You should be able to show that uu, for some , which implies u is an eigenvector of , with eigenvalue . 2Because  is symmetric, the u s will (or always can be chosen to be) orthogonal to i each other. of all possible orthogonal bases u ,...,u , the one that we have chosen max 1 k imizes (cid:) (cid:)y(i)(cid:)2. Thus, our choice of a basis preserves as much variability i 2 as possible in the original data. PCA can also be derived by picking the basis that minimizes the ap proximation error arising from projecting the data onto the kdimensional subspace spanned by them. (See more in homework.) PCAhasmanyapplications; wewillcloseourdiscussionwithafewexam ples. First, compressionrepresenting x(i)s with lower dimension y(i)sis an obvious application. If we reduce high dimensional data to k  2 or 3 di mensions, then we can also plot the y(i)s to visualize the data. For instance, if we were to reduce our automobiles data to 2 dimensions, then we can plot it (one point in our plot would correspond to one car type, say) to see what cars are similar to each other and what groups of cars may cluster together. Another standard application is to preprocess a dataset to reduce its dimension before running a supervised learning learning algorithm with the x(i)s as inputs. Apart from computational benefits, reducing the datas dimension can also reduce the complexity of the hypothesis class considered and help avoid overfitting (e.g., linear classifiers over lower dimensional input spaces will have smaller VC dimension). Lastly, as in our RC pilot example, we can also view PCA as a noise reduction algorithm. In our example it, estimates the intrinsic piloting karma from the noisy measures of piloting skill and enjoyment. In class, we also saw the application of this idea to face images, resulting in eigenfaces method. Here, each point x(i)  R100 was a dimensional vector, with each coordinate corresponding to a pixel intensity value in a 100x100 image of a face. Using PCA, we represent each image x(i) with a much lower dimensional y(i). In doing so, we hope that the principal components we found retain the interesting, systematic variations between faces that capture what a person really looks like, but not the noise in the images introduced by minor lighting variations, slightly different imaging conditions, and so on. We then measure distances between faces i and j by working in the reduced dimension, and computing (cid:)y(i)y(j)(cid:) . This resulted in a surprisingly good 2 facematching and retrieval algorithm. Chapter Independent components analysis Our next topic is Independent Components Analysis (ICA). Similar to PCA, this will find a new basis in which to represent our data. However, the goal is very different. As a motivating example, consider the cocktail party problem. Here, d speakers are speaking simultaneously at a party, and any microphone placed intheroomrecordsonlyanoverlappingcombinationofthedspeakersvoices. But lets say we have d different microphones placed in the room, and because each microphone is a different distance from each of the speakers, it records a differentcombinationofthespeakersvoices. Usingthesemicrophonerecord ings, can we separate out the original d speakers speech signals? To formalize this problem, we imagine that there is some data s  Rd that is generated via d independent sources. What we observe is x  As, where A is an unknown square matrix called the mixing matrix. Repeated observations gives us a dataset x(i);i  1,...,n, and our goal is to recover the sources s(i) that had generated our data (x(i)  As(i)). In our cocktail party problem, s(i) is an ddimensional vector, and s(i) is j thesoundthatspeakerj wasutteringattimei. Also, x(i) inanddimensional vector, and x(i) is the acoustic reading recorded by microphone j at time i. j Let W  A1 be the unmixing matrix. Our goal is to find W, so that given our microphone recordings x(i), we can recover the sources by computing s(i)  Wx(i). For notational convenience, we also let wT denote i the ith row of W, so that    wT  1 . W   . . .    wT  d Thus, w  Rd, and the jth source can be recovered as s(i)  wTx(i). i j j .1 ICA ambiguities To what degree can W  A1 be recovered? If we have no prior knowledge about the sources and the mixing matrix, it is easy to see that there are some inherent ambiguities in A that are impossible to recover, given only the x(i)s. Specifically, let P be any dbyd permutation matrix. This means that each row and each column of P has exactly one 1. Here are some examples of permutation matrices:   0 1 0 (cid:) (cid:) (cid:) (cid:) 0 1 1 0 P   1 0 0 ; P  ; P  . 1 0 0 1 0 0 1 If z is a vector, then Pz is another vector that contains a permuted version of zs coordinates. Given only the x(i)s, there will be no way to distinguish between W and PW. Specifically, the permutation of the original sources is ambiguous, which should be no surprise. Fortunately, this does not matter for most applications. Further, there is no way to recover the correct scaling of the w s. For in i stance, if A were replaced with 2A, and every s(i) were replaced with (0.5)s(i), then our observed x(i)  2A(0.5)s(i) would still be the same. More broadly, if a single column of A were scaled by a factor of , and the corresponding source were scaled by a factor of 1, then there is again no way to determine that this had happened given only the x(i)s. Thus, we cannot recover the correct scaling of the sources. However, for the applications that we are concerned withincluding the cocktail party problemthis ambiguity also does not matter. Specifically, scaling a speakers speech signal s(i) by some j positive factor  affects only the volume of that speakers speech. Also, sign changes do not matter, and s(i) and s(i) sound identical when played on a j j speaker. Thus, if the w found by an algorithm is scaled by any nonzero real i number, the corresponding recovered source s  wTx will be scaled by the i i same factor; but this usually does not matter. (These comments also apply to ICA for the brainMEG data that we talked about in class.) Are these the only sources of ambiguity in ICA? It turns out that they are, so long as the sources s are nonGaussian. To see what the difficulty is i with Gaussian data, consider an example in which n  2, and s  N(0,I). Here, I is the 2x2 identity matrix. Note that the contours of the density of the standard normal distribution N(0,I) are circles centered on the origin, and the density is rotationally symmetric. Now, suppose we observe some x  As, where A is our mixing matrix. Then, the distribution of x will be Gaussian, x  N(0,AAT), since E [x]  E[As]  AE[s]  0 sN(0,I) Cov[x]  E [xxT]  E[AssTAT]  AE[ssT]AT  ACov[s]AT  AAT sN(0,I) Now, let R be an arbitrary orthogonal (less formally, a rotationreflection) matrix, so that RRT  RTR  I, and let A(cid:)  AR. Then if the data had been mixed according to A(cid:) instead of A, we would have instead observed x(cid:)  A(cid:)s. The distribution of x(cid:) is also Gaussian, x(cid:)  N(0,AAT), since E [x(cid:)(x(cid:))T]  E[A(cid:)ssT(A(cid:))T]  E[ARssT(AR)T]  ARRTAT  AAT. sN(0,I) Hence, whether the mixing matrix is A or A(cid:), we would observe data from a N(0,AAT) distribution. Thus, there is no way to tell if the sources were mixed using A and A(cid:). There is an arbitrary rotational component in the mixing matrix that cannot be determined from the data, and we cannot recover the original sources. Our argument above was based on the fact that the multivariate standard normal distribution is rotationally symmetric. Despite the bleak picture that this paints for ICA on Gaussian data, it turns out that, so long as the data is not Gaussian, it is possible, given enough data, to recover the d independent sources. .2 Densities and linear transformations Before moving on to derive the ICA algorithm proper, we first digress briefly to talk about the effect of linear transformations on densities. Suppose a random variable s is drawn according to some density p (s). s For simplicity, assume for now that s  R is a real number. Now, let the random variable x be defined according to x  As (here, x  R,A  R). Let p be the density of x. What is p ? x x Let W  A1. To calculate the probability of a particular value of x, it is tempting to compute s  Wx, then then evaluate p at that point, and s conclude that p (x)  p (Wx). However, this is incorrect. For example, x s let s  Uniform[0,1], so p (s)  10  s  1. Now, let A  2, so x  2s. s Clearly, x is distributed uniformly in the interval [0,2]. Thus, its density is given by p (x)  (0.5)10  x  2. This does not equal p (Wx), where x s W  0.5  A1. Instead, the correct formula is p (x)  p (Wx)W. x s More generally, if s is a vectorvalued distribution with density p , and s x  As for a square, invertible matrix A, then the density of x is given by p (x)  p (Wx)W, x s where W  A1. Remark. If youre seen the result that A maps [0,1]d to a set of volume A, thenheresanotherwaytoremembertheformulaforp givenabove,thatalso x generalizes our previous 1dimensional example. Specifically, let A  Rdd be given, and let W  A1 as usual. Also let C  [0,1]d be the ddimensional 1 hypercube, and define C  As : s  C   Rd to be the image of C 2 1 1 under the mapping given by A. Then it is a standard result in linear algebra (and, indeed, one of the ways of defining determinants) that the volume of C is given by A. Now, suppose s is uniformly distributed in [0,1]d, so its 2 density is p (s)  1s  C . Then clearly x will be uniformly distributed s 1 in C . Its density is therefore found to be p (x)  1x  C vol(C ) (since 2 x 2 2 it must integrate over C to 1). But using the fact that the determinant 2 of the inverse of a matrix is just the inverse of the determinant, we have 1vol(C )  1A  A1  W. Thus, p (x)  1x  C W  1Wx  2 x 2 C W  p (Wx)W. 1 s .3 ICA algorithm We are now ready to derive an ICA algorithm. We describe an algorithm by Bell and Sejnowski, and we give an interpretation of their algorithm as a methodformaximumlikelihoodestimation. (Thisisdifferentfromtheirorig inal interpretation involving a complicated idea called the infomax principal which is no longer necessary given the modern understanding of ICA.) We suppose that the distribution of each source s is given by a density j p , and that the joint distribution of the sources s is given by s d (cid:) p(s)  p (s ). s j j1 Note that by modeling the joint distribution as a product of marginals, we capturetheassumptionthatthesourcesareindependent. Usingourformulas from the previous section, this implies the following density on x  As  W1s: d (cid:) p(x)  p (wTx)W. s j j1 All that remains is to specify a density for the individual sources p . s Recall that, given a realvalued random variable z, its cumulative distri bution function (cdf) F is defined by F(z )  P(z  z )  (cid:)z0 p (z)dz and 0 0  z the density is the derivative of the cdf: p (z)  F(cid:)(z). z Thus, to specify a density for the s s, all we need to do is to specify some i cdf for it. A cdf has to be a monotonic function that increases from zero to one. Following our previous discussion, we cannot choose the Gaussian cdf, as ICA doesnt work on Gaussian data. What well choose instead as a reasonable default cdf that slowly increases from 0 to 1, is the sigmoid function g(s)  1(1es). Hence, p (s)  g(cid:)(s).1 s The square matrix W is the parameter in our model. Given a training set x(i);i  1,...,n, the log likelihood is given by (cid:) (cid:) n d (cid:) (cid:) (cid:)(W)  logg(cid:)(wTx(i))logW . j i1 j1 We would like to maximize this in terms W. By taking derivatives and using the fact (from the first set of notes) that  W  W(W1)T, we easily W derive a stochastic gradient ascent learning rule. For a training example x(i), the update rule is:    12g(wTx(i)) 1  12g(wTx(i))   W : W  . 2 x(i)T (WT)1,  .   .    12g(wTx(i)) d 1If you have prior knowledge that the sources densities take a certain form, then it is a good idea to substitute that in here. But in the absence of such knowledge, the sigmoid function can be thought of as a reasonable default that seems to work well for many problems. Also, the presentation here assumes that either the data x(i) has been preprocessed to have zero mean, or that it can naturally be expected to have zero mean (such as acoustic signals). This is necessary because our assumption that p (s)  g(cid:)(s) s implies E[s]  0 (the derivative of the logistic function is a symmetric function, and hence gives a density corresponding to a random variable with zero mean), which implies E[x]E[As]0. where  is the learning rate. After the algorithm converges, we then compute s(i)  Wx(i) to recover the original sources. Remark. When writing down the likelihood of the data, we implicitly as sumed that the x(i)s were independent of each other (for different values of i; note this issue is different from whether the different coordinates of x(i) are independent), so that the likelihood of the training set was given by (cid:) p(x(i);W). This assumption is clearly incorrect for speech data and i other time series where the x(i)s are dependent, but it can be shown that having correlated training examples will not hurt the performance of the al gorithm if we have sufficient data. However, for problems where successive training examples are correlated, when implementing stochastic gradient as cent, it sometimes helps accelerate convergence if we visit training examples in a randomly permuted order. (I.e., run stochastic gradient ascent on a randomly shuffled copy of the training set.) Chapter Selfsupervised learning and foundation models Despite its huge success, supervised learning with neural networks typically relies on the availability of a labeled dataset of decent size, which is some times costly to collect. Recently, AI and machine learning are undergoing a paradigm shift with the rise of models (e.g., BERT [Devlin et al., ] and GPT3 [Brown et al., ]) that are pretrained on broad data at scale and are adaptable to a wide range of downstream tasks. These models, called foundation models by Bommasani et al. [], oftentimes leverage massive unlabeled data so that much fewer labeled data in the downstream tasks are needed. Moreover, though foundation models are based on standard deep learning and transfer learning, their scale results in new emergent capabil ities. These models are typically (pre)trained by selfsupervised learning methods where the supervisionslabels come from parts of the inputs. This chapter will introduce the paradigm of foundation models and basic related concepts. .1 Pretraining and adaptation The foundation models paradigm consists of two phases: pretraining (or sim ply training) and adaptation. We first pretrain a large model on a massive unlabeled dataset (e.g., billions of unlabeled images).1 Then, we adapt the pretrained model to a downstream task (e.g., detecting cancer from scan im ages). These downstream tasks are often prediction tasks with limited or 1Sometimes, pretraining can involve largescale labeled datasets as well (e.g., the Ima geNet dataset). even no labeled data. The intuition is that the pretrained models learn good representations that capture intrinsic semantic structure information about the data, and the adaptation phase customizes the model to a particular downstream task by, e.g., retrieving the information specific to it. For ex ample, a model pretrained on massive unlabeled image data may learn good general visual representationsfeatures, and we adapt the representations to solve biomedical imagining tasks. We formalize the two phases below. Pretraining. Suppose we have an unlabeled pretraining dataset x(1),x(2) ,x(n) that consists of n examples in Rd. Let  be a model that  is parameterized by  and maps the input x to some mdimensional represen tation  (x). (People also call  (x)  Rm the embedding or features of the   example x.) We pretrain the model  with a pretraining loss, which is often anaverageoflossfunctionsonalltheexamples: L ()  1 (cid:)n (cid:) (,x(i)). pre n i1 pre Here (cid:) is a socalled selfsupervised loss on a single datapoint x(i), because pre as shown later, e.g., in Section .3, the supervision comes from the data point x(i) itself. It is also possible that the pretraining loss is not a sum of losses on individual examples. We will discuss two pretraining losses in Section .2 and Section .3. We use some optimizers (mostly likely SGD or ADAM [Kingma and Ba,  ]) to minimize L (). We denote the obtained pretrained model by . pre Adaptation. For a downstream task, we usually have a labeled dataset (x(1) ,y(1) ), ,(x(n task ),y(n task )) with n examples. The setting when task task task task task n  0 is called zeroshot learningthe downstream task doesnt have any task labeled examples. When n is relatively small (say, between 1 and ), the task setting is called fewshot learning. Its also pretty common to have a larger n on the order of ranging from hundreds to tens of thousands. task Anadaptationalgorithmgenerallytakesinadownstreamdatasetandthe   pretrained model , and outputs a variant of  that solves the downstream task. We will discuss below two popular and general adaptation methods, linear probe and finetuning. In addition, two other methods specific to lan guage problems are introduced in .3.2. The linear probe approach uses a linear head on top of the representation to predict the downstream labels. Mathematically, the adapted model out puts w(cid:) (x), where w  Rm is a parameter to be learned, and   is exactly  the pretrained model (fixed). We can use SGD (or other optimizers) to train w on the downstream task loss to predict the task label n 1 (cid:)task min (cid:) (y(i) ,w(cid:) (x(i) )) (.1) wRm n task task task  task i1 E.g., if the downstream task is a regression problem, we will have (cid:) (y ,w(cid:) (x ))  (y w(cid:) (x ))2. task task  task task  task The finetuning algorithm uses a similar structure for the downstream prediction model, but also further finetunes the pretrained model (instead of keeping it fixed). Concretely, the prediction model is w(cid:) (x) with pa  rameters w and . We optimize both w and  to fit the downstream data,  but initialize  with the pretrained model . The linear head w is usually initialized randomly. n 1 (cid:)task minimize (cid:) (y(i) ,w(cid:) (x(i) )) (.2) w, n task task task  task i1 with initialization w  random vector (.3)     (.4) Various other adaptation methods exists and are sometimes specialized to the particular pretraining methods. We will discuss one of them in Sec tion .3.2. .2 Pretraining methods in computer vision This section introduces two concrete pretraining methods for computer vi sion: supervised pretraining and contrastive learning. Supervised pretraining. Here, the pretraining dataset is a largescale labeled dataset (e.g., ImageNet), and the pretrained models are simply a neural network trained with vanilla supervised learning (with the last layer being removed). Concretely, suppose we write the learned neural network as  U (x), whereU is the last (fullyconnected)layer parameters,  corresponds  to the parameters of all the other layers, and  (x) are the penultimate  activations layer (which serves as the representation). We simply discard U and use  (x) as the pretrained model.  Contrastive learning. Contrastive learning is a selfsupervised pretraining method that uses only unlabeled data. The main intuition is that a good representation function  () should map semantically similar images to sim  ilar representations, and that random pair of images should generally have distinct representations. E.g., we may want to map images of two huskies to similar representations, but a husky and an elephant should have different representations. One definition of similarity is that images from the same class are similar. Using this definition will result in the socalled supervised contrastive algorithms that work well when labeled pretraining datasets are available. Without labeled data, we can use data augmentation to generate a pair of similar augmented images given an original image x. Data augmenta tion typically means that we apply random cropping, flipping, andor color transformation on the original image x to generate a variant. We can take two random augmentations, denoted by x and x, of the same original image x, and call them a positive pair. We observe that positive pairs of images are often semantically related because they are augmentations of the same image. We will design a loss function for  such that the representations of a positive pair,  (x), (x), as close to each other as possible.   On the other hand, we can also take another random image z from the pretraining dataset and generate an augmentation zfrom z. Note that (x,z) are from different images; therefore, with a good chance, they are not seman tically related. We call (x,z) a negative or random pair.2 We will design a loss to push the representation of random pairs,  (x), (z), far away from   each other. There are many recent algorithms based on the contrastive learning prin ciple, and here we introduce SIMCLR [Chen et al., ] as an concrete example. The loss function is defined on a batch of examples (x1, ,x(B)) with batch size B. The algorithm computes two random augmentations for each example x(i) in the batch, denoted by x(i) and x(i). As a result, we have the augmented batch of 2B examples: x1, ,x(B), x1, ,x(B). The SIMCLR loss is defined as3 (cid:) B exp (cid:0)   (x(i))(cid:)  (x(i)) (cid:1) L ()   log . pre exp( (x(i))(cid:) (x(i))) (cid:) exp( (x(i))(cid:) (x(j))) i1   j(cid:)i   The intuition is as follows. The loss is increasing in  (x(i))(cid:) (x(j)), and   thus minimizing the loss encourages  (x(i))(cid:) (x(j)) to be small, making    (x(i)) far away from  (x(j)). On the other hand, the loss is decreasing in   2Random pair may be a more accurate term because its still possible (though not likely) that x and z are semantically related, so are x and z. But in the literature, the term negative pair seems to be also common. 3Thisisavariantandsimplificationoftheoriginallossthatdoesnotchangetheessence (but may change the efficiency slightly).  (x(i))(cid:) (x(i)), and thus minimizing the loss encourages  (x(i))(cid:) (x(i))     to be large, resulting in  (x(i)) and  (x(i)) to be close.4   .3 Pretrained large language models Natural language processing is another area where pretraining models are particularly successful. In language problems, an example typically corre sponds to a document or generally a sequencetrunk of words,5 denoted by x  (x , ,x ) where T is the length of the documentsequence, 1 T x  1, ,V are words in the document, and V is the vocabulary size.6 i A language model is a probabilistic model representing the probability of a document, denoted by p(x , ,x ). This probability distribution is very 1 T complex because its support size is VT  exponential in the length of the document. Instead of modeling the distribution of a document itself, we can apply the chain rule of conditional probability to decompose it as follows: p(x , ,x )  p(x )p(x x )p(x x , ,x ). (.5) 1 T 1 2 1 T 1 T1 Now the support size of each of the conditional probability p(x x , ,x ) t 1 t1 is V. We will model the conditional probability p(x x , ,x ) as a function t 1 t1 of x ,...,x parameterized by some parameter . 1 t1 A parameterized model takes in numerical inputs and therefore we first introduce embeddings or representations fo the words. Let e  Rd be the i embedding of the word i  1,2, ,V. We call [e , ,e ]  RdV the 1 V embedding matrix. The most commonly used model is Transformer [Vaswani et al., ]. In thissubsection,wewillintroducetheinputoutputinterfaceofaTransformer, buttreattheintermediatecomputationintheTransformerasablackbox. We referthestudentstothetransformerpaperormoreadvancedcoursesformore details. As shown in Figure .1, given a document (x , ,x ), we first 1 T translate the sequence of discrete variables into a sequence of corresponding 4Toseethis,youcanverifythatthefunctionlog p isdecreasinginp,andincreasing pq in q when p,q 0. 5In the practical implementations, typically all the data are concatenated into a single sequenceinsomeorder,andeachexampletypicallycorrespondsasubsequenceofconsec utivewordswhichmaycorrespondstoasubsetofadocumentormayspanacrossmultiple documents. 6Technically,wordsmaybedecomposedintotokenswhichcouldbewordsorsubwords (combinationsofletters),butthisnoteomitsthistechnicality. Infactmostcommonswords are a single token themselves. word embeddings (e , ,e ). We also introduce a fixed special token x1 xT x   in the vocabulary with corresponding embedding e to mark the 0 x0 beginning of a document. Then, the word embeddings are passed into a Transformer model, which takes in a sequence of vectors (e ,e , ,e ) x0 x1 xT and outputs a sequence of vectors (u ,u , ,u ), where u  RV will be 1 2 T1 t interpreted as the logits for the probability distribution of the next word. Here we use the autoregressive version of the Transformers which by design ensures u only depends on x , ,x (note that this property does not t 1 t1 hold in masked language models [Devlin et al., ] where the losses are also different.) We view the whole mapping from xs to us a blackbox in this subsection and call it a Transformer, denoted it by f , where  include  both the parameters in the Transformer and the input embeddings. We write u  f (x ,x ,...,x ) where f denotes the mapping from the input to the t  0 1 t1  outputs.  !       (! Transformer  ()     !           !   Figure .1: The inputs and outputs of a Transformer model. Theconditionalprobabilityp(x x , ,x )isthesofttmaxofthelogits: t 1 t1   p(x  1x  ,x ) t 1 t1 p(x  2x  ,x )  t 1 . t1   softmax(u )  RV (.6)  .  t .   p(x  Vx  ,x ) t 1 t1  softmax(f (x ,...,x )) (.7)  0 t1 We train the Transformer parameter  by minimizing the negative log likelihood of seeing the data under the probabilistic model defined by , which is the crossentropy loss on the logitis. T 1 (cid:) loss()  log(p (x x ,...,x )) (.8)  t 1 t1 T t1 T 1 (cid:)  (cid:) (f (x ,x , ,x ),x ) ce  0 1 t1 t T t1 T 1 (cid:)  log(softmax(f (x ,x , ,x )) ). T  0 1 t1 xt t1 Autoregressive text decoding  generation. Given a autoregressive Transformer, we can simply sample text from it sequentially. Given a pre fix x ,...x , we generate text completion x ,...x sequentially using the 1 t t1 T conditional distribution. x  softmax(f (x ,x , ,x )) (.9) t1  0 1 t x  softmax(f (x ,x , ,x )) (.) t2  0 1 t1 ... (.) x  softmax(f (x ,x , ,x )). (.) T  0 1 T1 Note that each generated token is used as the input to the model when gen erating the following tokens. In practice, people often introduce a parameter   0 named temperature to further adjust the entropysharpness of the generated distribution, x  softmax(f (x ,x , ,x )) (.) t1  0 1 t x  softmax(f (x ,x , ,x )) (.) t2  0 1 t1 ... (.) x  softmax(f (x ,x , ,x )). (.) T  0 1 T1 When   1, the text is sampled from the original conditional probability defined by the model. With a decreasing , the generated text gradually becomes more deterministic.   0 reduces to greedy decoding, where we generate the most probable next token from the conditional probability. .3.1 Zeroshot learning and incontext learning For language models, there are many ways to adapt a pretrained model to downstream tasks. In this notes, we discuss three of them: finetuning, zero shot learning, and incontext learning. Finetuning is not very common for the autoregressive language models that we introduced in Section .3 but much more common for other variants such as masked language models which has similar inputoutput interfaces but are pretrained differently [Devlin et al., ]. The finetuning method is the same as introduced generally in Section .1the only question is how we define the prediction task with an additional linear head. One option is to treat c   (x , ,x ) as the representation and use w(cid:)c  T1  1 T T1 w(cid:) (x , ,x ) to predict task label. As described in Section .1, we  1 T  initialize  to the pretrained model  and then optimize both w and . Zeroshot adaptation or zeroshot learning is the setting where there is no inputoutput pairs from the downstream tasks. For language problems tasks, typically the task is formatted as a question or a cloze test form via natural language. For example, we can format an example as a question: x  (x , ,x )  Is the speed of light a universal constant? task task,1 task,T Then, we compute the most likely next word predicted by the lan guage model given this question, that is, computing argmax p(x  xT1 T1 x , ,x ). In this case, if the most likely next word x is No, task,1 task,T T1 then we solve the task. (The speed of light is only a constant in vacuum). We note that there are many ways to decode the answer from the language models, e.g., instead of computing the argmax, we may use the language model to generate a few words word. It is an active research question to find the best way to utilize the language models. Incontext learning is mostly used for fewshot settings where we have a fewlabeledexamples(x(1) ,y(1) ), ,(x(n task ),y(n task )). Givenatestexample task task task task x , we construct a document (x , ,x ), which is more commonly called test 1 T a prompt in this context, by concatenating the labeled examples and the text example in some format. For example, we may construct the prompt as follows (1) x , ,x  Q: 2  3  ? x 1 T task (1) A: 5 y task (2) Q: 6  7  ? x task (2) A: y task  Q:  2  ? x test Then, we let the pretrained model generate the most likely x ,x , . T1 T2 In this case, if the model can learn that the symbol  means addition from the few examples, we will obtain the following which suggests the answer is . x ,x ,  A: . T1 T2 The area of foundation models is very new and quickly growing. The notes here only attempt to introduce these models on a conceptual level with a significant amount of simplification. We refer the readers to other materials, e.g., Bommasani et al. [], for more details. Part V Reinforcement Learning and Control Chapter Reinforcement learning We now begin our study of reinforcement learning and adaptive control. Insupervisedlearning, wesawalgorithmsthattriedtomaketheiroutputs mimic the labels y given in the training set. In that setting, the labels gave an unambiguous right answer for each of the inputs x. In contrast, for many sequential decision making and control problems, it is very difficult to providethistypeofexplicitsupervisiontoalearningalgorithm. Forexample, if we have just built a fourlegged robot and are trying to program it to walk, then initially we have no idea what the correct actions to take are to make it walk, and so do not know how to provide explicit supervision for a learning algorithm to try to mimic. In the reinforcement learning framework, we will instead provide our al gorithms only a reward function, which indicates to the learning agent when it is doing well, and when it is doing poorly. In the fourlegged walking ex ample, the reward function might give the robot positive rewards for moving forwards, and negative rewards for either moving backwards or falling over. Itwillthenbethelearningalgorithmsjobtofigureouthowtochooseactions over time so as to obtain large rewards. Reinforcement learning has been successful in applications as diverse as autonomous helicopter flight, robot legged locomotion, cellphone network routing, marketing strategy selection, factory control, and efficient webpage indexing. Our study of reinforcement learning will begin with a definition of the Markov decision processes (MDP), which provides the formalism in which RL problems are usually posed. .1 Markov decision processes A Markov decision process is a tuple (S,A,P ,,R), where: sa  S is a set of states. (For example, in autonomous helicopter flight, S might be the set of all possible positions and orientations of the heli copter.)  A is a set of actions. (For example, the set of all possible directions in which you can push the helicopters control sticks.)  P are the state transition probabilities. For each state s  S and sa action a  A, P is a distribution over the state space. Well say more sa about this later, but briefly, P gives the distribution over what states sa we will transition to if we take action a in state s.    [0,1) is called the discount factor.  R : S A (cid:) R is the reward function. (Rewards are sometimes also written as a function of a state S only, in which case we would have R : S (cid:) R). The dynamics of an MDP proceeds as follows: We start in some state s , 0 and get to choose some action a  A to take in the MDP. As a result of our 0 choice, the state of the MDP randomly transitions to some successor state s , drawn according to s  P . Then, we get to pick another action a . 1 1 s0a0 1 As a result of this action, the state transitions again, now to some s  P . 2 s1a1 We then pick a , and so on.... Pictorially, we can represent this process as 2 follows: s  a 0 s  a 1 s  a 2 s  a 3 ... 0 1 2 3 Upon visiting the sequence of states s ,s ,... with actions a ,a ,..., our 0 1 0 1 total payoff is given by R(s ,a )R(s ,a )2R(s ,a ) . 0 0 1 1 2 2 Or, whenwearewritingrewardsasafunctionofthestatesonly, thisbecomes R(s )R(s )2R(s ) . 0 1 2 For most of our development, we will use the simpler staterewards R(s), though the generalization to stateaction rewards R(s,a) offers no special difficulties. Our goal in reinforcement learning is to choose actions over time so as to maximize the expected value of the total payoff: (cid:2) (cid:3) E R(s )R(s )2R(s ) 0 1 2 Note that the reward at timestep t is discounted by a factor of t. Thus, to make this expectation large, we would like to accrue positive rewards as soon as possible (and postpone negative rewards as long as possible). In economic applications where R() is the amount of money made,  also has a natural interpretation in terms of the interest rate (where a dollar today is worth more than a dollar tomorrow). A policy is any function  : S (cid:) A mapping from the states to the actions. We say that we are executing some policy  if, whenever we are in state s, we take action a  (s). We also define the value function for a policy  according to (cid:2) (cid:) V(s)  E R(s )R(s )2R(s )(cid:)s  s,]. 0 1 2 0 V(s) is simply the expected sum of discounted rewards upon starting in state s, and taking actions according to .1 Given a fixed policy , its value function V satisfies the Bellman equa tions: (cid:) V(s)  R(s) P (s(cid:))V(s(cid:)). s(s) s(cid:)S This says that the expected sum of discounted rewards V(s) for starting in s consists of two terms: First, the immediate reward R(s) that we get right away simply for starting in state s, and second, the expected sum of future discounted rewards. Examining the second term in more detail, we see that the summation term above can be rewritten E [V(s(cid:))]. This s(cid:)P s(s) is the expected sum of discounted rewards for starting in state s(cid:), where s(cid:) is distributed according P , which is the distribution over where we will s(s) end up after taking the first action (s) in the MDP from state s. Thus, the second term above gives the expected sum of discounted rewards obtained after the first step in the MDP. Bellmans equations can be used to efficiently solve for V. Specifically, in a finitestate MDP (S  ), we can write down one such equation for V(s) for every state s. This gives us a set of S linear equations in S variables (the unknown V(s)s, one for each state), which can be efficiently solved for the V(s)s. 1This notation in which we condition on  isnt technically correct because  isnt a random variable, but this is quite standard in the literature. We also define the optimal value function according to V(s)  maxV(s). (.1)  In other words, this is the best possible expected sum of discounted rewards that can be attained using any policy. There is also a version of Bellmans equations for the optimal value function: (cid:) V(s)  R(s)max P (s(cid:))V(s(cid:)). (.2) sa aA s(cid:)S The first term above is the immediate reward as before. The second term is the maximum over all actions a of the expected future sum of discounted rewards well get upon after action a. You should make sure you understand this equation and see why it makes sense. We also define a policy  : S (cid:) A as follows: (cid:) (s)  argmax P (s(cid:))V(s(cid:)). (.3) sa aA s(cid:)S Note that (s) gives the action a that attains the maximum in the max in Equation (.2). It is a fact that for every state s and every policy , we have V(s)  V(s)  V(s). The first equality says that the V, the value function for , is equal to the optimal value function V for every state s. Further, the inequality above says that s value is at least a large as the value of any other other policy. In other words,  as defined in Equation (.3) is the optimal policy. Note that  has the interesting property that it is the optimal policy for all states s. Specifically, it is not the case that if we were starting in some state s then thered be some optimal policy for that state, and if we were starting in some other state s(cid:) then thered be some other policy thats optimal policy for s(cid:). The same policy  attains the maximum in Equa tion (.1) for all states s. This means that we can use the same policy  no matter what the initial state of our MDP is. .2 Value iteration and policy iteration We now describe two efficient algorithms for solving finitestate MDPs. For now, we will consider only MDPs with finite state and action spaces (S  , A  ). In this section, we will also assume that we know the state transition probabilities P  and the reward function R. sa The first algorithm, value iteration, is as follows: Algorithm 4 Value Iteration 1: For each state s, initialize V(s) : 0. 2: for until convergence do 3: For every state, update (cid:) V(s) : R(s)max P (s(cid:))V(s(cid:)). (.4) sa aA s(cid:) This algorithm can be thought of as repeatedly trying to update the estimated value function using Bellman Equations (.2). Therearetwopossiblewaysofperformingtheupdatesintheinnerloopof the algorithm. In the first, we can first compute the new values for V(s) for every state s, and then overwrite all the old values with the new values. This iscalledasynchronousupdate. Inthiscase, thealgorithmcanbeviewedas implementing a Bellman backup operator that takes a current estimate of the value function, and maps it to a new estimate. (See homework problem for details.) Alternatively, we can also perform asynchronous updates. Here, we would loop over the states (in some order), updating the values one at a time. Under either synchronous or asynchronous updates, it can be shown that value iteration will cause V to converge to V. Having found V, we can then use Equation (.3) to find the optimal policy. Apart from value iteration, there is a second standard algorithm for find ing an optimal policy for an MDP. The policy iteration algorithm proceeds as follows: Thus, the innerloop repeatedly computes the value function for the cur rent policy, and then updates the policy using the current value function. (The policy  found in step (b) is also called the policy that is greedy with respect to V.) Note that step (a) can be done via solving Bellmans equa tions as described earlier, which in the case of a fixed policy, is just a set of S linear equations in S variables. After at most a finite number of iterations of this algorithm, V will con verge to V, and  will converge to .2 2Note that value iteration cannot reach the exact V in a finite number of iterations, Algorithm 5 Policy Iteration 1: Initialize  randomly. 2: for until convergence do 3: Let V : V. (cid:) typically by linear system solver 4: For each state s, let (cid:) (s) : argmax P (s(cid:))V(s(cid:)). sa aA s(cid:) Both value iteration and policy iteration are standard algorithms for solv ing MDPs, and there isnt currently universal agreement over which algo rithm is better. For small MDPs, policy iteration is often very fats and converges with very few iterations. However, for MDPs with large state spaces, solving for V explicitly would involve solving a large system of lin ear equations, and could be difficult (and note that one has to solve the linear system multiple times in policy iteration). In these problems, value iteration may be preferred. For this reason, in practice value iteration seems to be used more often than policy iteration. For some more discussions on the comparison and connection of value iteration and policy iteration, please see Section .5. .3 Learning a model for an MDP So far, we have discussed MDPs and algorithms for MDPs assuming that the state transition probabilities and rewards are known. In many realistic prob lems, we are not given state transition probabilities and rewards explicitly, but must instead estimate them from data. (Usually, S,A and  are known.) For example, suppose that, for the inverted pendulum problem (see prob whereas policy iteration with an exact linear system solver, can. This is because when the actions space and policy space are discrete and finite, and once the policy reaches the optimal policy in policy iteration, then it will not change at all. On the other hand, even though value iteration will converge to the V, but there is always some nonzero error in the learned value function. lem set 4), we had a number of trials in the MDP, that proceeded as follows: s(1)  a( 0 1) s(1)  a( 1 1) s(1)  a( 2 1) s(1)  a( 3 1) ... 0 1 2 3 s(2)  a( 0 2) s(2)  a( 1 2) s(2)  a( 2 2) s(2)  a( 3 2) ... 0 1 2 3 ... Here, s(j) is the state we were at time i of trial j, and a(j) is the cor i i responding action that was taken from that state. In practice, each of the trials above might be run until the MDP terminates (such as if the pole falls over in the inverted pendulum problem), or it might be run for some large but finite number of timesteps. Given this experience in the MDP consisting of a number of trials, we can then easily derive the maximum likelihood estimates for the state transition probabilities: times took we action a in state s and got to s(cid:) P (s(cid:))  (.5) sa times we took action a in state s Or, if the ratio above is 00corresponding to the case of never having taken action a in state s beforethe we might simply estimate P (s(cid:)) to be sa 1S. (I.e., estimate P to be the uniform distribution over all states.) sa Note that, if we gain more experience (observe more trials) in the MDP, there is an efficient way to update our estimated state transition probabilities using the new experience. Specifically, if we keep around the counts for both the numerator and denominator terms of (.5), then as we observe more trials, we can simply keep accumulating those counts. Computing the ratio of these counts then given our estimate of P . sa Using a similar procedure, if R is unknown, we can also pick our estimate of the expected immediate reward R(s) in state s to be the average reward observed in state s. Having learned a model for the MDP, we can then use either value it eration or policy iteration to solve the MDP using the estimated transition probabilities and rewards. For example, putting together model learning and value iteration, here is one possible algorithm for learning in an MDP with unknown state transition probabilities: 1. Initialize  randomly. 2. Repeat  (a) Execute  in the MDP for some number of trials. (b) Using the accumulated experience in the MDP, update our esti mates for P (and R, if applicable). sa (c) Apply value iteration with the estimated state transition probabil ities and rewards to get a new estimated value function V. (d) Update  to be the greedy policy with respect to V.  We note that, for this particular algorithm, there is one simple optimiza tion that can make it run much more quickly. Specifically, in the inner loop ofthealgorithmwhereweapplyvalueiteration, ifinsteadofinitializingvalue iteration with V  0, we initialize it with the solution found during the pre vious iteration of our algorithm, then that will provide value iteration with a much better initial starting point and make it converge more quickly. .4 Continuous state MDPs So far, weve focused our attention on MDPs with a finite number of states. We now discuss algorithms for MDPs that may have an infinite number of  states. For example, fora car, we mightrepresent thestate as(x,y,,x,y,), comprising its position (x,y); orientation ; velocity in the x and y directions x and y; and angular velocity   . Hence, S  R6 is an infinite set of states, because there is an infinite number of possible positions and orientations for the car.3 Similarly, the inverted pendulum you saw in PS4 has states  (x,,x,), where  is the angle of the pole. And, a helicopter flying in 3d    space has states of the form (x,y,z,,,,x,y,z,,,), where here the roll , pitch , and yaw  angles specify the 3d orientation of the helicopter. In this section, we will consider settings where the state space is S  Rd, and describe ways for solving such MDPs. .4.1 Discretization Perhaps the simplest way to solve a continuousstate MDP is to discretize the state space, and then to use an algorithm like value iteration or policy iteration, as described previously. For example, if we have 2d states (s ,s ), we can use a grid to discretize 1 2 the state space: 3Technically, isanorientationandsotherangeof isbetterwritten [,)than  R; but for our purposes, this distinction is not important. [t] Here, each grid cell represents a separate discrete state s. We can then approximate the continuousstate MDP via a discretestate one   (S,A,P ,,R), where S is the set of discrete states, P  are our state sa sa transition probabilities over the discrete states, and so on. We can then use value iteration or policy iteration to solve for the V(s) and (s) in the  discrete state MDP (S,A,P ,,R). When our actual system is in some sa continuousvalued state s  S and we need to pick an action to execute, we compute the corresponding discretized state s, and execute action (s). This discretization approach can work well for many problems. However, there are two downsides. First, it uses a fairly naive representation for V (and ). Specifically, it assumes that the value function is takes a constant value over each of the discretization intervals (i.e., that the value function is piecewise constant in each of the gridcells). To better understand the limitations of such a representation, consider a supervised learning problem of fitting a function to this dataset: 5.5 5 4.5 4 3.5 3 2.5 2 1.5 [t] 1 2 3 4 5 6 7 8 x y Clearly, linear regression would do fine on this problem. However, if we instead discretize the xaxis, and then use a representation that is piecewise constant in each of the discretization intervals, then our fit to the data would look like this: 5.5 5 4.5 4 3.5 3 2.5 2 1.5 [t] 1 2 3 4 5 6 7 8 x y Thispiecewiseconstantrepresentationjustisntagoodrepresentationfor many smooth functions. It results in little smoothing over the inputs, and no generalization over the different grid cells. Using this sort of representation, we would also need a very fine discretization (very small grid cells) to get a good approximation. A second downside of this representation is called the curse of dimen sionality. SupposeS  Rd, andwediscretizeeachof theddimensionsof the state into k values. Then the total number of discrete states we have is kd. This grows exponentially quickly in the dimension of the state space d, and thus does not scale well to large problems. For example, with a 10d state, if we discretize each state variable into values, we would have  discrete states, which is far too many to represent even on a modern desktop computer. As a rule of thumb, discretization usually works extremely well for 1d and 2d problems (and has the advantage of being simple and quick to im plement). Perhaps with a little bit of cleverness and some care in choosing the discretization method, it often works well for problems with up to 4d states. If youre extremely clever, and somewhat lucky, you may even get it to work for some 6d problems. But it very rarely works for problems any higher dimensional than that. .4.2 Value function approximation We now describe an alternative method for finding policies in continuous state MDPs, in which we approximate V directly, without resorting to dis cretization. This approach, called value function approximation, has been successfully applied to many RL problems. Using a model or simulator To develop a value function approximation algorithm, we will assume that we have a model, or simulator, for the MDP. Informally, a simulator is a blackbox that takes as input any (continuousvalued) state s and action t a , and outputs a nextstate s sampled according to the state transition t t1 probabilities P : stat [t] There are several ways that one can get such a model. One is to use physics simulation. For example, the simulator for the inverted pendulum in PS4 was obtained by using the laws of physics to calculate what position and orientation the cartpole will be in at time t1, given the current state at time t and the action a taken, assuming that we know all the parameters of the system such as the length of the pole, the mass of the pole, and so on. Alternatively,onecanalsouseanofftheshelfphysicssimulationsoftware package which takes as input a complete physical description of a mechanical system, the current state s and action a , and computes the state s of the t t t1 system a small fraction of a second into the future.4 An alternative way to get a model is to learn one from data collected in the MDP. For example, suppose we execute n trials in which we repeatedly take actions in an MDP, each trial for T timesteps. This can be done picking actions at random, executing some specific policy, or via some other way of 4Open Dynamics Engine (http:www.ode.com) is one example of a freeopensource physics simulator that can be used to simulate systems like the inverted pendulum, and that has been a reasonably popular choice among RL researchers. choosing actions. We would then observe n state sequences like the following: s(1)  a( 0 1) s(1)  a( 1 1) s(1)  a( 2 1)  a  ( T 1  ) 1 s(1) 0 1 2 T s(2)  a( 0 2) s(2)  a( 1 2) s(2)  a( 2 2)  a  ( T 2  ) 1 s(2) 0 1 2 T  s(n)  a 0 (  n) s(n)  a( 1 n) s(n)  a( 2 n)  a  ( T n  ) 1 s(n) 0 1 2 T We can then apply a learning algorithm to predict s as a function of s t1 t and a . t For example, one may choose to learn a linear model of the form s  As Ba , (.6) t1 t t using an algorithm similar to linear regression. Here, the parameters of the model are the matrices A and B, and we can estimate them using the data collected from our n trials, by picking (cid:) n (cid:) T1(cid:) (cid:) (cid:)(cid:)2 argmin (cid:)s(i)  As(i) Ba(i) (cid:) . (cid:) t1 t t (cid:) A,B 2 i1 t0 We could also potentially use other loss functions for learning the model. For example, it has been found in recent work Luo et al. [] that using (cid:)(cid:) norm (without the square) may be helpful in certain cases. 2 Having learned A and B, one option is to build a deterministic model, in which given an input s and a , the output s is exactly determined. t t t1 Specifically, we always compute s according to Equation (.6). Alter t1 natively, we may also build a stochastic model, in which s is a random t1 function of the inputs, by modeling it as s  As Ba (cid:) , t1 t t t where here (cid:) is a noise term, usually modeled as (cid:)  N(0,). (The covari t t ance matrix  can also be estimated from data in a straightforward way.) Here, weve written the nextstate s as a linear function of the current t1 state and action; but of course, nonlinear functions are also possible. Specif ically, one can learn a model s  A (s )B (a ), where  and  are t1 s t a t s a some nonlinear feature mappings of the states and actions. Alternatively, one can also use nonlinear learning algorithms, such as locally weighted lin ear regression, to learn to estimate s as a function of s and a . These t1 t t approaches can also be used to build either deterministic or stochastic sim ulators of an MDP. Fitted value iteration We now describe the fitted value iteration algorithm for approximating the value function of a continuous state MDP. In the sequel, we will assume that the problem has a continuous state space S  Rd, but that the action space A is small and discrete.5 Recall that in value iteration, we would like to perform the update (cid:) V(s) : R(s)max P (s(cid:))V(s(cid:))ds(cid:) (.7) sa a s(cid:)  R(s)maxE [V(s(cid:))] (.8) a s(cid:)Psa (InSection15.2, wehadwrittenthevalueiterationupdatewithasummation V(s) : R(s)max (cid:) P (s(cid:))V(s(cid:)) rather than an integral over states; a s(cid:) sa the new notation reflects that we are now working in continuous states rather than discrete states.) The main idea of fitted value iteration is that we are going to approxi mately carry out this step, over a finite sample of states s(1),...,s(n). Specif ically, we will use a supervised learning algorithmlinear regression in our descriptionbelowtoapproximatethevaluefunctionasalinearornonlinear function of the states: V(s)  T(s). Here,  is some appropriate feature mapping of the states. For each state s in our finite sample of n states, fitted value iteration will first compute a quantity y(i), which will be our approximation to R(s) max E [V(s(cid:))] (the right hand side of Equation .8). Then, it will a s(cid:)Psa apply a supervised learning algorithm to try to get V(s) close to R(s)  max E [V(s(cid:))] (or, in other words, to try to get V(s) close to y(i)). a s(cid:)Psa In detail, the algorithm is as follows: 1. Randomly sample n states s(1),s(2),...s(n)  S. 2. Initialize  : 0. 3. Repeat  For i  1,...,n  5Inpractice,mostMDPshavemuchsmalleractionspacesthanstatespaces. E.g.,acar has a 6d state space, and a 2d action space (steering and velocity controls); the inverted pendulum has a 4d state space, and a 1d action space; a helicopter has a 12d state space, and a 4d action space. So, discretizing this set of actions is usually less of a problem than discretizing the state space would have been. For each action a  A  Sample s(cid:),...,s(cid:)  P (using a model of the MDP). 1 k s(i)a Set q(a)  1 (cid:)k R(s(i))V(s(cid:)) k j1 j  Hence, q(a) is an estimate of R(s(i))  E [V(s(cid:))]. s(cid:)P s(i)a  Set y(i)  max q(a). a  Hence, y(i) is an estimate of R(s(i))  max E [V(s(cid:))]. a s(cid:)P s(i)a   In the original value iteration algorithm (over discrete states)  we updated the value function according to V(s(i)) : y(i).  In this algorithm, we want V(s(i))  y(i), which well achieve  using supervised learning (linear regression). Set  : argmin 1 (cid:)n (cid:0) T(s(i))y(i) (cid:1)2  2 i1  Above, we had written out fitted value iteration using linear regression as the algorithm to try to make V(s(i)) close to y(i). That step of the algo rithm is completely analogous to a standard supervised learning (regression) problem in which we have a training set (x(1),y(1)),(x(2),y(2)),...,(x(n),y(n)), and want to learn a function mapping from x to y; the only difference is that here s plays the role of x. Even though our description above used linear re gression, clearly other regression algorithms (such as locally weighted linear regression) can also be used. Unlike value iteration over a discrete set of states, fitted value iteration cannot be proved to always to converge. However, in practice, it often does converge (or approximately converge), and works well for many problems. Note also that if we are using a deterministic simulatormodel of the MDP, then fitted value iteration can be simplified by setting k  1 in the algorithm. This is because the expectation in Equation (.8) becomes an expectation over a deterministic distribution, and so a single example is sufficient to exactly compute that expectation. Otherwise, in the algorithm above, we had to draw k samples, and average to try to approximate that expectation (see the definition of q(a), in the algorithm pseudocode). Finally, fitted value iteration outputs V, which is an approximation to V. This implicitly defines our policy. Specifically, when our system is in some state s, and we need to choose an action, we would like to choose the action argmaxE [V(s(cid:))] (.9) a s(cid:)Psa The process for computingapproximating this is similar to the innerloop of fitted value iteration, where for each action, we sample s(cid:),...,s(cid:)  P to 1 k sa approximate the expectation. (And again, if the simulator is deterministic, we can set k  1.) In practice, there are often other ways to approximate this step as well. For example, one very common case is if the simulator is of the form s  t1 f(s ,a )  (cid:) , where f is some deterministic function of the states (such as t t t f(s ,a )  As Ba ), and (cid:) is zeromean Gaussian noise. In this case, we t t t t can pick the action given by argmaxV(f(s,a)). a In other words, here we are just setting (cid:)  0 (i.e., ignoring the noise in t the simulator), and setting k  1. Equivalent, this can be derived from Equation (.9) using the approximation E [V(s(cid:))]  V(E [s(cid:)]) (.) s(cid:) s(cid:)  V(f(s,a)), (.) where here the expectation is over the random s(cid:)  P . So long as the noise sa terms (cid:) are small, this will usually be a reasonable approximation. t However,forproblemsthatdontlendthemselvestosuchapproximations, having to sample kA states using the model, in order to approximate the expectation above, can be computationally expensive. .5 Connections between Policy and Value Iteration (Optional) In the policy iteration, line 3 of Algorithm 5, we typically use linear system solver to compute V. Alternatively, one can also the iterative Bellman updates, similarly to the value iteration, to evaluate V, as in the Procedure VE() in Line 1 of Algorithm 6 below. Here if we take option 1 in Line 2 of the Procedure VE, then the difference between the Procedure VE from the Algorithm 6 Variant of Policy Iteration 1: procedure VE(, k) (cid:) To evaluate V 2: Option 1: initialize V(s) : 0; Option 2: Initialize from the current V in the main algorithm. 3: for i  0 to k 1 do 4: For every state s, update (cid:) V(s) : R(s) P (s(cid:))V(s(cid:)). (.) s(s) s(cid:) return V 5: Require: hyperparameter k. 6: Initialize  randomly. 7: for until convergence do 8: Let V  VE(,k). 9: For each state s, let (cid:) (s) : argmax P (s(cid:))V(s(cid:)). (.) sa aA s(cid:) value iteration (Algorithm 4) is that on line 4, the procedure is using the action from  instead of the greedy action. Using the Procedure VE, we can build Algorithm 6, which is a variant of policy iteration that serves an intermediate algorithm that connects pol icy iteration and value iteration. Here we are going to use option 2 in VE to maximize the reuse of knowledge learned before. One can verify indeed that if we take k  1 and use option 2 in Line 2 in Algorithm 6, then Algo rithm 6 is semantically equivalent to value iteration (Algorithm 4). In other words, both Algorithm 6 and value iteration interleave the updates in (.) and (.). Algorithm 6 alternate between k steps of update (.) and one step of (.), whereas value iteration alternates between 1 steps of up date (.) and one step of (.). Therefore generally Algorithm 6 should not be faster than value iteration, because assuming that update (.) and (.) are equally useful and timeconsuming, then the optimal balance of the update frequencies could be just k  1 or k  1. On the other hand, if k steps of update (.) can be done much faster than k times a single step of (.), then taking additional steps of equa tion (.) in group might be useful. This is what policy iteration is lever aging  the linear system solver can give us the result of Procedure VE with k   much faster than using the Procedure VE for a large k. On the flip side, when such a speedingup effect no longer exists, e.g.,, when the state space is large and linear system solver is also not fast, then value iteration is more preferable. Chapter LQR, DDP and LQG .1 Finitehorizon MDPs In Chapter , we defined Markov Decision Processes (MDPs) and covered Value Iteration  Policy Iteration in a simplified setting. More specifically we introduced the optimal Bellman equation that defines the optimal value function V of the optimal policy . (cid:) V(s)  R(s)max P (s(cid:))V(s(cid:)) sa aA s(cid:)S Recall that from the optimal value function, we were able to recover the optimal policy  with (cid:) (s)  argmax P (s(cid:))V(s(cid:)) aA sa s(cid:)S In this chapter, well place ourselves in a more general setting: 1. We want to write equations that make sense for both the discrete and the continuous case. Well therefore write E (cid:2) V(s(cid:)) (cid:3) instead of s(cid:)Psa (cid:) P (s(cid:))V(s(cid:)) sa s(cid:)S meaning that we take the expectation of the value function at the next state. In the finite case, we can rewrite the expectation as a sum over states. In the continuous case, we can rewrite the expectation as an integral. The notation s(cid:)  P means that the state s(cid:) is sampled from sa the distribution P . sa 2. Well assume that the rewards depend on both states and actions. In other words, R : SA  R. This implies that the previous mechanism for computing the optimal action is changed into (s)  argmax R(s,a)E (cid:2) V(s(cid:)) (cid:3) aA s(cid:)Psa 3. Instead of considering an infinite horizon MDP, well assume that we have a finite horizon MDP that will be defined as a tuple (S,A,P ,T,R) sa with T  0 the time horizon (for instance T  ). In this setting, our definition of payoff is going to be (slightly) different: R(s ,a )R(s ,a )R(s ,a ) 0 0 1 1 T T instead of (infinite horizon case) R(s ,a )R(s ,a )2R(s ,a )... 0 0 1 1 2 2  (cid:) R(s ,a )t t t t0 What happened to the discount factor ? Remember that the intro duction of  was (partly) justified by the necessity of making sure that the infinite sum would be finite and welldefined. If the rewards are  bounded by a constant R, the payoff is indeed bounded by   (cid:) (cid:)  R(s )t  R  t t t0 t0 and we recognize a geometric sum! Here, as the payoff is a finite sum, the discount factor  is not necessary anymore. In this new setting, things behave quite differently. First, the optimal policy mightbenonstationary, meaningthatit changes over time. In other words, now we have (t) : S  A where the superscript (t) denotes the policy at time step t. The dynam ics of the finite horizon MDP following policy (t) proceeds as follows: we start in some state s , take some action a : (0)(s ) according to 0 0 0 our policy at time step 0. The MDP transitions to a successor s , drawn 1 according to P . Then, we get to pick another action a : (1)(s ) s0a0 1 1 following our new policy at time step 1 and so on... Why does the optimal policy happen to be nonstationary in the finite horizon setting? Intuitively, as we have a finite numbers of actions to take, we might want to adopt different strategies depending on where we are in the environment and how much time we have left. Imagine a grid with 2 goals with rewards 1 and . At the beginning, we might want to take actions to aim for the  goal. But if after some steps, dynamics somehow pushed us closer to the 1 goal and we dont have enough steps left to be able to reach the  goal, then a better strategy would be to aim for the 1 goal... 4. This observation allows us to use time dependent dynamics s  P(t) t1 st,at meaning that the transitions distribution P(t) changes over time. The st,at same thing can be said about R(t). Note that this setting is a better model for real life. In a car, the gas tank empties, traffic changes, etc. Combining the previous remarks, well use the following general formulation for our finite horizon MDP (cid:0) (cid:1) S,A,P(t),T,R(t) sa Remark: notice that the above formulation would be equivalent to adding the time into the state. The value function at time t for a policy  is then defined in the same way as before, as an expectation over trajectories generated following policy  starting in state s. V (s)  E(cid:2) R(t)(s ,a )R(T)(s ,a )s  s, (cid:3) t t t T T t Now, the question is In this finitehorizon setting, how do we find the optimal value function V(s)  maxV(s) t t  It turns out that Bellmans equation for Value Iteration is made for Dy namic Programming. This may come as no surprise as Bellman is one of the fathers of dynamic programming and the Bellman equation is strongly related to the field. To understand how we can simplify the problem by adopting an iterationbased approach, we make the following observations: 1. Notice that at the end of the game (for time step T), the optimal value is obvious s  S : V(s) : maxR(T)(s,a) (.1) T aA 2. For another time step 0  t  T, if we suppose that we know the optimal value function for the next time step V , then we have t1 (cid:) (cid:) t  T,s  S : V(s) : max R(t)(s,a)E (cid:2) V (s(cid:)) (cid:3) (.2) t aA s(cid:)Ps ( a t) t1 With these observations in mind, we can come up with a clever algorithm to solve for the optimal value function: 1. compute V using equation (.1). T 2. for t  T 1,...,0: compute V using V using equation (.2) t t1 Side note We can interpret standard value iteration as a special case of this general case, but without keeping track of time. It turns out that in the standard setting, if we run value iteration for T steps, we get a T approximation of the optimal value iteration (geometric convergence). See problem set 4 for a proof of the following result: Theorem Let B denote the Bellman update and f(x) : sup f(x).  x If V denotes the value function at the tth step, then t V V  B(V )V t1  t   V V t   tV V 1  In other words, the Bellman operator B is a contracting operator. .2 Linear Quadratic Regulation (LQR) Inthissection, wellcoveraspecialcaseofthefinitehorizonsettingdescribed in Section .1, for which the exact solution is (easily) tractable. This model is widely used in robotics, and a common technique in many problems is to reduce the formulation to this framework. First, lets describe the models assumptions. We place ourselves in the continuous setting, with S  Rd, A  Rd and well assume linear transitions (with noise) s  A s B a w t1 t t t t t where A  Rdd,B  Rdd are matrices and w  N(0, ) is some t t t t gaussian noise (with zero mean). As well show in the following paragraphs, it turns out that the noise, as long as it has zero mean, does not impact the optimal policy! Well also assume quadratic rewards R(t)(s ,a )  s(cid:)U s a(cid:)W a t t t t t t t t where U  Rdn,W  Rdd are positive definite matrices (meaning that t t the reward is always negative). Remark Note that the quadratic formulation of the reward is equivalent to saying that we want our state to be close to the origin (where the reward is higher). For example, if U  I (the identity matrix) and W  I , then t d t d R  s 2 a 2, meaning that we want to take smooth actions (small t t t norm of a ) to go back to the origin (small norm of s ). This could model a t t car trying to stay in the middle of lane without making impulsive moves... Now that we have defined the assumptions of our LQR model, lets cover the 2 steps of the LQR algorithm step 1 suppose that we dont know the matrices A,B,. To esti mate them, we can follow the ideas outlined in the Value Ap proximation section of the RL notes. First, collect transitions from an arbitrary policy. Then, use linear regression to find (cid:) (cid:) (cid:)(cid:)2 argmin (cid:)n (cid:)T1(cid:)s(i)  As(i) Ba(i) (cid:) . Finally, use a tech A,B i1 t0 (cid:) t1 t t (cid:) nique seen in Gaussian Discriminant Analysis to learn . step 2 assuming that the parameters of our model are known (given or esti mated with step 1), we can derive the optimal policy using dynamic programming. In other words, given (cid:) s  A s B a w A ,B ,U ,W , known t1 t t t t t t t t t t R(t)(s ,a )  s(cid:)U s a(cid:)W a t t t t t t t t we want to compute V. If we go back to section .1, we can apply t dynamic programming, which yields 1. Initialization step For the last time step T, V(s )  maxR (s ,a ) T T T T T aTA  maxs(cid:)U s a(cid:)W a T T T T t T aTA  s(cid:)U s (maximized for a  0) T t T T 2. Recurrence step Let t  T. Suppose we know V . t1 Fact 1: It can be shown that if V is a quadratic function in s , then V t1 t t is also a quadratic function. In other words, there exists some matrix  and some scalar  such that if V (s )  s(cid:)  s  t1 t1 t1 t1 t1 t1 then V(s )  s(cid:) s  t t t t t t For time step t  T, we had   U and   0. t T T Fact 2: We can show that the optimal policy is just a linear function of the state. Knowing V is equivalent to knowing  and  , so we just need t1 t1 t1 to explain how we compute  and  from  and  and the other t t t1 t1 parameters of the problem. V(s )  s(cid:) s  t t t t t t (cid:) (cid:)  max R(t)(s ,a )E [V (s )] at t t st1Ps ( t t , ) at t1 t1  max (cid:2) s(cid:)U s a(cid:)V a E [s(cid:)  s  ] (cid:3) at t t t t t t st1N(AtstBtat,t) t1 t1 t1 t1 where the second line is just the definition of the optimal value function and the third line is obtained by plugging in the dynamics of our model along with the quadratic assumption. Notice that the last expression is a quadratic function in a and can thus be (easily) optimized1. We get t the optimal action a t (cid:2) (cid:3) a  (B(cid:) B V )1B  A s t t t1 t t t t1 t t  L s t t where (cid:2) (cid:3) L : (B(cid:) B W )1B  A t t t1 t t t t1 t 1Use the identity E(cid:2) w(cid:) w (cid:3) Tr(  ) with w N (0, ) t t1 t t t1 t t which is an impressive result: our optimal policy is linear in s . Given t a we can solve for  and  . We finally get the Discrete Ricatti t t t equations (cid:) (cid:)   A(cid:)   B (cid:0) B(cid:) B W (cid:1)1 B  A U t t t1 t1 t t t1 t t t t1 t t   tr(  ) t t t1 t1 Fact 3: we notice that  depends on neither  nor the noise  ! As L t t t is a function of A ,B and  , it implies that the optimal policy also t t t1 does not depend on the noise! (But  does depend on  , which t t implies that V depends on  .) t t Then, to summarize, the LQR algorithm works as follows 1. (if necessary) estimate parameters A ,B , t t t 2. initialize  : U and  : 0. T T T 3. iterate from t  T  1...0 to update  and  using  and  t t t1 t1 using the discrete Ricatti equations. If there exists a policy that drives the state towards zero, then convergence is guaranteed! Using Fact 3, we can be even more clever and make our algorithm run (slightly) faster! As the optimal policy does not depend on  , and the t update of  only depends on  , it is sufficient to update only  ! t t t .3 From nonlinear dynamics to LQR It turns out that a lot of problems can be reduced to LQR, even if dynamics are nonlinear. While LQR is a nice formulation because we are able to come up with a nice exact solution, it is far from being general. Lets take for instance the case of the inverted pendulum. The transitions between states look like      x x t1 t   x t1   F     x t ,a    t1  t t      t1 t where the function F depends on the cos of the angle etc. Now, the question we may ask is Can we linearize this system? .3.1 Linearization of dynamics Lets suppose that at time t, the system spends most of its time in some state s and the actions we perform are around a. For the inverted pendulum, if t t we reached some kind of optimal, this is true: our actions are small and we dont deviate much from the vertical. We are going to use Taylor expansion to linearize the dynamics. In the simple case where the state is onedimensional and the transition function F does not depend on the action, we would write something like s  F(s )  F(s)F(cid:)(s)(s s) t1 t t t t t In the more general setting, the formula looks the same, with gradients instead of simple derivatives s  F(s,a) F(s,a)(s s) F(s,a)(a a) (.3) t1 t t s t t t t a t t t t andnow, s islinearins anda , becausewecanrewriteequation(.3) t1 t t as s  As Bs  t1 t t where  is some constant and A,B are matrices. Now, this writing looks awfully similar to the assumptions made for LQR. We just have to get rid of the constant term ! It turns out that the constant term can be absorbed into s by artificially increasing the dimension by one. This is the same trick t that we used at the beginning of the class for linear regression... .3.2 Differential Dynamic Programming (DDP) The previous method works well for cases where the goal is to stay around some state s (think about the inverted pendulum, or a car having to stay in the middle of a lane). However, in some cases, the goal can be more complicated. Well cover a method that applies when our system has to follow some trajectory (think about a rocket). This method is going to discretize the trajectory into discrete time steps, and create intermediary goals around which we will be able to use the previous technique! This method is called Differential Dynamic Programming. The main steps are step 1 comeupwithanominaltrajectoryusinganaivecontroller, thatapprox imate the trajectory we want to follow. In other words, our controller is able to approximate the gold trajectory with s,a  s,a  ... 0 0 1 1 step 2 linearize the dynamics around each trajectory point s, in other words t s  F(s,a) F(s,a)(s s) F(s,a)(a a) t1 t t s t t t t a t t t t where s ,a would be our current state and action. Now that we have t t a linear approximation around each of these points, we can use the previous section and rewrite s  A s B a t1 t t t t (notice that in that case, we use the nonstationary dynamics setting that we mentioned at the beginning of these lecture notes) Note We can apply a similar derivation for the reward R(t), with a secondorder Taylor expansion. R(s ,a )  R(s,a) R(s,a)(s s) R(s,a)(a a) t t t t s t t t t a t t t t 1  (s s)(cid:)H (s s)(s s)(cid:)H (a a) 2 t t ss t t t t sa t t 1  (a a)(cid:)H (a a) 2 t t aa t t where H refers to the entry of the Hessian of R with respect to x and xy y evaluated in (s,a) (omitted for readability). This expression can be t t rewritten as R (s ,a )  s(cid:)U s a(cid:)W a t t t t t t t t t for some matrices U ,W , with the same trick of adding an extra dimen t t sion of ones. To convince yourself, notice that (cid:) (cid:) (cid:) (cid:) (cid:0) (cid:1) a b 1 1 x    a2bxcx2 b c x step 3 Now, you can convince yourself that our problem is strictly rewritten in the LQR framework. Lets just use LQR to find the optimal policy  . As a result, our new controller will (hopefully) be better! t Note: Some problems might arise if the LQR trajectory deviates too much from the linearized approximation of the trajectory, but that can be fixed with rewardshaping... step 4 Now that we get a new controller (our new policy  ), we use it to t produce a new trajectory s, (s)  s, (s)  ...  s 0 0 0 1 1 1 T note that when we generate this new trajectory, we use the real F and not its linear approximation to compute transitions, meaning that s  F(s,a) t1 t t then, go back to step 2 and repeat until some stopping criterion. .4 Linear Quadratic Gaussian (LQG) Often, inthereal word, wedont getto observe thefull states . For example, t an autonomous car could receive an image from a camera, which is merely an observation, and not the full state of the world. So far, we assumed that the state was available. As this might not hold true for most of the realworld problems, we need a new tool to model this situation: Partially Observable MDPs. A POMDP is an MDP with an extra observation layer. In other words, we introduce a new variable o , that follows some conditional distribution t given the current state s t o s  O(os) t t Formally, a finitehorizon POMDP is given by a tuple (S,O,A,P ,T,R) sa Within this framework, the general strategy is to maintain a belief state (distribution over states) based on the observation o ,...,o . Then, a policy 1 t in a POMDP maps this belief states to actions. In this section, well present a extension of LQR to this new setting. Assume that we observe y  Rn with m  n such that t (cid:) y  C s v t t t s  As B a w t1 t t t where C  Rnd is a compression matrix and v is the sensor noise (also t gaussian, like w ). Note that the reward function R(t) is left unchanged, as a t function of the state (not the observation) and action. Also, as distributions are gaussian, the belief state is also going to be gaussian. In this new frame work, lets give an overview of the strategy we are going to adopt to find the optimal policy: step 1 first, compute the distribution on the possible states (the belief state), based on the observations we have. In other words, we want to compute the mean s and the covariance  of tt tt (cid:0) (cid:1) s y ,...,y  N s , t 1 t tt tt to perform the computation efficiently over time, well use the Kalman Filter algorithm (used onboard Apollo Lunar Module!). step 2 now that we have the distribution, well use the mean s as the best tt approximation for s t step 3 then set the action a : L s where L comes from the regular LQR t t tt t algorithm. Intuitively, to understand why this works, notice that s is a noisy ap tt proximation of s (equivalent to adding more noise to LQR) but we proved t that LQR is independent of the noise! Step 1 needs to be explicated. Well cover a simple case where there is no action dependence in our dynamics (but the general case follows the same idea). Suppose that (cid:) s  As w , w  N(0, ) t1 t t t s y  C s v , v  N(0, ) t t t t y As noises are Gaussians, we can easily prove that the joint distribution is also Gaussian   s 1 .  . .    s   t  N (,) for some , y   1  . .   .  y t then,usingthemarginalformulasofgaussians(seeFactorAnalysisnotes), we would get (cid:0) (cid:1) s y ,...,y  N s , t 1 t tt tt However, computing the marginal distribution parameters using these formulaswouldbecomputationallyexpensive! Itwouldrequiremanipulating matrices of shape tt. Recall that inverting a matrix can be done in O(t3), and it would then have to be repeated over the time steps, yielding a cost in O(t4)! The Kalman filter algorithm provides a much better way of computing the mean and variance, by updating them over time in constant time in t! The kalman filter is based on two basics steps. Assume that we know the distribution of s y ,...,y : t 1 t predict step compute s y ,...,y t1 1 t update step compute s y ,...,y t1 1 t1 and iterate over time steps! The combination of the predict and update steps updates our belief states. In other words, the process looks like predict update predict (s y ,...,y )  (s y ,...,y )  (s y ,...,y )  ... t 1 t t1 1 t t1 1 t1 predict step Suppose that we know the distribution of (cid:0) (cid:1) s y ,...,y  N s , t 1 t tt tt then, the distribution over the next state is also a gaussian distribution (cid:0) (cid:1) s y ,...,y  N s , t1 1 t t1t t1t where (cid:) s  As t1t tt   A A(cid:)  t1t tt s update step given s and  such that t1t t1t (cid:0) (cid:1) s y ,...,y  N s , t1 1 t t1t t1t we can prove that (cid:0) (cid:1) s y ,...,y  N s , t1 1 t1 t1t1 t1t1 where (cid:) s  s K (y Cs ) t1t1 t1t t t1 t1t    K C  t1t1 t1t t t1t with K :  C(cid:)(C C(cid:)  )1 t t1t t1t y The matrix K is called the Kalman gain. t Now, if we have a closer look at the formulas, we notice that we dont need the observations prior to time step t! The update steps only depends on the previous distribution. Putting it all together, the algorithm first runs a forward pass to compute the K ,  and s (sometimes referred to as t tt tt s in the literature). Then, it runs a backward pass (the LQR updates) to compute the quantities  , and L . Finally, we recover the optimal policy t t t with a  L s . t t tt Chapter Policy Gradient (REINFORCE) We will present a modelfree algorithm called REINFORCE that does not requirethe notionof value functionsandQfunctions. Itturns outto bemore convenient to introduce REINFORCE in the finite horizon case, which will be assumed throughout this note: we use   (s ,a ,...,s ,a ,s ) to 0 0 T1 T1 T denote a trajectory, where T   is the length of the trajectory. Moreover, REINFORCEonlyappliestolearningarandomized policy. Weuse (as)  to denote the probability of the policy  outputting the action a at state s.  The other notations will be the same as in previous lecture notes. The advantage of applying REINFORCE is that we only need to assume that we can sample from the transition probabilities P  and can query the sa reward function R(s,a) at state s and action a,1 but we do not need to know the analytical form of the transition probabilities or the reward function. We do not explicitly learn the transition probabilities or the reward function either. Let s be sampled from some distribution . We consider optimizing the 0 expected total payoff of the policy  over the parameter  defined as.  (cid:) (cid:) T1 (cid:) () (cid:) E tR(s ,a ) (.1) t t t0 Recall that s  P and a   (s ). Also note that ()  t st1at1 t  t E [V (s )] if we ignore the difference between finite and infinite hori s0P 0 zon. 1In this notes we will work with the general setting where the reward depends on both the state and the action. We aim to use gradient ascent to maximize (). The main challenge we face here is to compute (or estimate) the gradient of () without the knowledge of theform of the reward function and the transition probabilities. Let P () denote the distribution of  (generated by the policy  ), and   let f()  (cid:)T1tR(s ,a ). We can rewrite () as t0 t t ()  E [f()] (.2) P  We face a similar situations in the variational autoencoder (VAE) setting covered in the previous lectures, where the we need to take the gradient w.r.t to a variable that shows up under the expectation  the distribution P  depends on . Recall that in VAE, we used the reparametrization techniques to address this problem. However it does not apply here because we do know not how to compute the gradient of the function f. (We only have an efficient way to evaluate the function f by taking a weighted sum of the observed rewards, but we do not necessarily know the reward function itself to compute the gradient.) The REINFORCE algorithm uses an another approach to estimate the gradient of (). We start with the following derivation: (cid:)  E [f()]   P ()f()d  P    (cid:)   (P ()f())d (swap integration with gradient)   (cid:)  ( P ())f()d (becaue f does not depend on )   (cid:)  P ()( logP ())f()d    (because logP ()  P  ())  P ()   E [( logP ())f()] (.3) P    Now we have a samplebased estimator for  E [f()]. Let (1),...,(n)  P  be n empirical samples from P (which are obtained by running the policy   for n times, with T steps for each run). We can estimate the gradient of  () by  E [f()]  E [( logP ())f()] (.4)  P P     n 1 (cid:)  ( logP ((i)))f((i)) (.5)   n i1 The next question is how to compute logP (). We derive an analyt  ical formula for logP () and compute its gradient w.r.t  (using auto  differentiation). Using the definition of , we have P ()  (s ) (a s )P (s ) (a s )P (s )P (s ) (.6)  0  0 0 s0a0 1  1 1 s1a1 2 sT1aT1 T Here recall that  to used to denote the density of the distribution of s . It 0 follows that logP ()  log(s )log (a s )logP (s )log (a s )  0  0 0 s0a0 1  1 1 logP (s )logP (s ) (.7) s1a1 2 sT1aT1 T Taking gradient w.r.t to , we obtain  logP ()   log (a s ) log (a s ) log (a s )     0 0   1 1   T1 T1 Note that many of the terms disappear because they dont depend on  and thushavezerogradients. (Thisissomewhatimportantwedontknowhow to evaluate those terms such as logP (s ) because we dont have access to s0a0 1 the transition probabilities, but luckily those terms have zero gradients!) Plugging the equation above into equation (.4), we conclude that (cid:)(cid:) (cid:) (cid:) T1 (cid:)  ()   E [f()]  E  log (a s ) f()   P P   t t   t0 (cid:)(cid:) (cid:) (cid:) (cid:)(cid:) T1 T1 (cid:) (cid:)  E  log (a s )  tR(s ,a ) P   t t t t  t0 t0 (.8) We estimate the RHS of the equation above by empirical sample trajectories, and the estimate is unbiased. The vanilla REINFORCE algorithm iteratively updates the parameter by gradient ascent using the estimated gradients. Interpretation of the policy gradient formula (.8). The quantity  P ()  (cid:)T1 log (a s ) is intuitively the direction of the change   t0   t t of  that will make the trajectory  more likely to occur (or increase the probability of choosing action a ,...,a ), and f() is the total payoff of 0 t1 this trajectory. Thus, by taking a gradient step, intuitively we are trying to improve the likelihood of all the trajectories, but with a different emphasis or weight for each  (or for each set of actions a ,a ,...,a ). If  is very 0 1 t1 rewarding (that is, f() is large), we try very hard to move in the direction that can increase the probability of the trajectory  (or the direction that increases the probability of choosing a ,...,a ), and if  has low payoff, 0 t1 we try less hard with a smaller weight. An interesting fact that follows from formula (.3) is that (cid:) (cid:) T1 (cid:) E  log (a s )  0 (.9) P   t t  t0 To see this, we take f()  1 (that is, the reward is always a constant), then the LHS of (.8) is zero because the payoff is always a fixed constant (cid:)T t. Thus the RHS of (.8) is also zero, which implies (.9). t0 In fact, one can verify that E  log (a s )  0 for any fixed t at  (st)   t t ands .2 Thisfacthastwoconsequences. First,wecansimplifyformula(.8) t to (cid:) (cid:) (cid:)(cid:) T1 T1 (cid:) (cid:)  ()  E  log (a s ) jR(s ,a )  P   t t j j  t0 j0 (cid:) (cid:) (cid:)(cid:) T1 T1 (cid:) (cid:)  E  log (a s ) jR(s ,a ) (.) P   t t j j  t0 jt where the second equality follows from (cid:) (cid:) (cid:)(cid:) (cid:) E  log (a s ) jR(s ,a ) P   t t j j  0jt (cid:) (cid:) (cid:)(cid:) (cid:)  E E[ log (a s )s ,a ,...,s ,a ,s ] jR(s ,a )   t t 0 0 t1 t1 t j j 0jt  0 (because E[ log (a s )s ,a ,...,s ,a ,s ]  0)   t t 0 0 t1 t1 t Note that here we used the law of total expectation. The outer expecta tion in the second line above is over the randomness of s ,a ,...,a ,s , 0 0 t1 t whereas the inner expectation is over the randomness of a (conditioned on t s ,a ,...,a ,s .) We see that weve made the estimator slightly simpler. 0 0 t1 t The second consequence of E  log (a s )  0 is the following: for at  (st)   t t any value B(s ) that only depends on s , it holds that t t E [ log (a s )B(s )] P   t t t   E[E[ log (a s )s ,a ,...,s ,a ,s ]B(s )]   t t 0 0 t1 t1 t t  0 (because E[ log (a s )s ,a ,...,s ,a ,s ]  0)   t t 0 0 t1 t1 t 2In general, its true that E [logp (x)]0. xp  Again here we used the law of total expectation. The outer expecta tion in the second line above is over the randomness of s ,a ,...,a ,s , 0 0 t1 t whereas the inner expectation is over the randomness of a (conditioned on t s ,a ,...,a ,s .) It follows from equation (.) and the equation above 0 0 t1 t that (cid:) (cid:) (cid:)(cid:) T1 T1 (cid:) (cid:)  ()  E  log (a s ) jR(s ,a )tB(s )  P   t t j j t  t0 jt (cid:) (cid:) (cid:)(cid:) T1 T1 (cid:) (cid:)  E  log (a s )t jtR(s ,a )B(s ) P   t t j j t  t0 jt (.) Therefore, we will get a different estimator for estimating the () with a difference choice of B(). The benefit of introducing a proper B()  which is often referred to as a baseline  is that it helps reduce the variance of the estimator.3 It turns out that a near optimal estimator would be the expected (cid:) (cid:) futurepayoffE (cid:)T1jtR(s ,a )s , whichisprettymuchthesameasthe jt j j t value function V (s ) (if we ignore the difference between finite and infinite t horizon.) Here one could estimate the value function V () in a crude way, because its precise value doesnt influence the mean of the estimator but only the variance. This leads to a policy gradient algorithm with baselines stated in Algorithm 7.4 3As a heuristic but illustrating example, suppose for a fixed t, the future reward (cid:)T1jtR(s ,a ) randomly takes two values 1 and 2 with equal proba jt j j bility, and the corresponding values for  log (a s ) are vector z and z. (Note that   t t because E[ log (a s )]  0, if  log (a s ) can only take two values uniformly,   t t   t t then the two values have to two vectors in an opposite direction.) In this case, without subtracting the baseline, the estimators take two values (1)z and (2)z, whereas after subtracting a baseline of , the estimator has two values z and 2z. The latter estimator has much lower variance compared to the original estimator. 4We note that the estimator of the gradient in the algorithm does not exactly match the equation .. If we multiply t in the summand of equation (.), then they will exactly match. Removing such discount factors empirically works well because it gives a large update. Algorithm 7 Vanilla policy gradient with baseline for i  1, do Collect a set of trajectories by executing the current policy. Use R t as a shorthand for (cid:)T1jtR(s ,a ) jt j j Fit the baseline by finding a function B that minimizes (cid:)(cid:) (R B(s ))2 (.) t t  t Update the policy parameter  with the gradient estimator (cid:)(cid:)  log (a s )(R B(s )) (.)   t t t t  t Bibliography Mikhail Belkin, Daniel Hsu, Siyuan Ma, and Soumik Mandal. Reconciling modern machinelearning practice and the classical biasvariance trade off. Proceedings of the National Academy of Sciences, ():, . Mikhail Belkin, Daniel Hsu, and Ji Xu. Two models of double descent for weak features. SIAM Journal on Mathematics of Data Science, 2(4): , . David M Blei, Alp Kucukelbir, and Jon D McAuliffe. Variational inference: A review for statisticians. Journal of the American Statistical Association, ():, . Rishi Bommasani, Drew A Hudson, Ehsan Adeli, Russ Altman, Simran Arora, Sydney von Arx, Michael S Bernstein, Jeannette Bohg, Antoine Bosselut, Emma Brunskill, et al. On the opportunities and risks of foun dation models. arXiv preprint arXiv:., . Tom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared D Ka plan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sas try,AmandaAskell,etal. Languagemodelsarefewshotlearners. Advances in neural information processing systems, :, . Ting Chen, Simon Kornblith, Mohammad Norouzi, and Geoffrey Hinton. A simple framework for contrastive learning of visual representations. In International Conference on Machine Learning, pages . PMLR, . Jacob Devlin, MingWei Chang, Kenton Lee, and Kristina Toutanova. Bert: Pretraining of deep bidirectional transformers for language understand ing. In Proceedings of the Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Tech nologies, Volume 1 (Long and Short Papers), pages , . Jeff Z HaoChen, Colin Wei, Jason D Lee, and Tengyu Ma. Shape matters: Understanding the implicit bias of the noise covariance. arXiv preprint arXiv:., . Trevor Hastie, Andrea Montanari, Saharon Rosset, and Ryan J Tibshirani. Surprises in highdimensional ridgeless least squares interpolation. . Trevor Hastie, Andrea Montanari, Saharon Rosset, and Ryan J Tibshirani. Surprises in highdimensional ridgeless least squares interpolation. The Annals of Statistics, (2):, . Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In Proceedings of the IEEE conference on computer vision and pattern recognition, pages , . Gareth James, Daniela Witten, Trevor Hastie, and Robert Tibshirani. An introduction to statistical learning, second edition, volume . Springer, . Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic opti mization. arXiv preprint arXiv:., . DiederikPKingmaandMaxWelling. Autoencodingvariationalbayes. arXiv preprint arXiv:., . Yuping Luo, Huazhe Xu, Yuanzhi Li, Yuandong Tian, Trevor Darrell, and Tengyu Ma. Algorithmic framework for modelbased deep reinforcement learningwiththeoreticalguarantees. InInternational Conference on Learn ing Representations, . SongMeiandAndreaMontanari. Thegeneralizationerrorofrandomfeatures regression: Precise asymptotics and the double descent curve. Communi cations on Pure and Applied Mathematics, (4):, . Preetum Nakkiran. More data can hurt for linear regression: Samplewise double descent. . PreetumNakkiran,PrayaagVenkat,ShamKakade,andTengyuMa. Optimal regularization can mitigate double descent. . ManfredOpper. Statisticalmechanicsoflearning: Generalization. The hand book of brain theory and neural networks, pages , . Manfred Opper. Learning to generalize. Frontiers of Life, 3(part 2):, . Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Lukasz Kaiser, and Illia Polosukhin. Attention is all you need. arXiv preprint arXiv:., . Blake Woodworth, Suriya Gunasekar, Jason D Lee, Edward Moroshko, Pe dro Savarese, Itay Golan, Daniel Soudry, and Nathan Srebro. Kernel and richregimesinoverparametrizedmodels. arXiv preprint arXiv:., .